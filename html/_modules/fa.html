<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>fa &mdash; FAdo 1.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="FAdo 1.2 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">FAdo 1.2 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for fa</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;**Finite automata manipulation.**</span>

<span class="sd">Deterministic and non-deterministic automata manipulation, conversion and evaluation.</span>

<span class="sd">.. *Authors:* Rogério Reis &amp; Nelma Moreira</span>

<span class="sd">.. *This is part of FAdo project*   http://fado.dcc.fc.up.pt.</span>

<span class="sd">.. *Copyright:* 1999-2014 Rogério Reis &amp; Nelma Moreira {rvr,nam}@dcc.fc.up.pt</span>

<span class="sd">.. This program is free software; you can redistribute it and/or</span>
<span class="sd">   modify it under the terms of the GNU General Public License as published</span>
<span class="sd">   by the Free Software Foundation; either version 2 of the License, or</span>
<span class="sd">   (at your option) any later version.</span>

<span class="sd">   This program is distributed in the hope that it will be useful,</span>
<span class="sd">   but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="sd">   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="sd">   for more details.</span>

<span class="sd">   You should have received a copy of the GNU General Public License along</span>
<span class="sd">   with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="sd">   675 Mass Ave, Cambridge, MA 02139, USA.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="kn">import</span> <span class="nn">reex</span>
<span class="kn">from</span> <span class="nn">common</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">unionFind</span> <span class="kn">import</span> <span class="n">UnionFind</span>
<span class="kn">import</span> <span class="nn">graphs</span>


<div class="viewcode-block" id="SemiDFA"><a class="viewcode-back" href="../index.html#fa.SemiDFA">[docs]</a><span class="k">class</span> <span class="nc">SemiDFA</span><span class="p">(</span><span class="n">Drawable</span><span class="p">):</span>
    <span class="c"># noinspection PyUnresolvedReferences</span>
    <span class="sd">&quot;&quot;&quot;Class of automata without initial or final states</span>

<span class="sd">        :var States: list of states</span>
<span class="sd">        :type States: list of objects</span>
<span class="sd">        :var delta: transition function</span>
<span class="sd">        :type delta: dict</span>
<span class="sd">        :var Sigma: alphabet set</span>
<span class="sd">        :type Sigma: set of str&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<div class="viewcode-block" id="SemiDFA.dotDrawState"><a class="viewcode-back" href="../index.html#fa.SemiDFA.dotDrawState">[docs]</a>    <span class="k">def</span> <span class="nf">dotDrawState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dot representation of a state</span>

<span class="sd">        :param sti: state index</span>
<span class="sd">        :type sti: int</span>
<span class="sd">        :param sep: separator</span>
<span class="sd">        :type sep: str        </span>
<span class="sd">        :rtype: str &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;node [shape = circle]; </span><span class="se">\&quot;</span><span class="s">{0:s}</span><span class="se">\&quot;</span><span class="s">;{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">]</span><span class="o">.</span><span class="n">__str__</span><span class="p">(),</span> <span class="n">sep</span><span class="p">)</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="SemiDFA.dotDrawTransition"><a class="viewcode-back" href="../index.html#fa.SemiDFA.dotDrawTransition">[docs]</a>    <span class="k">def</span> <span class="nf">dotDrawTransition</span><span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="n">lbl1</span><span class="p">,</span> <span class="n">st2</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw a transition in dot format</span>

<span class="sd">        :param st1: departing state</span>
<span class="sd">        :type st1: str</span>
<span class="sd">        :param lbl1: label</span>
<span class="sd">        :type lbl1: str</span>
<span class="sd">        :param st2: arriving state</span>
<span class="sd">        :type st2: str</span>
<span class="sd">        :param sep: separator</span>
<span class="sd">        :type sep: str</span>
<span class="sd">        :rtype: str &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">{0:s}</span><span class="se">\&quot;</span><span class="s"> -&gt; </span><span class="se">\&quot;</span><span class="s">{1:s}</span><span class="se">\&quot;</span><span class="s"> [label = </span><span class="se">\&quot;</span><span class="s">{2:s}</span><span class="se">\&quot;</span><span class="s">];{3:s} &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="n">st2</span><span class="p">,</span> <span class="n">lbl1</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SemiDFA.dotFormat"><a class="viewcode-back" href="../index.html#fa.SemiDFA.dotFormat">[docs]</a>    <span class="k">def</span> <span class="nf">dotFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s">&quot;20,20&quot;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">&quot;LR&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dot format of automata</span>

<span class="sd">        :param size: image size</span>
<span class="sd">        :type size: str</span>
<span class="sd">        :param direction: direction of drawing</span>
<span class="sd">        :type size: str</span>
<span class="sd">        :param sep: separator</span>
<span class="sd">        :type sep: str</span>
<span class="sd">        :rtype: str &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;digraph finite_state_machine {{{0:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;rankdir={0:s};{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;size=</span><span class="se">\&quot;</span><span class="s">{0:s}</span><span class="se">\&quot;</span><span class="s">;{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">sn</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">si</span><span class="p">])</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;node [shape = point]; </span><span class="se">\&quot;</span><span class="s">dummy{0:s}</span><span class="se">\&quot;</span><span class="s">{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dotDrawState</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">dummy{0:s}</span><span class="se">\&quot;</span><span class="s"> -&gt; </span><span class="se">\&quot;</span><span class="s">{1:s}</span><span class="se">\&quot;</span><span class="s">;{2:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">si</span><span class="p">]),</span> <span class="n">sep</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dotDrawTransition</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">si</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">si</span><span class="p">][</span><span class="n">s1</span><span class="p">]]))</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;}}{0:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>


<span class="c"># noinspection PyUnresolvedReferences</span></div></div>
<div class="viewcode-block" id="FA"><a class="viewcode-back" href="../index.html#fa.FA">[docs]</a><span class="k">class</span> <span class="nc">FA</span><span class="p">(</span><span class="n">Drawable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for Finite Automata.</span>

<span class="sd">    :var States: set of states</span>
<span class="sd">    :type States: list of objects</span>
<span class="sd">    :var Sigma: alphabet set</span>
<span class="sd">    :type Sigma: set of str</span>
<span class="sd">    :var Initial: the initial state</span>
<span class="sd">    :var Final: set of final states</span>
<span class="sd">    :type Final: set of int</span>
<span class="sd">    :var delta: the transition function</span>

<span class="sd">    .. note::</span>
<span class="sd">       This is just an abstract class.</span>
<span class="sd">       **Not to be used directly!!**&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&#39;Official&#39; string representation</span>

<span class="sd">        :returns: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&#39;FA({0:&gt;s})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__str__</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&#39;Informal&#39; string representation</span>

<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="c"># noinspection PyProtectedMember</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_States</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_Sigma</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_lstInitial</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_Final</span>
        <span class="n">e</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lstTransitions</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="FA.evalSymbol"><a class="viewcode-back" href="../index.html#fa.FA.evalSymbol">[docs]</a>    <span class="k">def</span> <span class="nf">evalSymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluation of a single symbol&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_s_States</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_s_Sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_s_Final</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Size: number of states</span>

<span class="sd">        :rtype: int&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>

<div class="viewcode-block" id="FA.dotDrawState"><a class="viewcode-back" href="../index.html#fa.FA.dotDrawState">[docs]</a>    <span class="k">def</span> <span class="nf">dotDrawState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Draw a state in dot format</span>

<span class="sd">        :arg sti: index of the state</span>
<span class="sd">        :arg sep: separator</span>
<span class="sd">        :type sep: str</span>
<span class="sd">        :type sti: int</span>
<span class="sd">        :rtype: str &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;node [shape = doublecircle]; </span><span class="se">\&quot;</span><span class="s">{0:s}</span><span class="se">\&quot;</span><span class="s">;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">]),</span> <span class="n">sep</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;node [shape = circle]; </span><span class="se">\&quot;</span><span class="s">{0:s}</span><span class="se">\&quot;</span><span class="s">;{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">]),</span> <span class="n">sep</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FA.same_nullability"><a class="viewcode-back" href="../index.html#fa.FA.same_nullability">[docs]</a>    <span class="k">def</span> <span class="nf">same_nullability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if this two states have the same nullability</span>

<span class="sd">        :param s1: state index</span>
<span class="sd">        :param s2: state index</span>
<span class="sd">        :type s1: int</span>
<span class="sd">        :type s2: int</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="ow">is</span> <span class="p">(</span><span class="n">s2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
</div>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">succintTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Colapsed transitions&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="FA.dotDrawTransition"><a class="viewcode-back" href="../index.html#fa.FA.dotDrawTransition">[docs]</a>    <span class="k">def</span> <span class="nf">dotDrawTransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">st2</span><span class="p">,</span> <span class="n">sep</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw a transition in dot format</span>

<span class="sd">        :param str st1: departing state</span>
<span class="sd">        :param str sym: label</span>
<span class="sd">        :param str st2: arriving state</span>
<span class="sd">        :param str sep: separator&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="FA.initialSet"><a class="viewcode-back" href="../index.html#fa.FA.initialSet">[docs]</a>    <span class="k">def</span> <span class="nf">initialSet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The set of initial states</span>

<span class="sd">        :returns: the set of the initial states</span>
<span class="sd">        :rtype: set of States&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
</div>
<div class="viewcode-block" id="FA.initialP"><a class="viewcode-back" href="../index.html#fa.FA.initialP">[docs]</a>    <span class="k">def</span> <span class="nf">initialP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Tests if a state is initial</span>

<span class="sd">        :param int state: state index</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
</div>
<div class="viewcode-block" id="FA.finalP"><a class="viewcode-back" href="../index.html#fa.FA.finalP">[docs]</a>    <span class="k">def</span> <span class="nf">finalP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Tests if a state is final</span>

<span class="sd">        :param int state: state index</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span>
</div>
<div class="viewcode-block" id="FA.finalsP"><a class="viewcode-back" href="../index.html#fa.FA.finalsP">[docs]</a>    <span class="k">def</span> <span class="nf">finalsP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Tests if al the states in a set are final</span>

<span class="sd">        :param set states: set of state indexes</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        .. versionadded:: 1.0&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">states</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_namesToString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;All state names are transformed in strings&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
            <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="FA.hasStateIndexP"><a class="viewcode-back" href="../index.html#fa.FA.hasStateIndexP">[docs]</a>    <span class="k">def</span> <span class="nf">hasStateIndexP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if a state index pertains to an FA</span>

<span class="sd">        :param int st: index of the state</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">st</span> <span class="o">&gt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="FA.addState"><a class="viewcode-back" href="../index.html#fa.FA.addState">[docs]</a>    <span class="k">def</span> <span class="nf">addState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a new state to an FA. If no name is given a new name is created.</span>

<span class="sd">        :param object name: Name of the state to be added</span>
<span class="sd">        :returns: Current number of states (the new state index)</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        :raises DuplicateName: if a state with that name already exists&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">iname</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">iname</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">iname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
                <span class="n">iname</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">iname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DuplicateName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</div>
<div class="viewcode-block" id="FA.deleteState"><a class="viewcode-back" href="../index.html#fa.FA.deleteState">[docs]</a>    <span class="k">def</span> <span class="nf">deleteState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the given state and the transitions related with that state.</span>

<span class="sd">        :param int sti: index of the state to be removed</span>
<span class="sd">        :raises DFAstateUnknown: if state index does not exist&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sti</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DFAstateUnknown</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_deleteRefInDelta</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">sti</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleteRefInitial</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sti</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">sti</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="FA.words"><a class="viewcode-back" href="../index.html#fa.FA.words">[docs]</a>    <span class="k">def</span> <span class="nf">words</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stringo</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lexicografical word generator</span>

<span class="sd">        .. attention:: does not generate the empty word</span>

<span class="sd">        :param bool stringo: are words strings?</span>

<span class="sd">        .. versionadded:: 0.9.8&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_translate</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s1</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s1</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="n">r</span><span class="p">[</span><span class="n">z</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">s</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span>

        <span class="kn">import</span> <span class="nn">itertools</span>

        <span class="n">ss</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="n">n0</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">_translate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">stringo</span><span class="p">)</span>
            <span class="n">n0</span> <span class="o">+=</span> <span class="mi">1</span>
</div>
<div class="viewcode-block" id="FA.equivalentP"><a class="viewcode-back" href="../index.html#fa.FA.equivalentP">[docs]</a>    <span class="k">def</span> <span class="nf">equivalentP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test equivalence</span>

<span class="sd">        :param other: the other automata</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        .. versionadded:: 0.9.6&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>
</div>
<div class="viewcode-block" id="FA.setInitial"><a class="viewcode-back" href="../index.html#fa.FA.setInitial">[docs]</a>    <span class="k">def</span> <span class="nf">setInitial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stateindex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the initial state of a FA</span>

<span class="sd">        :param int stateindex: index of the initial state&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="n">stateindex</span>
</div>
<div class="viewcode-block" id="FA.setFinal"><a class="viewcode-back" href="../index.html#fa.FA.setFinal">[docs]</a>    <span class="k">def</span> <span class="nf">setFinal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statelist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the final states of the FA</span>

<span class="sd">        :param int|list|set statelist: a list (or set) of final states indexes</span>

<span class="sd">        .. caution::</span>
<span class="sd">           it erases any previous definition of the final state set.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">statelist</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FA.addFinal"><a class="viewcode-back" href="../index.html#fa.FA.addFinal">[docs]</a>    <span class="k">def</span> <span class="nf">addFinal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stateindex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A new state is added to the already defined set of final states.</span>

<span class="sd">        :param stateindex: index of the new final state</span>
<span class="sd">        :type stateindex: int&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">stateindex</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FA.delFinals"><a class="viewcode-back" href="../index.html#fa.FA.delFinals">[docs]</a>    <span class="k">def</span> <span class="nf">delFinals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletes all the information about final states.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
</div>
<div class="viewcode-block" id="FA.delFinal"><a class="viewcode-back" href="../index.html#fa.FA.delFinal">[docs]</a>    <span class="k">def</span> <span class="nf">delFinal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletes a state from the final states list</span>

<span class="sd">        :param int st: state to be marked as not final&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="o">-</span> <span class="p">{</span><span class="n">st</span><span class="p">}</span>
</div>
<div class="viewcode-block" id="FA.setSigma"><a class="viewcode-back" href="../index.html#fa.FA.setSigma">[docs]</a>    <span class="k">def</span> <span class="nf">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbolSet</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Defines the alphabet for the FA.</span>

<span class="sd">        :param list|set symbolSet: alphabet symbols&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbolSet</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FA.addSigma"><a class="viewcode-back" href="../index.html#fa.FA.addSigma">[docs]</a>    <span class="k">def</span> <span class="nf">addSigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sym</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a new symbol to the alphabet.</span>

<span class="sd">        :param str sym: symbol to be added</span>
<span class="sd">        :raises DFAepsilonRedefenition: if sym is Epsilon</span>

<span class="sd">        .. note::</span>
<span class="sd">            * There is no problem with duplicate symbols because Sigma is a Set.</span>
<span class="sd">            * No symbol Epsilon can be added.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAepsilonRedefinition</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FA.stateIndex"><a class="viewcode-back" href="../index.html#fa.FA.stateIndex">[docs]</a>    <span class="k">def</span> <span class="nf">stateIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">autoCreate</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Index of given state name.</span>

<span class="sd">        :param object name: name of the state</span>
<span class="sd">        :param bool autoCreate: flag to create state if not already done</span>
<span class="sd">        :returns: state index</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        :raises DFAstateUnknown: if the state name is unknown and autoCreate==False</span>

<span class="sd">        .. note::</span>
<span class="sd">           Replaces stateName</span>

<span class="sd">        .. note::</span>
<span class="sd">           If the state name is not known and flag is set creates it on the fly</span>

<span class="sd">        .. versionadded:: 1.0&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">autoCreate</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DFAstateUnknown</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</div>
    <span class="nd">@deprecated</span>
<div class="viewcode-block" id="FA.stateName"><a class="viewcode-back" href="../index.html#fa.FA.stateName">[docs]</a>    <span class="k">def</span> <span class="nf">stateName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">autoCreate</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Index of given state name.</span>

<span class="sd">        :param object name: name of the state</span>
<span class="sd">        :param bool autoCreate: flag to create state if not already done</span>
<span class="sd">        :returns: state index</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        :raises DFAstateUnknown: if the state name is unknown and autoCreate==False</span>

<span class="sd">        .. deprecated:: 1.0</span>
<span class="sd">           Use: :func:`stateIndex` instead&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">autoCreate</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FA.indexList"><a class="viewcode-back" href="../index.html#fa.FA.indexList">[docs]</a>    <span class="k">def</span> <span class="nf">indexList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lstn</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a list of stateNames into a set of stateIndexes.</span>

<span class="sd">        :param list lstn: list of names</span>
<span class="sd">        :returns: the list of state indexes</span>
<span class="sd">        :rtype: Set of int</span>
<span class="sd">        :raises DFAstateUnknown: if a state name is unknown&quot;&quot;&quot;</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lstn</span><span class="p">:</span>
            <span class="n">lst</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">lst</span>
</div>
<div class="viewcode-block" id="FA.plus"><a class="viewcode-back" href="../index.html#fa.FA.plus">[docs]</a>    <span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plus of a FA (star without the adding of epsilon)</span>

<span class="sd">        .. versionadded:: 0.9.6&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FA.disjunction"><a class="viewcode-back" href="../index.html#fa.FA.disjunction">[docs]</a>    <span class="k">def</span> <span class="nf">disjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A simple literate invocation of __or__</span>

<span class="sd">        :param other: the other FA&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__or__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FA.disj"><a class="viewcode-back" href="../index.html#fa.FA.disj">[docs]</a>    <span class="k">def</span> <span class="nf">disj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Another simple literate invocation of __or__</span>

<span class="sd">        :param other: the other FA</span>

<span class="sd">        .. versionadded:: 0.9.6&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__or__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FA.union"><a class="viewcode-back" href="../index.html#fa.FA.union">[docs]</a>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A simple literate invocation of __or__</span>

<span class="sd">        :param other: right hand operand&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__or__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FA.conjunction"><a class="viewcode-back" href="../index.html#fa.FA.conjunction">[docs]</a>    <span class="k">def</span> <span class="nf">conjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A simple literate invocation of __and__</span>

<span class="sd">        :param other: the other FA</span>

<span class="sd">        .. versionadded:: 0.9.6&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__and__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FA.renameState"><a class="viewcode-back" href="../index.html#fa.FA.renameState">[docs]</a>    <span class="k">def</span> <span class="nf">renameState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename a given state.</span>

<span class="sd">        :param int st: state index</span>
<span class="sd">        :param object name: name</span>
<span class="sd">        :return: self</span>

<span class="sd">        .. note::</span>
<span class="sd">            Deals gacefully both with int and str names in the case of name collision.</span>

<span class="sd">        .. attention::</span>
<span class="sd">           the object is modified in place&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">st</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">while</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">+=</span> <span class="n">name</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">while</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">+=</span> <span class="s">&quot;+&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">DuplicateName</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="FA.renameStates"><a class="viewcode-back" href="../index.html#fa.FA.renameStates">[docs]</a>    <span class="k">def</span> <span class="nf">renameStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nameList</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Renames all states using a new list of names.</span>

<span class="sd">        :param list nameList: list of new names</span>
<span class="sd">        :raises DFAerror: if provided list is too short</span>
<span class="sd">        :return: self</span>

<span class="sd">        .. note::</span>
<span class="sd">           If no list of names is given, state indexes are used.</span>

<span class="sd">        .. attention::</span>
<span class="sd">           the object is modified in place&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nameList</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nameList</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">DFAerror</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">renameState</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nameList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="FA.eliminateDeadName"><a class="viewcode-back" href="../index.html#fa.FA.eliminateDeadName">[docs]</a>    <span class="k">def</span> <span class="nf">eliminateDeadName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Eliminates dead state name (common.DeadName) renaming the state</span>

<span class="sd">        .. attention::</span>
<span class="sd">           works inplace</span>

<span class="sd">        .. versionadded:: 1.2&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">DeadName</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">DFAstateUnknown</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">renameState</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="FA.noBlankNames"><a class="viewcode-back" href="../index.html#fa.FA.noBlankNames">[docs]</a>    <span class="k">def</span> <span class="nf">noBlankNames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Eliminates blank names</span>

<span class="sd">        :return: self</span>

<span class="sd">        .. attention::</span>
<span class="sd">           in place transformation&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="FA.reversal"><a class="viewcode-back" href="../index.html#fa.FA.reversal">[docs]</a>    <span class="k">def</span> <span class="nf">reversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a NFA that recognizes the reversal of the language</span>

<span class="sd">        :returns: NFA recognizing reversal language</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">rev</span> <span class="o">=</span> <span class="n">NFA</span><span class="p">()</span>
        <span class="n">rev</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">rev</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverseTransitions</span><span class="p">(</span><span class="n">rev</span><span class="p">)</span>
        <span class="n">rev</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">])</span>
        <span class="n">rev</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rev</span>
</div>
<div class="viewcode-block" id="FA.countTransitions"><a class="viewcode-back" href="../index.html#fa.FA.countTransitions">[docs]</a>    <span class="k">def</span> <span class="nf">countTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the size of FA transitionwise</span>

<span class="sd">        :returns: the number of transitions</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        .. versionchanged:: 1.0&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="FA.inputS"><a class="viewcode-back" href="../index.html#fa.FA.inputS">[docs]</a>    <span class="k">def</span> <span class="nf">inputS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Input labels coming out of state i</span>

<span class="sd">        :param int i: state</span>
<span class="sd">        :returns: set of input labels</span>
<span class="sd">        :rtype: set of str</span>

<span class="sd">        .. versionadded:: 1.0&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{}))</span>
</div>
    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="FA.succintTransitions"><a class="viewcode-back" href="../index.html#fa.FA.succintTransitions">[docs]</a>    <span class="k">def</span> <span class="nf">succintTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Collapsed transitions</span>
<span class="sd">        :rtype: list&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="FA.dotFormat"><a class="viewcode-back" href="../index.html#fa.FA.dotFormat">[docs]</a>    <span class="k">def</span> <span class="nf">dotFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s">&quot;20,20&quot;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">&quot;LR&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A dot representation</span>

<span class="sd">        :param str direction: direction of drawing</span>
<span class="sd">        :param str size: size of image</span>
<span class="sd">        :param str sep: line separator</span>
<span class="sd">        :return: the dot representation</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        .. versionadded:: 0.9.6</span>

<span class="sd">        .. versionchanged:: 0.9.8&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;digraph finite_state_machine {{{0:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;rankdir={0:s};{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;size=</span><span class="se">\&quot;</span><span class="s">{0:s}</span><span class="se">\&quot;</span><span class="s">;{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;node [shape = point]; dummy{0:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="n">niStates</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dotDrawState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;dummy -&gt; </span><span class="se">\&quot;</span><span class="s">{0:s}</span><span class="se">\&quot;</span><span class="s">{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]),</span> <span class="n">sep</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="n">niStates</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dotDrawState</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">succintTransitions</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dotDrawTransition</span><span class="p">(</span><span class="n">si</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">si</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">si</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;}}{0:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

</div></div>
<div class="viewcode-block" id="OFA"><a class="viewcode-back" href="../index.html#fa.OFA">[docs]</a><span class="k">class</span> <span class="nc">OFA</span><span class="p">(</span><span class="n">FA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Base class for one-way automata</span>
<span class="sd">    .. inheritance-diagram:: OFA&quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="OFA.succintTransitions"><a class="viewcode-back" href="../index.html#fa.OFA.succintTransitions">[docs]</a>    <span class="k">def</span> <span class="nf">succintTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Collapsed transitions&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="OFA.evalSymbol"><a class="viewcode-back" href="../index.html#fa.OFA.evalSymbol">[docs]</a>    <span class="k">def</span> <span class="nf">evalSymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Eval symbol&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="OFA.addTransition"><a class="viewcode-back" href="../index.html#fa.OFA.addTransition">[docs]</a>    <span class="k">def</span> <span class="nf">addTransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">st2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add transition</span>
<span class="sd">        :param int st1: departing state</span>
<span class="sd">        :param str sym: label</span>
<span class="sd">        :param int st2: arriving state&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="OFA.stateChildren"><a class="viewcode-back" href="../index.html#fa.OFA.stateChildren">[docs]</a>    <span class="k">def</span> <span class="nf">stateChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; To be implemented below</span>

<span class="sd">        :param s: state</span>
<span class="sd">        :rtype: list&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="k">def</span> <span class="nf">_deleteRefTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete transition</span>

<span class="sd">        :param int src: source state</span>
<span class="sd">        :param str sym: label</span>
<span class="sd">        :param int dest: target state&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">dest</span><span class="p">:</span>
            <span class="k">del</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">])</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="OFA.dotDrawTransition"><a class="viewcode-back" href="../index.html#fa.OFA.dotDrawTransition">[docs]</a>    <span class="k">def</span> <span class="nf">dotDrawTransition</span><span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">st2</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Draw a transition in Dot Format</span>

<span class="sd">        :param str st1: starting state</span>
<span class="sd">        :param str st2: ending state</span>
<span class="sd">        :param str label: symbol</span>
<span class="sd">        :param str sep: separator</span>
<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">{0:s}</span><span class="se">\&quot;</span><span class="s"> -&gt; </span><span class="se">\&quot;</span><span class="s">{1:s}</span><span class="se">\&quot;</span><span class="s"> [label = </span><span class="se">\&quot;</span><span class="s">{2:s}</span><span class="se">\&quot;</span><span class="s">];{3:s} &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="n">st2</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
</div>
    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="OFA.initialComp"><a class="viewcode-back" href="../index.html#fa.OFA.initialComp">[docs]</a>    <span class="k">def</span> <span class="nf">initialComp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initial component</span>

<span class="sd">        :rtype: list&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_getTags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="OFA.usefulStates"><a class="viewcode-back" href="../index.html#fa.OFA.usefulStates">[docs]</a>    <span class="k">def</span> <span class="nf">usefulStates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; To be implemented below &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="OFA.deleteStates"><a class="viewcode-back" href="../index.html#fa.OFA.deleteStates">[docs]</a>    <span class="k">def</span> <span class="nf">deleteStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">del_states</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; To be implemented below</span>

<span class="sd">        :param del_states: states to be deleted</span>
<span class="sd">        :type del_states: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="OFA.toGFA"><a class="viewcode-back" href="../index.html#fa.OFA.toGFA">[docs]</a>    <span class="k">def</span> <span class="nf">toGFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; To be implemented below</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="OFA.finalCompP"><a class="viewcode-back" href="../index.html#fa.OFA.finalCompP">[docs]</a>    <span class="k">def</span> <span class="nf">finalCompP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;To be implemented below</span>

<span class="sd">        :param s: state</span>
<span class="sd">        :rtype: list&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="OFA.uniqueRepr"><a class="viewcode-back" href="../index.html#fa.OFA.uniqueRepr">[docs]</a>    <span class="k">def</span> <span class="nf">uniqueRepr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Abstract method&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="OFA.emptyP"><a class="viewcode-back" href="../index.html#fa.OFA.emptyP">[docs]</a>    <span class="k">def</span> <span class="nf">emptyP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Tests if the automaton accepts a empty language</span>

<span class="sd">        :rtype: bool</span>

<span class="sd">        .. versionadded:: 1.0&quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialComp</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="OFA.dump"><a class="viewcode-back" href="../index.html#fa.OFA.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a python representation of the object</span>

<span class="sd">        :returns: the python representation (Tags,States,Sigma,delta,Initial,Final)</span>
<span class="sd">        :rtype: tuple &quot;&quot;&quot;</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getTags</span><span class="p">()</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">forceIterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)]</span>
        <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__len__</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                    <span class="n">ci</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ci</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">forceIterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]):</span>
                    <span class="n">dt</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">F</span>
</div>
<div class="viewcode-block" id="OFA.completeP"><a class="viewcode-back" href="../index.html#fa.OFA.completeP">[docs]</a>    <span class="k">def</span> <span class="nf">completeP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if it is a complete FA (if delta is total)</span>

<span class="sd">        :return: bool&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">ni</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ss</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="OFA.complete"><a class="viewcode-back" href="../index.html#fa.OFA.complete">[docs]</a>    <span class="k">def</span> <span class="nf">complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dead</span><span class="o">=</span><span class="n">DeadName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transforms the automata into a complete one. If Sigma is empty nothing is done.</span>

<span class="sd">        :param str dead: dead state name</span>
<span class="sd">        :return: the complete FA</span>
<span class="sd">        :rtype: DFA</span>

<span class="sd">        .. note::</span>
<span class="sd">           Adds a dead state (if necessary) so that any word can be processed with the automata. The new state is</span>
<span class="sd">           named ``dead``, so this name should never be used for other purposes.</span>

<span class="sd">        .. attention::</span>
<span class="sd">           The object is modified in place.</span>

<span class="sd">        .. versionchanged:: 1.0&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">completeP</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">Bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">dead</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">ni</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ss</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ni</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Bin</span><span class="p">)</span>
                        <span class="n">f</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deleteState</span><span class="p">(</span><span class="n">Bin</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="OFA.trim"><a class="viewcode-back" href="../index.html#fa.OFA.trim">[docs]</a>    <span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the states that do not lead to a final state, or, inclusively,</span>
<span class="sd">        that can&#39;t be reached from the initial state. Only useful states</span>
<span class="sd">        remain.</span>

<span class="sd">        .. attention:</span>
<span class="sd">            only applies to non empty languages</span>

<span class="sd">        .. attention::</span>
<span class="sd">           in place transformation&quot;&quot;&quot;</span>
        <span class="n">useful</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usefulStates</span><span class="p">()</span>
        <span class="n">del_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">useful</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">del_states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deleteStates</span><span class="p">(</span><span class="n">del_states</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="OFA.trimP"><a class="viewcode-back" href="../index.html#fa.OFA.trimP">[docs]</a>    <span class="k">def</span> <span class="nf">trimP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if the FA is trim: initially connected and co-accessible</span>

<span class="sd">        :return: bool&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalCompP</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initialComp</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="OFA.minimalBrzozowski"><a class="viewcode-back" href="../index.html#fa.OFA.minimalBrzozowski">[docs]</a>    <span class="k">def</span> <span class="nf">minimalBrzozowski</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructs the equivalent minimal DFA using Brzozowski&#39;s</span>
<span class="sd">        algorithm</span>

<span class="sd">        :return: equivalent minimal DFA</span>
<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reversal</span><span class="p">()</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span><span class="o">.</span><span class="n">reversal</span><span class="p">()</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="OFA.minimalBrzozowskiP"><a class="viewcode-back" href="../index.html#fa.OFA.minimalBrzozowskiP">[docs]</a>    <span class="k">def</span> <span class="nf">minimalBrzozowskiP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if the FA is minimal using Brzozowski&#39;s algorithm</span>

<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimalBrzozowski</span><span class="p">()</span>
        <span class="n">x</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniqueRepr</span><span class="p">()</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">uniqueRepr</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="OFA.regexpSE"><a class="viewcode-back" href="../index.html#fa.OFA.regexpSE">[docs]</a>    <span class="k">def</span> <span class="nf">regexpSE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A regular expression obtained by state elimination algorithm whose language is recognised by the FA.</span>

<span class="sd">        :return: the equivalent regular expression</span>
<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">States</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">emptyset</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">emptyset</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">epsilon</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="o">==</span> <span class="n">NFA</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">epsilon</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">toGFA</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;Last&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">last</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">lfoo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">foo</span><span class="p">[</span><span class="n">lfoo</span><span class="p">],</span> <span class="n">foo</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span><span class="p">,</span> <span class="n">lfoo</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lfoo</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span><span class="n">lfoo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span> <span class="n">lfoo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">lr</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">eliminateAll</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">completeDelta</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">][</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">],</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">fi</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">fi</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>
        <span class="c"># bd*</span>
        <span class="n">re1</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="c"># a + bd*c</span>
        <span class="n">re2</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">disj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">re1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="c"># (a + bd*c)* bd*</span>
        <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">re2</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span> <span class="n">re1</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="OFA.allRegExps"><a class="viewcode-back" href="../index.html#fa.OFA.allRegExps">[docs]</a>    <span class="k">def</span> <span class="nf">allRegExps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the alphabetic length of the equivalent regular expression using every possible order of state</span>
<span class="sd">        elimination.</span>

<span class="sd">        :rtype: list of tuples (int, list of states)&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span>

        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">toGFA</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">))):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_stateElimination</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">order</span><span class="p">)))</span><span class="o">.</span><span class="n">alphabeticLength</span><span class="p">(),</span> <span class="n">order</span>
</div>
    <span class="k">def</span> <span class="nf">_isAcyclic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">strict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines if from state s a cyclic is reached</span>

<span class="sd">        :param int s: state</span>
<span class="sd">        :param dict visited: marks visited states</span>
<span class="sd">        :param bool strict: if not True loops are allowed</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">dest</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateChildren</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">strict</span><span class="p">):</span>
                    <span class="n">acyclic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isAcyclic</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">strict</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">acyclic</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">False</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>

<div class="viewcode-block" id="OFA.acyclicP"><a class="viewcode-back" href="../index.html#fa.OFA.acyclicP">[docs]</a>    <span class="k">def</span> <span class="nf">acyclicP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Checks if the FA is acyclic</span>

<span class="sd">        :param strict: if not True loops are allowed</span>
<span class="sd">        :type strict: bool</span>
<span class="sd">        :returns: True if the FA is acyclic</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">acyclic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isAcyclic</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">strict</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">acyclic</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="k">def</span> <span class="nf">_topoSort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Auxiliar for topological order&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="c"># noinspection PyTypeChecker</span>
                <span class="k">for</span> <span class="n">dest</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateChildren</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_topoSort</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
            <span class="n">L</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

<div class="viewcode-block" id="OFA.topoSort"><a class="viewcode-back" href="../index.html#fa.OFA.topoSort">[docs]</a>    <span class="k">def</span> <span class="nf">topoSort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Topological order for the FA</span>

<span class="sd">        :returns: List of state indexes</span>
<span class="sd">        :rtype: list of int</span>

<span class="sd">        .. note::</span>
<span class="sd">           self loops are taken in consideration&quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_topoSort</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L</span>
</div>
<div class="viewcode-block" id="OFA.eliminateSingles"><a class="viewcode-back" href="../index.html#fa.OFA.eliminateSingles">[docs]</a>    <span class="k">def</span> <span class="nf">eliminateSingles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Eliminates every state that only have one successor and one predecessor.</span>

<span class="sd">        :returns: GFA after eliminating states</span>
<span class="sd">        :rtype: GFA &quot;&quot;&quot;</span>
        <span class="c"># DFS to obtain {v:(e, s)} -&gt; convert from {v:(e, s)} to {(e, s):v} -&gt; eliminate all {(1, 1):v}</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toGFA</span><span class="p">()</span>
        <span class="n">io</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">DFS</span><span class="p">(</span><span class="n">io</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">io</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">new</span><span class="p">[</span><span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new</span><span class="p">[</span><span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gfa</span>
            <span class="c"># While there are singles, delete them</span>
        <span class="k">while</span> <span class="n">new</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">new</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">v</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">disj</span><span class="p">(</span><span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span><span class="p">],</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">o</span><span class="p">],</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span>
                                            <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">o</span><span class="p">])</span>
                <span class="n">new</span><span class="p">[</span><span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">new</span><span class="p">[</span><span class="n">io</span><span class="p">[</span><span class="n">o</span><span class="p">]]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                <span class="c"># lists are unhashable</span>
                <span class="n">e0</span><span class="p">,</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">e0</span><span class="p">,</span> <span class="n">e1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">e0</span><span class="p">,</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">io</span><span class="p">[</span><span class="n">o</span><span class="p">]</span>
                <span class="n">io</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">e0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                    <span class="n">new</span><span class="p">[</span><span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new</span><span class="p">[</span><span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">io</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                    <span class="n">new</span><span class="p">[</span><span class="n">io</span><span class="p">[</span><span class="n">o</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new</span><span class="p">[</span><span class="n">io</span><span class="p">[</span><span class="n">o</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="p">]</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span><span class="p">],</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">o</span><span class="p">],</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">o</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">io</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="c"># Clean up state indexes...</span>
        <span class="n">newOrder</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">newOrder</span><span class="p">:</span>
                <span class="n">newOrder</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">newOrder</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">newOrder</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">a</span>
            <span class="n">ind</span> <span class="o">+=</span> <span class="n">a</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">newOrder</span><span class="p">)</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">[:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">gfa</span>
</div>
<div class="viewcode-block" id="OFA.SPRegExp"><a class="viewcode-back" href="../index.html#fa.OFA.SPRegExp">[docs]</a>    <span class="k">def</span> <span class="nf">SPRegExp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Checks if FA is SP (Serial-PArallel), and if so returns the regular expression whose language is recognised by the FA</span>

<span class="sd">        :returns: equivalent regular expression</span>
<span class="sd">        :rtype: regexp</span>
<span class="sd">        :raises NotSP: if the automaton is not Serial-Parallel</span>

<span class="sd">        .. seealso:: Moreira &amp; Reis, Fundamenta Informatica, Series-Parallel automata and short regular expressions,</span>
<span class="sd">           n.91 3-4, pag 611-629.</span>
<span class="sd">           http://www.dcc.fc.up.pt/~nam/publica/spa07.pdf</span>

<span class="sd">        .. note::</span>
<span class="sd">           Automata must be Serial-Parallel&quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># just to satisfy the checker</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toGFA</span><span class="p">()</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">lab</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">out_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">out_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">out_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">topoOrder</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">topoSort</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">topoOrder</span><span class="p">:</span>  <span class="c"># States should be topologically ordered</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># noinspection PyProtectedMember</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">_simplify</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">v</span><span class="p">]):</span>
                <span class="n">track</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">v</span><span class="p">])[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">)]</span>
                <span class="n">rp</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">v</span><span class="p">])[</span><span class="mi">0</span><span class="p">]][</span><span class="n">v</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">track</span> <span class="o">=</span> <span class="n">SPLabel</span><span class="p">([])</span>
                <span class="n">rp</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">epsilon</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># noinspection PyProtectedMember</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">_do_edges</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">track</span><span class="p">,</span> <span class="n">rp</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">v</span><span class="p">])[</span><span class="mi">0</span><span class="p">]][</span><span class="n">v</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="OFA.reCG"><a class="viewcode-back" href="../index.html#fa.OFA.reCG">[docs]</a>    <span class="k">def</span> <span class="nf">reCG</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Regular expression from state elimination whose language is recognised by the FA. Uses a heuristic to choose</span>
<span class="sd">        the order of elimination.</span>

<span class="sd">        :returns: the equivalent regular expression</span>
<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">toGFA</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">emptyset</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">st</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">and</span> <span class="n">st</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">weight</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">weights</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># After &#39;m&#39; is eliminated it&#39;s adjacencies might</span>
            <span class="c"># change their indexes...</span>
            <span class="n">adj</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">st</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">adj</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">st</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">adj</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">st</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">adj</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">st</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">adj</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">eliminateState</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">st</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">st</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">st</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">st</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">and</span> <span class="n">st</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">weight</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">weights</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">][</span><span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="OFA.reCG_nn"><a class="viewcode-back" href="../index.html#fa.OFA.reCG_nn">[docs]</a>    <span class="k">def</span> <span class="nf">reCG_nn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Regular expression from state elimination whose language is recognised by the FA. Uses a heuristic to choose</span>
<span class="sd">        the order of elimination. The FA is not normalized before the state elimination.</span>

<span class="sd">        :returns: the equivalent regular expression</span>
<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">emptyset</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">toGFA</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;Last&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">last</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">lfoo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">foo</span><span class="p">[</span><span class="n">lfoo</span><span class="p">],</span> <span class="n">foo</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span><span class="p">,</span> <span class="n">lfoo</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lfoo</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span><span class="n">lfoo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span> <span class="n">lfoo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">st</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">and</span> <span class="n">st</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">weight</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">weights</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">succs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">succs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">preds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">eliminate</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="c"># update predecessors for weight(st)...</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">succs</span><span class="p">:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">preds</span><span class="p">:</span>
                    <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">succs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">preds</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">and</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">weight</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">weights</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">completeDelta</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">][</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">],</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>
        <span class="c"># noinspection PyProtectedMember</span>
        <span class="k">return</span> <span class="n">gfa</span><span class="o">.</span><span class="n">_re0</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="OFA.re_stateElimination"><a class="viewcode-back" href="../index.html#fa.OFA.re_stateElimination">[docs]</a>    <span class="k">def</span> <span class="nf">re_stateElimination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Regular expression from state elimination whose language is recognised by the FA. The FA is normalized before</span>
<span class="sd">        the state elimination.</span>

<span class="sd">        :param order: state elimination sequence</span>
<span class="sd">        :type order: list</span>
<span class="sd">        :returns: the equivalent regular expression</span>
<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">toGFA</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">emptyset</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">st</span><span class="p">:</span>
                    <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">eliminateState</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">][</span><span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
</div>
<div class="viewcode-block" id="OFA.reDynamicCycleHeuristic"><a class="viewcode-back" href="../index.html#fa.OFA.reDynamicCycleHeuristic">[docs]</a>    <span class="k">def</span> <span class="nf">reDynamicCycleHeuristic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; State elimination Heuristic based on the number of cycles that passes through each state. Here those</span>
<span class="sd">        numbers are evaluated dynamically after each elimination step</span>

<span class="sd">        :returns: an equivalent regular expression</span>
<span class="sd">        :rtype: regexp</span>

<span class="sd">        .. seealso::</span>
<span class="sd">           Nelma Moreira, Davide Nabais, and Rogério Reis. State elimination ordering strategies: Some experimental</span>
<span class="sd">           results. Proc. of 11th Workshop on Descriptional Complexity of Formal Systems (DCFS10),</span>
<span class="sd">           pages 169-180.2010. DOI: 10.4204/EPTCS.31.16&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">emptyset</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">evalNumberOfStateCycles</span><span class="p">()</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">toGFA</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;Last&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">last</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">lfoo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">foo</span><span class="p">[</span><span class="n">lfoo</span><span class="p">],</span> <span class="n">foo</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span><span class="p">,</span> <span class="n">lfoo</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lfoo</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span><span class="n">lfoo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span> <span class="n">lfoo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">st</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">and</span> <span class="n">st</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">weightWithCycles</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">cycles</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">weights</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">succs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">succs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">preds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">eliminate</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">cycles</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">evalNumberOfStateCycles</span><span class="p">()</span>
            <span class="c"># update predecessors for weight(st)...</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">succs</span><span class="p">:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">preds</span><span class="p">:</span>
                    <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">succs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">preds</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">and</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">weightWithCycles</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cycles</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">weights</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">completeDelta</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">][</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">],</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="c"># noinspection PyProtectedMember</span>
        <span class="k">return</span> <span class="n">gfa</span><span class="o">.</span><span class="n">_re0</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="OFA.reStaticCycleHeuristic"><a class="viewcode-back" href="../index.html#fa.OFA.reStaticCycleHeuristic">[docs]</a>    <span class="k">def</span> <span class="nf">reStaticCycleHeuristic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;State elimination Heuristic based on the number of cycles that passes through each state. Here those</span>
<span class="sd">        numbers are evaluated statically in the beginning of the process</span>

<span class="sd">        :returns: a equivalent regular expression</span>
<span class="sd">        :rtype: regexp</span>

<span class="sd">        .. seealso::</span>
<span class="sd">           Nelma Moreira, Davide Nabais, and Rogério Reis. State elimination ordering strategies: Some experimental</span>
<span class="sd">           results. Proc. of 11th Workshop on Descriptional Complexity of Formal Systems (DCFS10),</span>
<span class="sd">           pages 169-180.2010. DOI: 10.4204/EPTCS.31.16&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">emptyset</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">evalNumberOfStateCycles</span><span class="p">()</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">toGFA</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;Last&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">last</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">lfoo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">foo</span><span class="p">[</span><span class="n">lfoo</span><span class="p">],</span> <span class="n">foo</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span><span class="p">,</span> <span class="n">lfoo</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lfoo</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span><span class="n">lfoo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span> <span class="n">lfoo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">st</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">and</span> <span class="n">st</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">weightWithCycles</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">cycles</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">weights</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">succs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">succs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">preds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">eliminate</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">succs</span><span class="p">:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">preds</span><span class="p">:</span>
                    <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">succs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">preds</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">and</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">weightWithCycles</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cycles</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">weights</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">completeDelta</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">][</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">],</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="c"># noinspection PyProtectedMember</span>
        <span class="k">return</span> <span class="n">gfa</span><span class="o">.</span><span class="n">_re0</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="OFA.re_stateElimination_nn"><a class="viewcode-back" href="../index.html#fa.OFA.re_stateElimination_nn">[docs]</a>    <span class="k">def</span> <span class="nf">re_stateElimination_nn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Regular expression from state elimination whose language is recognised by the FA. The FA is not normalized</span>
<span class="sd">        before the state elimination.</span>

<span class="sd">        :param order: state elimination sequence</span>
<span class="sd">        :type order: list</span>
<span class="sd">        :returns: the equivalent regular expression</span>
<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># just to satisfy the checker</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toGFA</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">emptyset</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;Last&quot;</span><span class="p">)</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                    <span class="n">gfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
                    <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">last</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">last</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">last</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">foo</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">lfoo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">foo</span><span class="p">[</span><span class="n">lfoo</span><span class="p">],</span> <span class="n">foo</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span><span class="p">,</span> <span class="n">lfoo</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lfoo</span> <span class="o">!=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span><span class="n">lfoo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span> <span class="n">lfoo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">order</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">st</span><span class="p">:</span>
                    <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">eliminateState</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">completeDelta</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">][</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">],</span>
                             <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">fi</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">fi</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>
        <span class="c"># bd*</span>
        <span class="n">re1</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span>
                          <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="c"># a + bd*c</span>
        <span class="n">re2</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">disj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">re1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span>
                        <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="c"># (a + bd*c)* bd*</span>
        <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">re2</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span>
                           <span class="n">re1</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="OFA.cutPoints"><a class="viewcode-back" href="../index.html#fa.OFA.cutPoints">[docs]</a>    <span class="k">def</span> <span class="nf">cutPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of FA&#39;s cut points</span>

<span class="sd">        :returns: set of states</span>
<span class="sd">        :rtype: set of int&quot;&quot;&quot;</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toGFA</span><span class="p">()</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="c"># make gfa a graph instead of a digraph</span>
        <span class="n">newEdges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
                <span class="n">newEdges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">newEdges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&#39;x&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">newEdges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="s">&#39;x&#39;</span>
        <span class="c"># initializations needed for cut point detection</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">low</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">cuts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">assignNum</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">assignLow</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="c"># initial state is never a cut point so it should be removed</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">cuts</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">cutpoints</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">cuts</span><span class="p">)</span> <span class="o">-</span> <span class="n">gfa</span><span class="o">.</span><span class="n">Final</span>
        <span class="c"># remove self-loops and check if the cut points are in a loop</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toGFA</span><span class="p">()</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">del</span> <span class="n">gfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="n">gfa</span><span class="o">.</span><span class="n">evalNumberOfStateCycles</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cycles</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cutpoints</span><span class="p">:</span>
                <span class="n">cutpoints</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cutpoints</span>
</div>
<div class="viewcode-block" id="OFA.evalNumberOfStateCycles"><a class="viewcode-back" href="../index.html#fa.OFA.evalNumberOfStateCycles">[docs]</a>    <span class="k">def</span> <span class="nf">evalNumberOfStateCycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the number of cycles each state participates</span>

<span class="sd">        :returns: state-&gt;list of cycle lengths</span>
<span class="sd">        :rtype: dict&quot;&quot;&quot;</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">):</span>
            <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="p">(</span><span class="n">bkE</span><span class="p">,</span> <span class="n">multipl</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DFSBackEdges</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bkE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chkForCycles</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cycles</span><span class="p">,</span> <span class="n">seen</span><span class="p">,</span> <span class="n">multipl</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cycles</span>
</div>
    <span class="k">def</span> <span class="nf">_chkForCycles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cycles</span><span class="p">,</span> <span class="n">seen</span><span class="p">,</span> <span class="n">multipl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used in evalNumberOfStateCycles&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateChildren</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
        <span class="n">marked</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">foo</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">foo</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">bar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalizeCycle</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">m</span> <span class="o">*=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">multipl</span><span class="p">[(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])])</span>
                    <span class="n">m</span> <span class="o">*=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">multipl</span><span class="p">[(</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                        <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cycles</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">marked</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateChildren</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">cycles</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_normalizeCycle</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normalizes a cycle with its first element at the begining</span>

<span class="sd">        :param list c: cycle&quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_DFSBackEdges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a pair (BE, M) whee BE is the set of backedges form a DFS starting with the initial state as pairs</span>
<span class="sd">         (s, d) and M is a map (i, j)-&gt;multiplicity</span>

<span class="sd">        :returns: as said above</span>
<span class="sd">        :rtype: tuple&quot;&quot;&quot;</span>
        <span class="n">mStates</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">bEdges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">multipl</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">:</span>  <span class="c"># NFAs</span>
            <span class="n">mStates</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
            <span class="n">pool</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># DFAs</span>
            <span class="n">mStates</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateChildren</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="c"># noinspection PyTypeChecker</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">child</span><span class="p">:</span>
                <span class="n">multipl</span><span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)]</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">child</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mStates</span> <span class="ow">or</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">:</span>
                    <span class="n">bEdges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pool</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">mStates</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bEdges</span><span class="p">,</span> <span class="n">multipl</span>

<div class="viewcode-block" id="OFA.eliminateStout"><a class="viewcode-back" href="../index.html#fa.OFA.eliminateStout">[docs]</a>    <span class="k">def</span> <span class="nf">eliminateStout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Eliminate all transitions outgoing from a given state</span>

<span class="sd">        :param int st: the state index to loose all outgoing transitions</span>

<span class="sd">        .. attention::</span>
<span class="sd">           performs in place alteration of the automata</span>

<span class="sd">        .. versionadded:: 0.9.6&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">del</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="OFA.dup"><a class="viewcode-back" href="../index.html#fa.OFA.dup">[docs]</a>    <span class="k">def</span> <span class="nf">dup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Duplicate OFA</span>

<span class="sd">        :returns: duplicate object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="NFA"><a class="viewcode-back" href="../index.html#fa.NFA">[docs]</a><span class="k">class</span> <span class="nc">NFA</span><span class="p">(</span><span class="n">OFA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for Non-deterministic Finite Automata (epsilon-transitions allowed).</span>

<span class="sd">    .. inheritance-diagram:: NFA&quot;&quot;&quot;</span>

<div class="viewcode-block" id="NFA.uniqueRepr"><a class="viewcode-back" href="../index.html#fa.NFA.uniqueRepr">[docs]</a>    <span class="k">def</span> <span class="nf">uniqueRepr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dummy representation. Used DFA.uniqueRepr()</span>
<span class="sd">        :rtype: tuple&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span><span class="o">.</span><span class="n">uniqueRepr</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">FA</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&#39;Official&#39; string representation</span>
<span class="sd">        :returns: str</span>
<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;NFA({0:&gt;s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__str__</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_lstTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">k</span><span class="p">]:</span>
                    <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">y</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">l</span>

    <span class="k">def</span> <span class="nf">_s_lstInitial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_lstInitial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAnoInitial</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="NFA.vDescription"><a class="viewcode-back" href="../index.html#fa.NFA.vDescription">[docs]</a>    <span class="k">def</span> <span class="nf">vDescription</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Generation of Verso interface description</span>

<span class="sd">        .. versionadded:: 0.9.5</span>

<span class="sd">        :return: the interface list&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="s">&quot;NFA&quot;</span><span class="p">,</span> <span class="s">&quot;Nondeterministic Finite Automata&quot;</span><span class="p">),</span>
                <span class="p">[(</span><span class="s">&quot;NFAFAdo&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">saveToString</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&quot;FAdo&quot;</span><span class="p">),</span>
                 <span class="p">(</span><span class="s">&quot;NFAdot&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">dotFormat</span><span class="p">(</span><span class="s">&quot;&amp;&quot;</span><span class="p">),</span> <span class="s">&quot;dot&quot;</span><span class="p">)],</span>
                <span class="p">(</span><span class="s">&quot;NFA-to-DFA&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;NFA to DFA&quot;</span><span class="p">,</span> <span class="s">&quot;NFA to DFA&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;NFA&quot;</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()),</span>
                <span class="p">(</span><span class="s">&quot;NFA-reversal&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Reversal language NFA&quot;</span><span class="p">,</span> <span class="s">&quot;Reversal language NFA&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;NFA&quot;</span><span class="p">,</span> <span class="s">&quot;NFA&quot;</span><span class="p">,</span>
                 <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reversal</span><span class="p">())]</span>
</div>
    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Disjunction of automata:  X | Y.</span>

<span class="sd">        :param NFA|DFA other: the right hand operand</span>
<span class="sd">        :raises FAdoGeneralError: if any operand is not an NFA</span>

<span class="sd">        .. versionchanged:: 1.2&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DFA</span><span class="p">):</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NFA</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">FAdoGeneralError</span><span class="p">(</span><span class="s">&quot;Incompatible objects&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span><span class="o">.</span><span class="n">elimEpsilon</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
            <span class="n">par1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span><span class="o">.</span><span class="n">elimEpsilon</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">par1</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">par1</span><span class="o">.</span><span class="n">_copySkell</span><span class="p">(</span><span class="n">par2</span><span class="p">)</span>
        <span class="n">ini</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">ini</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">par1</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">ini</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">si</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">par2</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">ini</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">si</span><span class="p">)</span>
        <span class="n">fin</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">fin</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">par1</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">fin</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">par2</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">fin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conjunction of automata</span>

<span class="sd">        :param NFA|DFA other: the right hand operand</span>
<span class="sd">        :rtype: NFA</span>
<span class="sd">        :raises FAdoGeneralError: if any operand is not an NFA&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DFA</span><span class="p">):</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">FAdoGeneralError</span><span class="p">(</span><span class="s">&quot;Incompatible objects&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span><span class="o">.</span><span class="n">elimEpsilon</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
            <span class="n">par1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span><span class="o">.</span><span class="n">elimEpsilon</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">par1</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">par1</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">par2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">par1</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">par2</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">par1</span><span class="o">.</span><span class="n">Final</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">Final</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new</span><span class="o">.</span><span class="n">_namesToString</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Complement of the NFA (through conversion to DFA)</span>

<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">foo</span><span class="o">.</span><span class="n">__invert__</span><span class="p">()</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_getTags</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;returns Tags for dump</span>

<span class="sd">        :rtype: list of str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">&quot;NFA&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="NFA.concat"><a class="viewcode-back" href="../index.html#fa.NFA.concat">[docs]</a>    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">middle</span><span class="o">=</span><span class="s">&quot;middle&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenation of NFA</span>

<span class="sd">        :param str middle: glue state name</span>
<span class="sd">        :param NFA|DFA other: the other NFA</span>
<span class="sd">        :returns: the result of the concatenation</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DFA</span><span class="p">):</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">other</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copySkell</span><span class="p">(</span><span class="n">par2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)))</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)),</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">par2</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">par2</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="NFA.witness"><a class="viewcode-back" href="../index.html#fa.NFA.witness">[docs]</a>    <span class="k">def</span> <span class="nf">witness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Witness of non emptyness</span>

<span class="sd">        :return: word</span>
<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">notDone</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">pref</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">pref</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">Epsilon</span>
            <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">notDone</span><span class="p">:</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">notDone</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pref</span><span class="p">[</span><span class="n">si</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">syi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="k">for</span> <span class="n">so</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">si</span><span class="p">][</span><span class="n">syi</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">so</span> <span class="ow">in</span> <span class="n">done</span> <span class="ow">or</span> <span class="n">so</span> <span class="ow">in</span> <span class="n">notDone</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">pref</span><span class="p">[</span><span class="n">so</span><span class="p">]</span> <span class="o">=</span> <span class="n">sConcat</span><span class="p">(</span><span class="n">pref</span><span class="p">[</span><span class="n">si</span><span class="p">],</span> <span class="n">syi</span><span class="p">)</span>
                    <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">so</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c"># noinspection PyUnresolvedReferences</span></div>
<div class="viewcode-block" id="NFA.shuffle"><a class="viewcode-back" href="../index.html#fa.NFA.shuffle">[docs]</a>    <span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shuffle of a NFA</span>

<span class="sd">        :param other: an FA</span>
<span class="sd">        :type other: FA</span>
<span class="sd">        :returns: the resulting NFA</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toNFASingleInitial</span><span class="p">()</span><span class="o">.</span><span class="n">elimEpsilon</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="n">NFA</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toNFASingleInitial</span><span class="p">()</span><span class="o">.</span><span class="n">elimEpsilon</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">NFA</span><span class="p">()</span>
        <span class="n">NSigma</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">NSigma</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">States</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">States</span><span class="p">))]</span>
        <span class="n">c</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="nb">list</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">Initial</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">Initial</span><span class="p">)[</span><span class="mi">0</span><span class="p">])))</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d1</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">d2</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lq</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">([</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">sym</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">lq</span><span class="p">:</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">st</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                <span class="k">except</span> <span class="p">(</span><span class="n">DFAstopped</span><span class="p">,</span> <span class="n">DFAsymbolUnknown</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lq</span> <span class="o">=</span> <span class="n">d2</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">([</span><span class="n">st</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">sym</span><span class="p">)</span>
                    <span class="c"># noinspection PyTypeChecker</span>
                    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">lq</span><span class="p">:</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">)))</span>
                <span class="k">except</span> <span class="p">(</span><span class="n">DFAstopped</span><span class="p">,</span> <span class="n">DFAsymbolUnknown</span><span class="p">):</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">c</span>
</div>
<div class="viewcode-block" id="NFA.star"><a class="viewcode-back" href="../index.html#fa.NFA.star">[docs]</a>    <span class="k">def</span> <span class="nf">star</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Kleene star of a NFA</span>

<span class="sd">        :param flag: plus instead of star</span>
<span class="sd">        :type flag: Boolean</span>
<span class="sd">        :returns: the resulting NFA</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">ini</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">fin</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
        <span class="n">nf</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">nf</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">:</span>
            <span class="n">ni</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
            <span class="n">new</span><span class="o">.</span><span class="n">setInitial</span><span class="p">([</span><span class="n">ni</span><span class="p">])</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">nf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ni</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
            <span class="n">nni</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
            <span class="n">new</span><span class="o">.</span><span class="n">setInitial</span><span class="p">([</span><span class="n">nni</span><span class="p">])</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">nni</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">ni</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">ni</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ini</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fin</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">nf</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Test equivalence of two NFAs</span>

<span class="sd">        :param other: the other NFA</span>
<span class="sd">        :type other: NFA</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Test non  equivalence of two NFAs</span>

<span class="sd">        :param other: the other NFA</span>
<span class="sd">        :type other: NFA</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">_copySkell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new NFA with the skells of both NFAs</span>

<span class="sd">        Each state is named with its previous index is inscribed in a tuple (0,_) and (1,_) respectively</span>

<span class="sd">        :param NFA other: the other NFA</span>
<span class="sd">        :rtype: NFA</span>

<span class="sd">        .. attention::</span>
<span class="sd">           No initial and final states are assigned in the resulting NFA.&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">NFA</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)),</span> <span class="n">c</span><span class="p">,</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">)))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)),</span> <span class="n">c</span><span class="p">,</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">new</span>

<div class="viewcode-block" id="NFA.setInitial"><a class="viewcode-back" href="../index.html#fa.NFA.setInitial">[docs]</a>    <span class="k">def</span> <span class="nf">setInitial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statelist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the initial states of an NFA</span>

<span class="sd">        :param set|list|int statelist: an iterable of initial state indexes&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">statelist</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NFA.addInitial"><a class="viewcode-back" href="../index.html#fa.NFA.addInitial">[docs]</a>    <span class="k">def</span> <span class="nf">addInitial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stateindex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new state to the set of initial states.</span>

<span class="sd">        :param int stateindex: index of new initial state&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">stateindex</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NFA.succintTransitions"><a class="viewcode-back" href="../index.html#fa.NFA.succintTransitions">[docs]</a>    <span class="k">def</span> <span class="nf">succintTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Collects the transition information in a concat way suitable for graphical representation.</span>
<span class="sd">        :rtype: list&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
                        <span class="n">foo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">foo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="n">foo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">graphvizTranslate</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;, </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">graphvizTranslate</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">l</span>
</div>
<div class="viewcode-block" id="NFA.deleteStates"><a class="viewcode-back" href="../index.html#fa.NFA.deleteStates">[docs]</a>    <span class="k">def</span> <span class="nf">deleteStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">del_states</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete given iterable collection of states from the automaton.</span>

<span class="sd">        :param set|list del_states: collection of int representing states</span>

<span class="sd">        .. note::</span>
<span class="sd">           delta function will always be rebuilt, regardless of whether the states list to remove is a suffix,</span>
<span class="sd">           or a sublist, of the automaton&#39;s states list.&quot;&quot;&quot;</span>
        <span class="n">rename_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_delta</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_final</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">new_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">del_states</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">del_states</span><span class="p">:</span>
                <span class="n">rename_map</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_states</span><span class="p">)</span>
                <span class="n">new_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">rename_map</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">new_final</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rename_map</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_delta</span><span class="p">[</span><span class="n">rename_map</span><span class="p">[</span><span class="n">state</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                <span class="n">new_targets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">rename_map</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span>
                                   <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">rename_map</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">new_targets</span><span class="p">:</span>
                    <span class="n">new_delta</span><span class="p">[</span><span class="n">rename_map</span><span class="p">[</span><span class="n">state</span><span class="p">]][</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_targets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">new_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">new_delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="n">new_final</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">rename_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="NFA.addTransition"><a class="viewcode-back" href="../index.html#fa.NFA.addTransition">[docs]</a>    <span class="k">def</span> <span class="nf">addTransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">sti2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a new transition. Transition is from ``sti1`` to ``sti2`` consuming symbol ``sym``. ``sti2`` is a</span>
<span class="sd">        unique state, not a set of them.</span>

<span class="sd">        :param int sti1: state index of departure</span>
<span class="sd">        :param int sti2: state index of arrival</span>
<span class="sd">        :param str sym: symbol consumed&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="o">!=</span> <span class="n">Epsilon</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sti1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">sym</span><span class="p">:</span> <span class="p">{</span><span class="n">sti2</span><span class="p">}}</span>
        <span class="k">elif</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">sti2</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sti2</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NFA.addEpsilonLoops"><a class="viewcode-back" href="../index.html#fa.NFA.addEpsilonLoops">[docs]</a>    <span class="k">def</span> <span class="nf">addEpsilonLoops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add epsilon loops to every state</span>
<span class="sd">        :return: self</span>

<span class="sd">        .. attention:: in-place modification</span>

<span class="sd">        .. versionadded:: 1.0&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="NFA.addTransitionQ"><a class="viewcode-back" href="../index.html#fa.NFA.addTransitionQ">[docs]</a>    <span class="k">def</span> <span class="nf">addTransitionQ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">srcI</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">symb</span><span class="p">,</span> <span class="n">qfuture</span><span class="p">,</span> <span class="n">qpast</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add transition to the new transducer instance.</span>

<span class="sd">        :param set qpast: past queue</span>
<span class="sd">        :param set qfuture: future queue</span>
<span class="sd">        :param symb: symbol</span>
<span class="sd">        :param dest: destination state</span>
<span class="sd">        :param int srcI: source state</span>

<span class="sd">        .. versionadded:: 1.0&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qpast</span><span class="p">:</span>
            <span class="n">qfuture</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">srcI</span><span class="p">,</span> <span class="n">symb</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NFA.delTransition"><a class="viewcode-back" href="../index.html#fa.NFA.delTransition">[docs]</a>    <span class="k">def</span> <span class="nf">delTransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">sti2</span><span class="p">,</span> <span class="n">_no_check</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove a transition if existing and perform cleanup on the transition function&#39;s internal data structure.</span>

<span class="sd">        :param int sti1: state index of departure</span>
<span class="sd">        :param int sti2: state index of arrival</span>
<span class="sd">        :param str sym: symbol consumed</span>
<span class="sd">        :param bool _no_check: dismiss secure code</span>

<span class="sd">        .. note::</span>
<span class="sd">           unused alphabet symbols will be discarded from Sigma.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_no_check</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sti1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="ow">or</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">sti2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sym</span><span class="p">]:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">itervalues</span><span class="p">())):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="NFA.reversal"><a class="viewcode-back" href="../index.html#fa.NFA.reversal">[docs]</a>    <span class="k">def</span> <span class="nf">reversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a NFA that recognizes the reversal of the language</span>

<span class="sd">        :returns: NFA recognizing reversal language</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">rev</span> <span class="o">=</span> <span class="n">NFA</span><span class="p">()</span>
        <span class="n">rev</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">rev</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverseTransitions</span><span class="p">(</span><span class="n">rev</span><span class="p">)</span>
        <span class="n">rev</span><span class="o">.</span><span class="n">setFinal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">rev</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rev</span>
</div>
<div class="viewcode-block" id="NFA.reorder"><a class="viewcode-back" href="../index.html#fa.NFA.reorder">[docs]</a>    <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dicti</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reorder states indexes according to given dictionary.</span>

<span class="sd">        :param dicti: state name reorder</span>
<span class="sd">        :type dicti: dictionary</span>

<span class="sd">        .. note::</span>
<span class="sd">           dictionary does not have to be complete&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dicti</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dicti</span><span class="p">:</span>
                    <span class="n">dicti</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="n">delta</span><span class="p">[</span><span class="n">dicti</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">delta</span><span class="p">[</span><span class="n">dicti</span><span class="p">[</span><span class="n">s</span><span class="p">]][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="n">delta</span><span class="p">[</span><span class="n">dicti</span><span class="p">[</span><span class="n">s</span><span class="p">]][</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dicti</span><span class="p">[</span><span class="n">st</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dicti</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">))</span>
        <span class="n">Final</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">Final</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dicti</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="n">Final</span>
        <span class="n">states</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">states</span><span class="p">[</span><span class="n">dicti</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">states</span>
</div>
<div class="viewcode-block" id="NFA.epsilonP"><a class="viewcode-back" href="../index.html#fa.NFA.epsilonP">[docs]</a>    <span class="k">def</span> <span class="nf">epsilonP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether this NFA has epsilon-transitions</span>

<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Epsilon</span> <span class="ow">in</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()))</span>
</div>
<div class="viewcode-block" id="NFA.epsilonClosure"><a class="viewcode-back" href="../index.html#fa.NFA.epsilonClosure">[docs]</a>    <span class="k">def</span> <span class="nf">epsilonClosure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the set of states epsilon-connected to from given state or set of states.</span>

<span class="sd">        :param int|set st: state index or set of state indexes</span>
<span class="sd">        :returns: the list of state indexes epsilon connected to ``st``</span>
<span class="sd">        :rtype: set of int</span>

<span class="sd">        .. attention::</span>
<span class="sd">           ``st`` must exist.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">set</span><span class="p">:</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="p">{</span><span class="n">st</span><span class="p">}</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">s2</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">s1</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">s2</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Epsilon</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span> <span class="o">-</span> <span class="n">s1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s1</span>
</div>
<div class="viewcode-block" id="NFA.closeEpsilon"><a class="viewcode-back" href="../index.html#fa.NFA.closeEpsilon">[docs]</a>    <span class="k">def</span> <span class="nf">closeEpsilon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add all non epsilon transitions from the states in the epsilon closure of given state to given state.</span>

<span class="sd">        :param int st: state index&quot;&quot;&quot;</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonClosure</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="n">targets</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">targets</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delTransition</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">not_final</span> <span class="o">=</span> <span class="n">st</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">states</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">symbol</span> <span class="ow">is</span> <span class="n">Epsilon</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">not_final</span> <span class="ow">and</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
                <span class="n">not_final</span> <span class="o">=</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="NFA.eliminateTSymbol"><a class="viewcode-back" href="../index.html#fa.NFA.eliminateTSymbol">[docs]</a>    <span class="k">def</span> <span class="nf">eliminateTSymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete all trasitions through a given symbol</span>

<span class="sd">        :param str symbol: the symbol to be excluded from delta</span>

<span class="sd">        .. attention::</span>
<span class="sd">           in place alteration of the automata</span>

<span class="sd">        .. versionadded:: 0.9.6&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">del</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">symbol</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="NFA.elimEpsilon"><a class="viewcode-back" href="../index.html#fa.NFA.elimEpsilon">[docs]</a>    <span class="k">def</span> <span class="nf">elimEpsilon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Eliminate epsilon-transitions from this automaton.</span>

<span class="sd">        :rtype : NFA</span>

<span class="sd">        .. attention::</span>
<span class="sd">           performs in place modification of automaton</span>

<span class="sd">        .. versionchanged:: 1.1.1&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">closeEpsilon</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="NFA.evalWordP"><a class="viewcode-back" href="../index.html#fa.NFA.evalWordP">[docs]</a>    <span class="k">def</span> <span class="nf">evalWordP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify if the NFA recognises given word.</span>

<span class="sd">        :param str word: word to be recognised</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="n">ilist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonClosure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">ilist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">ilist</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ilist</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ilist</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="NFA.evalSymbol"><a class="viewcode-back" href="../index.html#fa.NFA.evalSymbol">[docs]</a>    <span class="k">def</span> <span class="nf">evalSymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stil</span><span class="p">,</span> <span class="n">sym</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of states reacheable from given states through given symbol and epsilon closure.</span>

<span class="sd">        :param set|list stil: set of current states</span>
<span class="sd">        :param str sym: symbol to be consumed</span>
<span class="sd">        :returns: set of reached state indexes</span>
<span class="sd">        :rtype: set[int]</span>
<span class="sd">        :raises DFAsymbolUnknown: if symbol is not in alphabet&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAsymbolUnknown</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stil</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">ls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="n">ls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epsilonClosure</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
<div class="viewcode-block" id="NFA.minimal"><a class="viewcode-back" href="../index.html#fa.NFA.minimal">[docs]</a>    <span class="k">def</span> <span class="nf">minimal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the equivalent minimal DFA</span>

<span class="sd">        :returns:  equivalent minimal DFA</span>
<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimalDFA</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="NFA.minimalDFA"><a class="viewcode-back" href="../index.html#fa.NFA.minimalDFA">[docs]</a>    <span class="k">def</span> <span class="nf">minimalDFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the equivalent minimal complete DFA</span>

<span class="sd">        :returns: equivalent minimal DFA</span>
<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimalBrzozowski</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="NFA.dup"><a class="viewcode-back" href="../index.html#fa.NFA.dup">[docs]</a>    <span class="k">def</span> <span class="nf">dup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Duplicate the basic structure into a new NFA. Basically a copy.deep.</span>

<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">NFA</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[:]</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
    <span class="k">def</span> <span class="nf">_inc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fa</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine self with given FA with a single final state.</span>

<span class="sd">        :param fa: FA to be included</span>
<span class="sd">        :type fa: FA</span>
<span class="sd">        :returns: a pair of state indexes (initial and final of the resulting NFA)</span>
<span class="sd">        :rtype: pair of int</span>

<span class="sd">        .. note::</span>
<span class="sd">           State names are not preserved.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">fa</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addSigma</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fa</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addState</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fa</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">fa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">)),</span> <span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">)))</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">uSet</span><span class="p">(</span><span class="n">fa</span><span class="o">.</span><span class="n">Initial</span><span class="p">))),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">uSet</span><span class="p">(</span><span class="n">fa</span><span class="o">.</span><span class="n">Final</span><span class="p">))))</span>

<div class="viewcode-block" id="NFA.reverseTransitions"><a class="viewcode-back" href="../index.html#fa.NFA.reverseTransitions">[docs]</a>    <span class="k">def</span> <span class="nf">reverseTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rev</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate reverse transition function.</span>

<span class="sd">        :param rev: NFA in which the reverse function will be stored</span>
<span class="sd">        :type rev: NFA&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">a</span><span class="p">]:</span>
                    <span class="n">rev</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NFA.initialComp"><a class="viewcode-back" href="../index.html#fa.NFA.initialComp">[docs]</a>    <span class="k">def</span> <span class="nf">initialComp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the connected component starting at the initial state.</span>

<span class="sd">        :returns: list of state indexes in the component</span>
<span class="sd">        :rtype: list of int&quot;&quot;&quot;</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">c</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                            <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">lst</span>
</div>
<div class="viewcode-block" id="NFA.finalCompP"><a class="viewcode-back" href="../index.html#fa.NFA.finalCompP">[docs]</a>    <span class="k">def</span> <span class="nf">finalCompP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify whether there is a final state in strongly connected component containing given state.</span>

<span class="sd">        :param s: state index</span>
<span class="sd">        :type s: int</span>
<span class="sd">        :returns: :: bool&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                            <span class="k">return</span> <span class="bp">True</span>
                        <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="NFA.deterministicP"><a class="viewcode-back" href="../index.html#fa.NFA.deterministicP">[docs]</a>    <span class="k">def</span> <span class="nf">deterministicP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify whether this NFA is actually deterministic</span>

<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">sy</span> <span class="o">==</span> <span class="n">Epsilon</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">][</span><span class="n">sy</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="k">def</span> <span class="nf">_toDFAd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transforms into a DFA assuming it is deterministic</span>

<span class="sd">    :returns: the FA in a DFA structure</span>
<span class="sd">    :rtype: DFA&quot;&quot;&quot;</span>
        <span class="c"># The subset construction will consider only accessible states</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span>
        <span class="c"># self must be trim</span>
        <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">old</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">old</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">old</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span> <span class="n">c</span><span class="p">,</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="s">&quot;{0:d}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uSet</span><span class="p">(</span><span class="n">old</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]))))</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">uSet</span><span class="p">(</span><span class="n">old</span><span class="o">.</span><span class="n">Initial</span><span class="p">))))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">old</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">new</span>

<div class="viewcode-block" id="NFA.homogenousP"><a class="viewcode-back" href="../index.html#fa.NFA.homogenousP">[docs]</a>    <span class="k">def</span> <span class="nf">homogenousP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether this NFA is homogenous; that is, for all states, whether all incoming transitions to that state</span>
<span class="sd">        are through the same symbol.</span>

<span class="sd">        :param x: dummy parameter to agree with the method in DFAr</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toNFAr</span><span class="p">()</span><span class="o">.</span><span class="n">homogenousP</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NFA.stronglyConnectedComponents"><a class="viewcode-back" href="../index.html#fa.NFA.stronglyConnectedComponents">[docs]</a>    <span class="k">def</span> <span class="nf">stronglyConnectedComponents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Strong components</span>

<span class="sd">        :rtype: list</span>

<span class="sd">        .. versionadded:: 1.0&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_strongConnect</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lowlink</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
            <span class="n">inIndices</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">inS</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">links</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="p">{})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">][</span><span class="n">k</span><span class="p">]]</span>
            <span class="c"># links = [self.delta[state][k] for k in self.delta.get(state, {})]</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">inIndices</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span>
                    <span class="n">_strongConnect</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                    <span class="n">lowlink</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lowlink</span><span class="p">[</span><span class="n">st</span><span class="p">],</span> <span class="n">lowlink</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">inS</span><span class="p">[</span><span class="n">l</span><span class="p">]:</span>
                    <span class="n">lowlink</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lowlink</span><span class="p">[</span><span class="n">st</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">lowlink</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">==</span> <span class="n">indices</span><span class="p">[</span><span class="n">st</span><span class="p">]:</span>
                <span class="n">component</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">inS</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="n">component</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">st</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lowlink</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">inIndices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">inS</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
            <span class="n">inIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">inS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">lowlink</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inIndices</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                <span class="n">_strongConnect</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="NFA.dotFormat"><a class="viewcode-back" href="../index.html#fa.NFA.dotFormat">[docs]</a>    <span class="k">def</span> <span class="nf">dotFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s">&quot;20,20&quot;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">&quot;LR&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A dot representation</span>
<span class="sd">        :arg direction: direction of drawing</span>
<span class="sd">        :arg size: size of image</span>
<span class="sd">        :arg sep: line separator</span>
<span class="sd">        :return: the dot representation</span>
<span class="sd">        type sep: str</span>
<span class="sd">        :type direction: str</span>
<span class="sd">        :type size: str</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        .. versionadded:: 0.9.6</span>

<span class="sd">        .. versionchanged:: 0.9.8&quot;&quot;&quot;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;digraph finite_state_machine {{{0:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;rankdir={0:s};{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;size=</span><span class="se">\&quot;</span><span class="s">{0:s}</span><span class="se">\&quot;</span><span class="s">;{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">sn</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">si</span><span class="p">])</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;node [shape = point]; </span><span class="se">\&quot;</span><span class="s">dummy{0:s}</span><span class="se">\&quot;</span><span class="s">{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dotDrawState</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">dummy{0:s}</span><span class="se">\&quot;</span><span class="s"> -&gt; </span><span class="se">\&quot;</span><span class="s">{1:s}</span><span class="se">\&quot;</span><span class="s">;{2:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">si</span><span class="p">]),</span> <span class="n">sep</span><span class="p">)</span>
        <span class="n">niStates</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="n">niStates</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dotDrawState</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">succintTransitions</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dotDrawTransition</span><span class="p">(</span><span class="n">si</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">si</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">si</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;}}{0:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>
</div>
<div class="viewcode-block" id="NFA.wordImage"><a class="viewcode-back" href="../index.html#fa.NFA.wordImage">[docs]</a>    <span class="k">def</span> <span class="nf">wordImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">ist</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the set of states reached consuming given word</span>

<span class="sd">        :param word: the word</span>
<span class="sd">        :type word: list of stings</span>
<span class="sd">        :param ist: starting state index (or set of)</span>
<span class="sd">        :type ist: int</span>
<span class="sd">        :returns: the set of ending states</span>
<span class="sd">        :rtype: Set of int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ist</span><span class="p">:</span>
            <span class="n">ist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
        <span class="n">ilist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonClosure</span><span class="p">(</span><span class="n">ist</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">ilist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">ilist</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ilist</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">ilist</span>
</div>
<div class="viewcode-block" id="NFA.product"><a class="viewcode-back" href="../index.html#fa.NFA.product">[docs]</a>    <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a NFA (skeletom) resulting of the simultaneous execution of two DFA.</span>

<span class="sd">        :param other: the other automata</span>
<span class="sd">        :type other: NFA</span>
<span class="sd">        :rtype: NFA</span>

<span class="sd">        .. note::</span>
<span class="sd">           No final states are set.</span>

<span class="sd">        .. attention::</span>
<span class="sd">           - the name ``EmptySet`` is used in a unique special state name</span>
<span class="sd">           - the method uses 3 internal functions for simplicity of code (really!)&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_sN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">DFAstateUnknown</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">j</span>

        <span class="k">def</span> <span class="nf">_kS</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">            :param a:</span>
<span class="sd">            :param j:</span>
<span class="sd">            :return:&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ks</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_dealT</span><span class="p">(</span><span class="n">srcI</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">            :param srcI: source state</span>
<span class="sd">            :param dest: destination state&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dest</span> <span class="ow">in</span> <span class="n">done</span> <span class="ow">or</span> <span class="n">dest</span> <span class="ow">in</span> <span class="n">notDone</span><span class="p">):</span>
                <span class="n">iN</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
                <span class="n">notDone</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iN</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">srcI</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">iN</span><span class="p">)</span>

        <span class="n">new</span> <span class="o">=</span> <span class="n">NFA</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="n">notDone</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">done</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">Initial</span><span class="p">]:</span>
                <span class="n">sname</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">sname</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">sname</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">notDone</span><span class="p">:</span>
                    <span class="n">notDone</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">notDone</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">notDone</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">done</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">_sN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">),</span> <span class="n">_sN</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>
            <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">_kS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i1</span><span class="p">),</span> <span class="n">_kS</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">i2</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">k2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">d1</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">d2</span><span class="p">])</span> <span class="k">for</span> <span class="n">d1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">d2</span> <span class="ow">in</span>
                                    <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i2</span><span class="p">][</span><span class="n">k</span><span class="p">]]:</span>
                    <span class="n">_dealT</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k1</span> <span class="o">-</span> <span class="n">k2</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">k</span><span class="p">]:</span>
                    <span class="n">_dealT</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">EmptySet</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k2</span> <span class="o">-</span> <span class="n">k1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i2</span><span class="p">][</span><span class="n">k</span><span class="p">]:</span>
                    <span class="n">_dealT</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">EmptySet</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
    <span class="k">def</span> <span class="nf">_toNFASingleInitial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct an equivalent NFA with only one initial state</span>

<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">aut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">Initial</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">Initial</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">Initial</span><span class="p">][</span><span class="n">Epsilon</span><span class="p">]</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">Initial</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">setInitial</span><span class="p">([</span><span class="n">Initial</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">aut</span>

    <span class="k">def</span> <span class="nf">_deleteRefInDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletion of a reference in Delta</span>

<span class="sd">        :param src: source state</span>
<span class="sd">        :type src: int</span>
<span class="sd">        :param sym: symbol</span>
<span class="sd">        :type sym: int</span>
<span class="sd">        :param dest: destination state</span>
<span class="sd">        :type dest: int&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">dest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">dest</span><span class="p">][</span><span class="n">sym</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">]):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">]):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_deleteRefInitial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletes a state from the set of initial states.  The other states are renumbered.</span>

<span class="sd">        :param sti: state index</span>
<span class="sd">        :type sti: int&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sti</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="NFA.toNFA"><a class="viewcode-back" href="../index.html#fa.NFA.toNFA">[docs]</a>    <span class="k">def</span> <span class="nf">toNFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Dummy identity function</span>

<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="NFA.toDFA"><a class="viewcode-back" href="../index.html#fa.NFA.toDFA">[docs]</a>    <span class="k">def</span> <span class="nf">toDFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a DFA equivalent to this NFA, by the subset construction method.</span>

<span class="sd">        :rtype: DFA</span>

<span class="sd">        .. note::</span>
<span class="sd">           valid to epsilon-NFA&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministicP</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toDFAd</span><span class="p">()</span>
        <span class="n">dfa</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">lStates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonClosure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
        <span class="n">dfa</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">dfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stl</span><span class="p">))</span>
        <span class="n">dfa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">stl</span><span class="p">:</span>
                <span class="n">dfa</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">slist</span> <span class="o">=</span> <span class="n">lStates</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">slist</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">stl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">slist</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stl</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">stl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lStates</span><span class="p">:</span>
                    <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                    <span class="n">foo</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">stl</span><span class="p">:</span>
                            <span class="n">dfa</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
                            <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">foo</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                <span class="n">dfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">foo</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lStates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">dfa</span>
</div>
<div class="viewcode-block" id="NFA.hasTransitionP"><a class="viewcode-back" href="../index.html#fa.NFA.hasTransitionP">[docs]</a>    <span class="k">def</span> <span class="nf">hasTransitionP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">symbol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether there&#39;s a transition from given state, optionally through given symbol,</span>
<span class="sd">        and optionally to a specific target.</span>

<span class="sd">        :param state: source state</span>
<span class="sd">        :type state: int</span>
<span class="sd">        :param symbol: optional transition symbol</span>
<span class="sd">        :type symbol: str</span>
<span class="sd">        :param target: optional target state</span>
<span class="sd">        :type target: int</span>
<span class="sd">        :returns: if there is a transition</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="NFA.usefulStates"><a class="viewcode-back" href="../index.html#fa.NFA.usefulStates">[docs]</a>    <span class="k">def</span> <span class="nf">usefulStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_states</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of states reacheable from the given initial state(s) that have a path to a final state.</span>

<span class="sd">        :param initial_states: set of initial states</span>
<span class="sd">        :type initial_states: set of int or list of int</span>
<span class="sd">        :returns: set of state indexes</span>
<span class="sd">        :rtype: set of int&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">initial_states</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">initial_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
        <span class="n">useful</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">initial_states</span>
                      <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">])</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">initial_states</span><span class="p">)</span>
        <span class="n">preceding</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">preceding</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">adjacent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                    <span class="n">is_useful</span> <span class="o">=</span> <span class="n">adjacent</span> <span class="ow">in</span> <span class="n">useful</span>
                    <span class="k">if</span> <span class="n">adjacent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="ow">or</span> <span class="n">is_useful</span><span class="p">:</span>
                        <span class="n">useful</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_useful</span><span class="p">:</span>
                            <span class="n">useful</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">adjacent</span><span class="p">)</span>
                            <span class="n">preceding</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adjacent</span><span class="p">)</span>
                        <span class="n">inpath_stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">preceding</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">useful</span><span class="p">]</span>
                        <span class="n">preceding</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">while</span> <span class="n">inpath_stack</span><span class="p">:</span>
                            <span class="n">previous</span> <span class="o">=</span> <span class="n">inpath_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">useful</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>
                            <span class="n">inpath_stack</span> <span class="o">+=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">preceding</span><span class="p">[</span><span class="n">previous</span><span class="p">]</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">useful</span><span class="p">]</span>
                            <span class="n">preceding</span><span class="p">[</span><span class="n">previous</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">adjacent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">preceding</span><span class="p">:</span>
                        <span class="n">preceding</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">state</span><span class="p">]</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adjacent</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">preceding</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">useful</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">useful</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">useful</span>
</div>
<div class="viewcode-block" id="NFA.eliminateEpsilonTransitions"><a class="viewcode-back" href="../index.html#fa.NFA.eliminateEpsilonTransitions">[docs]</a>    <span class="k">def</span> <span class="nf">eliminateEpsilonTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Eliminates all epslilon-transitions with no state addition</span>

<span class="sd">        .. attention::</span>
<span class="sd">           in-place modification&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">Epsilon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonClosure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">Epsilon</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="p">[]):</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">Epsilon</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="n">a</span><span class="p">]:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">Epsilon</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">delTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="NFA.autobisimulation"><a class="viewcode-back" href="../index.html#fa.NFA.autobisimulation">[docs]</a>    <span class="k">def</span> <span class="nf">autobisimulation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Largest right invariant equivalence between states of the NFA</span>

<span class="sd">        :returns: Incomplete equivalence relation (transitivity, and reflexivity not calculated) as a set of</span>
<span class="sd">                    unordered pairs of states</span>
<span class="sd">        :rtype: Set of frozensets</span>

<span class="sd">        .. seealso:: Ilie&amp;Yu, 2003&quot;&quot;&quot;</span>
        <span class="n">n_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="n">undecided_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">frozenset</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                               <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)])</span>
        <span class="n">marked</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">undecided_pairs</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pair</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
                <span class="n">marked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_desc_marked</span><span class="p">(</span><span class="n">d_p</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">mrkd</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">            :param d_p:</span>
<span class="sd">            :param sym:</span>
<span class="sd">            :param q1:</span>
<span class="sd">            :param mrkd:&quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">d_q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">q1</span><span class="p">][</span><span class="n">sym</span><span class="p">]:</span>
                <span class="k">yield</span> <span class="nb">frozenset</span><span class="p">((</span><span class="n">d_p</span><span class="p">,</span> <span class="n">d_q</span><span class="p">))</span> <span class="ow">in</span> <span class="n">mrkd</span>

        <span class="n">changed_marked</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="n">changed_marked</span><span class="p">:</span>
            <span class="n">changed_marked</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">undecided_pairs</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">marked</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">undecided_pairs</span><span class="p">:</span>
                <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">pair</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">q</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                        <span class="n">marked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                        <span class="n">changed_marked</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">p</span><span class="p">]:</span>
                            <span class="k">for</span> <span class="n">desc_p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">_desc_marked</span><span class="p">(</span><span class="n">desc_p</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">marked</span><span class="p">)):</span>
                                    <span class="n">marked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                                    <span class="n">changed_marked</span> <span class="o">=</span> <span class="bp">True</span>
                                    <span class="k">break</span>
                            <span class="k">if</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">:</span>
                                <span class="k">break</span>
                <span class="k">if</span> <span class="n">pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">marked</span> <span class="ow">and</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                        <span class="n">marked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                        <span class="n">changed_marked</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">q</span><span class="p">]:</span>
                            <span class="k">for</span> <span class="n">desc_q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">_desc_marked</span><span class="p">(</span><span class="n">desc_q</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">marked</span><span class="p">)):</span>
                                    <span class="n">marked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                                    <span class="n">changed_marked</span> <span class="o">=</span> <span class="bp">True</span>
                                    <span class="k">break</span>
                            <span class="k">if</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">:</span>
                                <span class="k">break</span>
        <span class="n">undecided_pairs</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">marked</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">undecided_pairs</span>

    <span class="c"># noinspection PyUnusedLocal</span></div>
<div class="viewcode-block" id="NFA.autobisimulation2"><a class="viewcode-back" href="../index.html#fa.NFA.autobisimulation2">[docs]</a>    <span class="k">def</span> <span class="nf">autobisimulation2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alternative space-efficient definition of NFA.autobisimulation.</span>

<span class="sd">        :returns: Incomplete equivalence relation (reflexivity, symmetry, and transitivity not calculated) as a set</span>
<span class="sd">                  of pairs of states</span>
<span class="sd">        :rtype: list of tuples&quot;&quot;&quot;</span>
        <span class="n">n_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="n">marked</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
                    <span class="n">marked</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">_all_desc_marked</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">mrkd</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">            :param p:</span>
<span class="sd">            :param q:</span>
<span class="sd">            :param mrkd:&quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">p</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">desc_p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">s</span><span class="p">]:</span>
                    <span class="n">all_marked</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">for</span> <span class="n">desc_q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">s</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">desc_p</span><span class="p">,</span> <span class="n">desc_q</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mrkd</span> <span class="ow">and</span> <span class="p">(</span><span class="n">desc_q</span><span class="p">,</span> <span class="n">desc_p</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mrkd</span><span class="p">:</span>
                            <span class="n">all_marked</span> <span class="o">=</span> <span class="bp">False</span>
                            <span class="k">break</span>
                    <span class="k">yield</span> <span class="n">all_marked</span>

        <span class="n">changed_marked</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="n">changed_marked</span><span class="p">:</span>
            <span class="c"># noinspection PyUnusedLocal</span>
            <span class="n">changed_marked</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                        <span class="n">marked</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                        <span class="n">changed_marked</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">_all_desc_marked</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">marked</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">_all_desc_marked</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">marked</span><span class="p">)):</span>
                        <span class="n">marked</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                        <span class="n">changed_marked</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">continue</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="NFA.equivReduced"><a class="viewcode-back" href="../index.html#fa.NFA.equivReduced">[docs]</a>    <span class="k">def</span> <span class="nf">equivReduced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">equiv_classes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent NFA reduced according to given equivalence classes.</span>

<span class="sd">        :param equiv_classes: Equivalence classes</span>
<span class="sd">        :type equiv_classes: UnionFind</span>
<span class="sd">        :returns: Equivalent NFA</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">nfa</span> <span class="o">=</span> <span class="n">NFA</span><span class="p">()</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">rename_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">istate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">equiv_istate</span> <span class="o">=</span> <span class="n">equiv_classes</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">istate</span><span class="p">)</span>
            <span class="n">equiv_istate_renamed</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">equiv_istate</span><span class="p">)</span>
            <span class="n">rename_map</span><span class="p">[</span><span class="n">equiv_istate</span><span class="p">]</span> <span class="o">=</span> <span class="n">equiv_istate_renamed</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">equiv_istate_renamed</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="n">equiv_state</span> <span class="o">=</span> <span class="n">equiv_classes</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">equiv_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rename_map</span><span class="p">:</span>
                <span class="n">equiv_state_renamed</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">equiv_state</span><span class="p">)</span>
                <span class="n">rename_map</span><span class="p">[</span><span class="n">equiv_state</span><span class="p">]</span> <span class="o">=</span> <span class="n">equiv_state_renamed</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">equiv_state_renamed</span> <span class="o">=</span> <span class="n">rename_map</span><span class="p">[</span><span class="n">equiv_state</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                    <span class="n">equiv_target</span> <span class="o">=</span> <span class="n">equiv_classes</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">equiv_target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rename_map</span><span class="p">:</span>
                        <span class="n">equiv_target_renamed</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">equiv_target</span><span class="p">)</span>
                        <span class="n">rename_map</span><span class="p">[</span><span class="n">equiv_target</span><span class="p">]</span> <span class="o">=</span> <span class="n">equiv_target_renamed</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">equiv_target_renamed</span> <span class="o">=</span> <span class="n">rename_map</span><span class="p">[</span><span class="n">equiv_target</span><span class="p">]</span>
                    <span class="n">nfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">equiv_state_renamed</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">equiv_target_renamed</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">equiv_state</span> <span class="o">=</span> <span class="n">equiv_classes</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">equiv_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rename_map</span><span class="p">:</span>
                <span class="n">rename_map</span><span class="p">[</span><span class="n">equiv_state</span><span class="p">]</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">equiv_state</span><span class="p">)</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">rename_map</span><span class="p">[</span><span class="n">equiv_state</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">nfa</span>
</div>
<div class="viewcode-block" id="NFA.rEquivNFA"><a class="viewcode-back" href="../index.html#fa.NFA.rEquivNFA">[docs]</a>    <span class="k">def</span> <span class="nf">rEquivNFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent NFA obtained from merging equivalent states from autobisimulation of this NFA.</span>

<span class="sd">        :rtype: NFA</span>

<span class="sd">        .. note::</span>
<span class="sd">           returns copy of self if autobisimulation renders no equivalent states.&quot;&quot;&quot;</span>
        <span class="n">autobisimulation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autobisimulation</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">autobisimulation</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">equiv_classes</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">auto_create</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">equiv_classes</span><span class="o">.</span><span class="n">make_set</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">autobisimulation</span><span class="p">:</span>
            <span class="n">equiv_classes</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivReduced</span><span class="p">(</span><span class="n">equiv_classes</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NFA.lEquivNFA"><a class="viewcode-back" href="../index.html#fa.NFA.lEquivNFA">[docs]</a>    <span class="k">def</span> <span class="nf">lEquivNFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent NFA obtained from merging equivalent states from autobisimulation of this NFA&#39;s reversal.</span>

<span class="sd">        :rtype: NFA</span>

<span class="sd">        .. note::</span>
<span class="sd">           returns copy of self if autobisimulation renders no equivalent states.&quot;&quot;&quot;</span>
        <span class="n">autobisimulation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reversal</span><span class="p">()</span><span class="o">.</span><span class="n">autobisimulation</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">autobisimulation</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">equiv_classes</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">auto_create</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">equiv_classes</span><span class="o">.</span><span class="n">make_set</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">autobisimulation</span><span class="p">:</span>
            <span class="n">equiv_classes</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivReduced</span><span class="p">(</span><span class="n">equiv_classes</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NFA.lrEquivNFA"><a class="viewcode-back" href="../index.html#fa.NFA.lrEquivNFA">[docs]</a>    <span class="k">def</span> <span class="nf">lrEquivNFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent NFA obtained from merging equivalent states from autobisimulation of this NFA,</span>
<span class="sd">        and from autobisimulation of its reversal; i.e., merges all states that are equivalent w.r.t. the largest</span>
<span class="sd">        right invariant and largest left invariant equivalence relations.</span>

<span class="sd">        :rtype: NFA</span>

<span class="sd">        .. note::</span>
<span class="sd">           returns copy of self if autobisimulations render no equivalent states.&quot;&quot;&quot;</span>
        <span class="n">l_nfa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lEquivNFA</span><span class="p">()</span>
        <span class="n">lr_nfa</span> <span class="o">=</span> <span class="n">l_nfa</span><span class="o">.</span><span class="n">rEquivNFA</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">l_nfa</span>
        <span class="k">return</span> <span class="n">lr_nfa</span>
</div>
<div class="viewcode-block" id="NFA.epsilonPaths"><a class="viewcode-back" href="../index.html#fa.NFA.epsilonPaths">[docs]</a>    <span class="k">def</span> <span class="nf">epsilonPaths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;All states in all paths (DFS) through empty words from a given starting state to a given ending state.</span>

<span class="sd">        :param start: start state</span>
<span class="sd">        :type start: int</span>
<span class="sd">        :param end: end state</span>
<span class="sd">        :type end: int</span>
<span class="sd">        :returns: states in epsilon paths from start to end</span>
<span class="sd">        :rtype: set of states&quot;&quot;&quot;</span>
        <span class="n">inpaths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="n">preceding</span> <span class="o">=</span> <span class="p">{</span><span class="n">start</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasTransitionP</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">adjacent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">Epsilon</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">adjacent</span> <span class="ow">is</span> <span class="n">end</span> <span class="ow">or</span> <span class="n">adjacent</span> <span class="ow">in</span> <span class="n">inpaths</span><span class="p">:</span>
                        <span class="n">inpaths</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                        <span class="n">inpath_stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">preceding</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inpaths</span><span class="p">]</span>
                        <span class="n">preceding</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">while</span> <span class="n">inpath_stack</span><span class="p">:</span>
                            <span class="n">previous</span> <span class="o">=</span> <span class="n">inpath_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">inpaths</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>
                            <span class="n">inpath_stack</span> <span class="o">+=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">preceding</span><span class="p">[</span><span class="n">previous</span><span class="p">]</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inpaths</span><span class="p">]</span>
                            <span class="n">preceding</span><span class="p">[</span><span class="n">previous</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">adjacent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">preceding</span><span class="p">:</span>
                        <span class="n">preceding</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">state</span><span class="p">]</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adjacent</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">preceding</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inpaths</span>
</div>
<div class="viewcode-block" id="NFA.toNFAr"><a class="viewcode-back" href="../index.html#fa.NFA.toNFAr">[docs]</a>    <span class="k">def</span> <span class="nf">toNFAr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NFA with the reverse mapping of the delta function.</span>

<span class="sd">        :returns: shallow copy with reverse delta function added</span>
<span class="sd">        :rtype: NFAr&quot;&quot;&quot;</span>
        <span class="n">nfaR</span> <span class="o">=</span> <span class="n">NFAr</span><span class="p">()</span>
        <span class="n">nfaR</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">nfaR</span><span class="o">.</span><span class="n">setFinal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
        <span class="n">nfaR</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">nfaR</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                    <span class="n">nfaR</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nfaR</span>
</div>
<div class="viewcode-block" id="NFA.countTransitions"><a class="viewcode-back" href="../index.html#fa.NFA.countTransitions">[docs]</a>    <span class="k">def</span> <span class="nf">countTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of transitions of a NFA</span>

<span class="sd">        :rtype: int&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()))</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="NFA.toGFA"><a class="viewcode-back" href="../index.html#fa.NFA.toGFA">[docs]</a>    <span class="k">def</span> <span class="nf">toGFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a GFA equivalent to NFA</span>

<span class="sd">        :returns: a GFA deep copy</span>
<span class="sd">        :rtype: GFA &quot;&quot;&quot;</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="n">GFA</span><span class="p">()</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="c"># this should be optimized</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toNFASingleInitial</span><span class="p">()</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="n">uSet</span><span class="p">(</span><span class="n">fa</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">States</span><span class="p">[:]</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">setFinal</span><span class="p">(</span><span class="n">fa</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fa</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">fa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">fa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="n">gfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gfa</span>
</div>
<div class="viewcode-block" id="NFA.stateChildren"><a class="viewcode-back" href="../index.html#fa.NFA.stateChildren">[docs]</a>    <span class="k">def</span> <span class="nf">stateChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of children of a state</span>

<span class="sd">        :param strict: if not strict a state is never its own child even if a self loop is in place</span>
<span class="sd">        :type strict: bool</span>
<span class="sd">        :param state: state id queried</span>
<span class="sd">        :type state: int</span>
<span class="sd">        :returns: children states</span>
<span class="sd">        :rtype: Set of int&quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">l</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                <span class="n">l</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">strict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span>
</div>
<div class="viewcode-block" id="NFA.half"><a class="viewcode-back" href="../index.html#fa.NFA.half">[docs]</a>    <span class="k">def</span> <span class="nf">half</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Half operation</span>

<span class="sd">        .. versionadded:: 0.9.6&quot;&quot;&quot;</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">a1</span><span class="o">.</span><span class="n">renameStates</span><span class="p">()</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span><span class="o">.</span><span class="n">reversal</span><span class="p">()</span>
        <span class="n">a4</span> <span class="o">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">_starTransitions</span><span class="p">()</span>
        <span class="n">a3</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">a4</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">a3</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n1</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;@empty_set&quot;</span> <span class="ow">or</span> <span class="n">n2</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;@empty_set&quot;</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">n1</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span> <span class="o">==</span> <span class="n">n2</span><span class="o">.</span><span class="n">__str__</span><span class="p">():</span>
                <span class="n">a3</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">a3</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)))</span>
        <span class="n">a3</span><span class="o">.</span><span class="n">deleteStates</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">a3</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">a3</span>
</div>
    <span class="k">def</span> <span class="nf">_starTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">NFA</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                        <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>

<div class="viewcode-block" id="NFA.subword"><a class="viewcode-back" href="../index.html#fa.NFA.subword">[docs]</a>    <span class="k">def</span> <span class="nf">subword</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns a nfa that recognizes subword(L(self))</span>

<span class="sd">        :rtype: nfa</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">ss</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sym</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">Epsilon</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">Epsilon</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="n">c</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">Epsilon</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span>
</div>
<div class="viewcode-block" id="NFA.enumNFA"><a class="viewcode-back" href="../index.html#fa.NFA.enumNFA">[docs]</a>    <span class="k">def</span> <span class="nf">enumNFA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the set of words of words of length up to n accepted by self</span>
<span class="sd">        :param n: highest lenght or all words if finite</span>
<span class="sd">        :type n: int</span>

<span class="sd">        :rtype: list of strings or None</span>

<span class="sd">        .. note: use with care because the number of words can be huge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">elimEpsilon</span><span class="p">()</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">EnumNFA</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">words</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">e</span><span class="o">.</span><span class="n">enumCrossSection</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">words</span> <span class="o">+=</span> <span class="n">e</span><span class="o">.</span><span class="n">Words</span>
        <span class="k">return</span> <span class="n">words</span>

    
<span class="c"># noinspection PyTypeChecker</span></div></div>
<div class="viewcode-block" id="NFAr"><a class="viewcode-back" href="../index.html#fa.NFAr">[docs]</a><span class="k">class</span> <span class="nc">NFAr</span><span class="p">(</span><span class="n">NFA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for Non-deterministic Finite Automata with reverse delta function added by construction.</span>

<span class="sd">    .. inheritance-diagram:: NFAr</span>

<span class="sd">    :var deltaReverse: the reversed transition function</span>

<span class="sd">    .. note::</span>
<span class="sd">       Includes efficient methods for merging states.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NFAr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="NFAr.addTransition"><a class="viewcode-back" href="../index.html#fa.NFAr.addTransition">[docs]</a>    <span class="k">def</span> <span class="nf">addTransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">sti2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a new transition. Transition is from ``sti1`` to ``sti2`` consuming symbol ``sym``. ``sti2`` is a</span>
<span class="sd">        unique state, not a set of them. Reversed transition function  is also computed</span>

<span class="sd">        :param sti1: state index of departure</span>
<span class="sd">        :type sti1: int</span>
<span class="sd">        :param sti2: state index of arrival</span>
<span class="sd">        :type sti2: int</span>
<span class="sd">        :param sym: symbol consumed</span>
<span class="sd">        :type sym: str&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NFAr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">sti1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">sti2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sti2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">sti2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">sym</span><span class="p">:</span> <span class="p">{</span><span class="n">sti1</span><span class="p">}}</span>
        <span class="k">elif</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">sti2</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">sti2</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">sti1</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">sti2</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sti1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NFAr.delTransition"><a class="viewcode-back" href="../index.html#fa.NFAr.delTransition">[docs]</a>    <span class="k">def</span> <span class="nf">delTransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">sti2</span><span class="p">,</span> <span class="n">_no_check</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove a transition if existing and perform cleanup on the transition function&#39;s internal data structure</span>
<span class="sd">        and in the reversal transition function</span>

<span class="sd">        :param sti1: state index of departure</span>
<span class="sd">        :type sti1: int</span>
<span class="sd">        :param sti2: state index of arrival</span>
<span class="sd">        :type sti2: int</span>
<span class="sd">        :param sym: symbol consumed</span>
<span class="sd">        :type sym: str</span>
<span class="sd">        :param _no_check: dismiss secure code</span>
<span class="sd">        :type _no_check: bool&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NFAr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">delTransition</span><span class="p">(</span><span class="n">sti1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">sti2</span><span class="p">,</span> <span class="n">_no_check</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_no_check</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sti2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span> <span class="ow">or</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">sti2</span><span class="p">]):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">sti2</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">sti1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">sti2</span><span class="p">][</span><span class="n">sym</span><span class="p">]:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">sti2</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">sti2</span><span class="p">]:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">sti2</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="NFAr.deleteStates"><a class="viewcode-back" href="../index.html#fa.NFAr.deleteStates">[docs]</a>    <span class="k">def</span> <span class="nf">deleteStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">del_states</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete given iterable collection of states from the automaton. Performe deletion in the transition</span>
<span class="sd">        function and its reversal.</span>

<span class="sd">        :param del_states: collection of int representing states</span>
<span class="sd">        :type del_states: set or list of int&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NFAr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">deleteStates</span><span class="p">(</span><span class="n">del_states</span><span class="p">)</span>
        <span class="n">new_deltaReverse</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">target</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_deltaReverse</span><span class="p">:</span>
                        <span class="n">new_deltaReverse</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_deltaReverse</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
                        <span class="n">new_deltaReverse</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                    <span class="n">new_deltaReverse</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span> <span class="o">=</span> <span class="n">new_deltaReverse</span>
</div>
<div class="viewcode-block" id="NFAr.mergeStates"><a class="viewcode-back" href="../index.html#fa.NFAr.mergeStates">[docs]</a>    <span class="k">def</span> <span class="nf">mergeStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge the first given state into the second. If first state is an initial or final state,</span>
<span class="sd">        the second becomes respectively an initial or final state.</span>

<span class="sd">        :param f: index of state to be absorbed</span>
<span class="sd">        :type f: int</span>
<span class="sd">        :param t: index of remaining state</span>
<span class="sd">        :type t:  int</span>

<span class="sd">        .. attention::</span>
<span class="sd">           It is up to the caller to remove the disconnected</span>
<span class="sd">           state. This can be achieved with ```trim()``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">f</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">state</span> <span class="o">=</span> <span class="n">t</span>
                    <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="n">t</span> <span class="ow">and</span> <span class="n">symbol</span> <span class="ow">is</span> <span class="n">Epsilon</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                        <span class="k">del</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">])</span>
            <span class="k">del</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">f</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">state</span> <span class="o">=</span> <span class="n">t</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="n">t</span> <span class="ow">and</span> <span class="n">symbol</span> <span class="ow">is</span> <span class="n">Epsilon</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                        <span class="k">del</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">])</span>
            <span class="k">del</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NFAr.mergeStatesSet"><a class="viewcode-back" href="../index.html#fa.NFAr.mergeStatesSet">[docs]</a>    <span class="k">def</span> <span class="nf">mergeStatesSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge a set of states with a target merge state. If the states in the set have transitions among them,</span>
<span class="sd">        those transitions will be directly merged into the target state.</span>

<span class="sd">        :param tomerge: set of states to merge with target</span>
<span class="sd">        :type tomerge: Set of initegers</span>
<span class="sd">        :param target: optional target state</span>
<span class="sd">        :type target: int</span>

<span class="sd">        .. note::</span>
<span class="sd">           if target state is not given, the minimal index with be considered.</span>

<span class="sd">        .. attention::</span>
<span class="sd">           The states of the list will become unreacheable, but won&#39;t be removed. It is up to the caller to remove</span>
<span class="sd">           them. That can be achieved with ``trim()``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tomerge</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tomerge</span><span class="p">)</span>
        <span class="c"># noinspection PyUnresolvedReferences</span>
        <span class="n">tomerge</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="p">:</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="n">target</span>
                        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">is</span> <span class="n">Epsilon</span> <span class="ow">and</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">target</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="p">:</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="n">target</span>
                        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">is</span> <span class="n">Epsilon</span> <span class="ow">and</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">target</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                <span class="k">del</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">del</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">target</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">is</span> <span class="n">Epsilon</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tomerge</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tomerge</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">target</span>
</div>
<div class="viewcode-block" id="NFAr.homogenousP"><a class="viewcode-back" href="../index.html#fa.NFAr.homogenousP">[docs]</a>    <span class="k">def</span> <span class="nf">homogenousP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks is the automaton is homogenous, i.e.the transitions that reaches a state have all the same label.</span>

<span class="sd">        :arg inplace: if True performs epsilon transitions elimination</span>
<span class="sd">        :type inplace: bool</span>
<span class="sd">        :return: True if homogenous</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="n">nfa</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elimEpsilon</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nfa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
                <span class="n">nfa</span><span class="o">.</span><span class="n">elimEpsilon</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">nfa</span><span class="o">.</span><span class="n">deltaReverse</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()])</span>
</div>
<div class="viewcode-block" id="NFAr.elimEpsilonO"><a class="viewcode-back" href="../index.html#fa.NFAr.elimEpsilonO">[docs]</a>    <span class="k">def</span> <span class="nf">elimEpsilonO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Eliminate epsilon-transitions from this automaton, with reduction of states through elimination of</span>
<span class="sd">        epsilon-cycles, and single epsilon-transition cases.</span>

<span class="sd">        :returns: itself</span>
<span class="sd">        :rtype:</span>

<span class="sd">        .. attention::</span>
<span class="sd">           performs inplace modification of automaton&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">merge_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonPaths</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="n">merge_states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unlinkSoleOutgoing</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
            <span class="n">merge_states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unlinkSoleIncoming</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
            <span class="n">merge_states</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">merge_states</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merge_states</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mergeStates</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">merge_states</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mergeStatesSet</span><span class="p">(</span><span class="n">merge_states</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NFAr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">elimEpsilon</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="NFAr.unlinkSoleIncoming"><a class="viewcode-back" href="../index.html#fa.NFAr.unlinkSoleIncoming">[docs]</a>    <span class="k">def</span> <span class="nf">unlinkSoleIncoming</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If given state has only one incoming transition (indegree is one), and it&#39;s through epsilon,</span>
<span class="sd">        then remove such transition and return the source state.</span>

<span class="sd">        :param state: state to check</span>
<span class="sd">        :type state: int</span>
<span class="sd">        :returns: source state</span>
<span class="sd">        :rtype: int or None</span>

<span class="sd">        .. note::</span>
<span class="sd">           if conditions aren&#39;t met, returned source state is None, and automaton remains unmodified.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">[]))</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Epsilon</span><span class="p">,</span> <span class="p">[]))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">source_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">Epsilon</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delTransition</span><span class="p">(</span><span class="n">source_state</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">source_state</span>
</div>
<div class="viewcode-block" id="NFAr.unlinkSoleOutgoing"><a class="viewcode-back" href="../index.html#fa.NFAr.unlinkSoleOutgoing">[docs]</a>    <span class="k">def</span> <span class="nf">unlinkSoleOutgoing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If given state has only one outgoing transition (outdegree is one), and it&#39;s through epsilon,</span>
<span class="sd">        then remove such transition and return the target state.</span>

<span class="sd">        :param state: state to check</span>
<span class="sd">        :type state: int</span>
<span class="sd">        :returns: target state</span>
<span class="sd">        :rtype: int or None</span>

<span class="sd">        .. note::</span>
<span class="sd">           if conditions aren&#39;t met, returned target state is None, and automaton remains unmodified.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">[]))</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Epsilon</span><span class="p">,</span> <span class="p">[]))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">target_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">Epsilon</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delTransition</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">target_state</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">target_state</span>
</div>
<div class="viewcode-block" id="NFAr.toNFA"><a class="viewcode-back" href="../index.html#fa.NFAr.toNFA">[docs]</a>    <span class="k">def</span> <span class="nf">toNFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn into an instance of NFA, and remove the reverse mapping of the delta function.</span>

<span class="sd">        :returns: shallow copy without reverse delta function</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">nfa</span> <span class="o">=</span> <span class="n">NFA</span><span class="p">()</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span>
        <span class="k">return</span> <span class="n">nfa</span>


<span class="c"># noinspection PyTypeChecker</span></div></div>
<div class="viewcode-block" id="DFA"><a class="viewcode-back" href="../index.html#fa.DFA">[docs]</a><span class="k">class</span> <span class="nc">DFA</span><span class="p">(</span><span class="n">OFA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Class for Deterministic Finite Automata.</span>

<span class="sd">    .. inheritance-diagram:: DFA&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DFA</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_inv</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="DFA.vDescription"><a class="viewcode-back" href="../index.html#fa.DFA.vDescription">[docs]</a>    <span class="k">def</span> <span class="nf">vDescription</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Generation of Verso interface description</span>

<span class="sd">        .. versionadded:: 0.9.5</span>

<span class="sd">        :return: the interface list&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;Deterministic Finite Automata&quot;</span><span class="p">),</span>
                <span class="p">[(</span><span class="s">&quot;DFAFAdo&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">saveToString</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&quot;FAdo&quot;</span><span class="p">),</span>
                 <span class="p">(</span><span class="s">&quot;DFAdot&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">dotFormat</span><span class="p">(</span><span class="s">&quot;&amp;&quot;</span><span class="p">),</span> <span class="s">&quot;dot&quot;</span><span class="p">)],</span>
                <span class="p">(</span><span class="s">&quot;DFA-complete-minimal&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Complete minimal automata&quot;</span><span class="p">,</span> <span class="s">&quot;Complete minimal automata&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span>
                 <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">completeMinimal</span><span class="p">()),</span>
                <span class="p">(</span><span class="s">&quot;DFA-concatenation&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Concatenate two DFAs&quot;</span><span class="p">,</span> <span class="s">&quot;Concatenate two DFAs&quot;</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span>
                 <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                <span class="p">(</span><span class="s">&quot;DFA-conjunction&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Intersection of DFAs&quot;</span><span class="p">,</span> <span class="s">&quot;Intersection of DFAs&quot;</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span>
                 <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conjunction</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                <span class="p">(</span><span class="s">&quot;DFA-disjunction&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Disjunction of DFAs&quot;</span><span class="p">,</span> <span class="s">&quot;Disjunction of DFAs&quot;</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span>
                 <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">disjunction</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                <span class="p">(</span><span class="s">&quot;DFA-to-NFA&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Convert to NFA&quot;</span><span class="p">,</span> <span class="s">&quot;Convert to NFA&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;NFA&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()),</span>
                <span class="p">(</span><span class="s">&quot;DFA-acyclicP&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Test if automata is acyclic&quot;</span><span class="p">,</span> <span class="s">&quot;Test if automata is acyclic&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;Bool&quot;</span><span class="p">,</span>
                 <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">acyclicP</span><span class="p">()),</span>
                <span class="p">(</span><span class="s">&quot;DFA-trim&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Trim automata&quot;</span><span class="p">,</span> <span class="s">&quot;Trim automata&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">trim</span><span class="p">()),</span>
                <span class="p">(</span><span class="s">&quot;DFA-trimP&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Test if automata is trim&quot;</span><span class="p">,</span> <span class="s">&quot;Test if automata is trim&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;Bool&quot;</span><span class="p">,</span>
                 <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">trimP</span><span class="p">()),</span>
                <span class="p">(</span><span class="s">&quot;DFA-to-reversal-NFA&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Reversal NFA&quot;</span><span class="p">,</span> <span class="s">&quot;Reversal NFA&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;NFA&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reversal</span><span class="p">()),</span>
                <span class="p">(</span><span class="s">&quot;DFA-minimal-Brzozowski&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Minimal (Brzozowski)&quot;</span><span class="p">,</span> <span class="s">&quot;Minimal (Brzozowski)&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span>
                 <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">minimalBrzozowski</span><span class="p">()),</span>
                <span class="p">(</span><span class="s">&quot;DFA-minimalP-Brzozowski&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Test minimality (Brzozowski)&quot;</span><span class="p">,</span> <span class="s">&quot;Test minimality (Brzozowski)&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span>
                 <span class="s">&quot;Bool&quot;</span><span class="p">,</span>
                 <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">minimalBrzozowskiP</span><span class="p">()),</span>
                <span class="p">(</span><span class="s">&quot;DFA-regexp-SE&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Convert to RE&quot;</span><span class="p">,</span> <span class="s">&quot;Convert to RE by state elimination&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;RE&quot;</span><span class="p">,</span>
                 <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">regexpSE</span><span class="p">()),</span>
                <span class="p">(</span><span class="s">&quot;DFA-dump&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;dump&quot;</span><span class="p">,</span> <span class="s">&quot;dump&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;DFA&quot;</span><span class="p">,</span> <span class="s">&quot;str&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">saveToString</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; DFA informal string representation&quot;</span>
<span class="sd">        :returns: str</span>
<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&#39;DFA({0:&gt;s})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__str__</span><span class="p">())</span>

<div class="viewcode-block" id="DFA.succintTransitions"><a class="viewcode-back" href="../index.html#fa.DFA.succintTransitions">[docs]</a>    <span class="k">def</span> <span class="nf">succintTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Collects the transition information in a compact way suitable for graphical representation.</span>
<span class="sd">        :rtype: list of tupples</span>

<span class="sd">        .. versionadded:: 0.9.8&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
                    <span class="n">foo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">foo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="n">foo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;, </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]])))</span>
        <span class="k">return</span> <span class="n">l</span>
</div>
<div class="viewcode-block" id="DFA.initialP"><a class="viewcode-back" href="../index.html#fa.DFA.initialP">[docs]</a>    <span class="k">def</span> <span class="nf">initialP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Tests if a state is initial</span>

<span class="sd">        :param state: state index</span>
<span class="sd">        :type state: int</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">==</span> <span class="n">state</span>
</div>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_getTags</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;returns Tags for dump</span>

<span class="sd">        :rtype: list of str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">&quot;DFA&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="DFA.initialSet"><a class="viewcode-back" href="../index.html#fa.DFA.initialSet">[docs]</a>    <span class="k">def</span> <span class="nf">initialSet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The set of initial states</span>

<span class="sd">        :returns: the set of the initial states</span>
<span class="sd">        :rtype: set of States&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">}</span>
</div>
<div class="viewcode-block" id="DFA.Delta"><a class="viewcode-back" href="../index.html#fa.DFA.Delta">[docs]</a>    <span class="k">def</span> <span class="nf">Delta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">symbol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the action of a symbol over a state</span>

<span class="sd">        :arg state: state index</span>
<span class="sd">        :type state: int</span>
<span class="sd">        :arg symbol: symbol</span>
<span class="sd">        :returns: the action of symbol over state</span>
<span class="sd">        :rtype: int&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">r</span>
</div>
    <span class="k">def</span> <span class="nf">_deleteRefInDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param src:</span>
<span class="sd">        :param sym:</span>
<span class="sd">        :param dest:&quot;&quot;&quot;</span>
        <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="o">==</span> <span class="n">old</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">old</span> <span class="o">&gt;</span> <span class="n">dest</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">old</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">]):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_deleteRefInitial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletes a state as Initial. If sti not Initial, Initial is renumbered if needed.</span>

<span class="sd">        :param sti: state index</span>
<span class="sd">        :type sti: int&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sti</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">sti</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="bp">None</span>

<div class="viewcode-block" id="DFA.deleteStates"><a class="viewcode-back" href="../index.html#fa.DFA.deleteStates">[docs]</a>    <span class="k">def</span> <span class="nf">deleteStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">del_states</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete given iterable collection of states from the automaton.</span>

<span class="sd">        :param del_states: collection of int representing states</span>

<span class="sd">        .. note::</span>
<span class="sd">           delta function will always be rebuilt, regardless of whether the states list to remove is a suffix,</span>
<span class="sd">           or a sublist, of the automaton&#39;s states list.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">del_states</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">rename_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">old_delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_final</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">new_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">del_states</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialP</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">del_states</span><span class="p">:</span>
                <span class="n">rename_map</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_states</span><span class="p">)</span>
                <span class="n">new_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">rename_map</span><span class="p">:</span>
            <span class="n">state_renamed</span> <span class="o">=</span> <span class="n">rename_map</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">new_final</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state_renamed</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">old_delta</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">old_delta</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">rename_map</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">state_renamed</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">rename_map</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">new_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="n">new_final</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># noinspection PyNoneFunctionAssignment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="n">rename_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DFA.addTransition"><a class="viewcode-back" href="../index.html#fa.DFA.addTransition">[docs]</a>    <span class="k">def</span> <span class="nf">addTransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">sti2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a new transition from ``sti1`` to ``sti2`` consuming symbol ``sym``.</span>

<span class="sd">        :param sti1: state index of departure</span>
<span class="sd">        :type sti1: int</span>
<span class="sd">        :param sti2: state index of arrival</span>
<span class="sd">        :type sti2: int</span>
<span class="sd">        :param sym: symbol consumed</span>
<span class="sd">        :type sym: str</span>
<span class="sd">        :raises DFAnotNFA: if one tries to add a non deterministic transition&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAnotNFA</span><span class="p">(</span><span class="s">&quot;Invalid epsilon transition from {0:&gt;s} to {1:&gt;s}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sti1</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">sti2</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sti1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">sym</span><span class="p">:</span> <span class="n">sti2</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">sti2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DFAnotNFA</span><span class="p">(</span><span class="s">&quot;extra transition from ({0:&gt;s}, {1:&gt;s})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sti1</span><span class="p">),</span> <span class="n">sym</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">sti2</span>
</div>
<div class="viewcode-block" id="DFA.delTransition"><a class="viewcode-back" href="../index.html#fa.DFA.delTransition">[docs]</a>    <span class="k">def</span> <span class="nf">delTransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">sti2</span><span class="p">,</span> <span class="n">_no_check</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove a transition if existing and perform cleanup on the transition function&#39;s internal data structure.</span>

<span class="sd">        :param _no_check: use unsecure code?</span>
<span class="sd">        :type _no_check: Boolean</span>
<span class="sd">        :param sti1: state index of departure</span>
<span class="sd">        :param sti2: state index of arrival</span>
<span class="sd">        :param sym: symbol consumed</span>
<span class="sd">        :type sti2: int</span>
<span class="sd">        :type sti1: int</span>
<span class="sd">        :type sym: str</span>

<span class="sd">        .. note::</span>
<span class="sd">           Unused alphabet symbols will be discarded from Sigma.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_no_check</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sti1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="ow">or</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">sti2</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">itervalues</span><span class="p">())):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="DFA.inDegree"><a class="viewcode-back" href="../index.html#fa.DFA.inDegree">[docs]</a>    <span class="k">def</span> <span class="nf">inDegree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the in-degree of a given state in an FA</span>

<span class="sd">        :param st: index of the state</span>
<span class="sd">        :type st: int</span>

<span class="sd">        :rtype: int&quot;&quot;&quot;</span>
        <span class="n">in_deg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">st</span><span class="p">:</span>
                        <span class="n">in_deg</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">in_deg</span>
</div>
<div class="viewcode-block" id="DFA.syncPower"><a class="viewcode-back" href="../index.html#fa.DFA.syncPower">[docs]</a>    <span class="k">def</span> <span class="nf">syncPower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the power automata for the action of each symbol</span>

<span class="sd">        :return: The power automata being the set of all states the initial state and all singleton states final.</span>
<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))))</span>
        <span class="n">tbd</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="n">done</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ia</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">tbd</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">tbd</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">ia</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">done</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sy</span> <span class="ow">in</span> <span class="n">new</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Delta</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sy</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">a</span><span class="p">])</span>
                <span class="n">b</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tbd</span><span class="p">:</span>
                        <span class="n">tbd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                        <span class="n">ib</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">ib</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ib</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">ib</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="DFA.pairGraph"><a class="viewcode-back" href="../index.html#fa.DFA.pairGraph">[docs]</a>    <span class="k">def</span> <span class="nf">pairGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns pair graph</span>

<span class="sd">        :rtype: DiGraphVM</span>

<span class="sd">        .. seealso::</span>
<span class="sd">           A graph theoretic approach to automata minimality. Antonio Restivo and Roberto Vaglica. Theoretical</span>
<span class="sd">           Computer Science, 429 (2012) 282-291. doi:10.1016/j.tcs.2011.12.049 Theoretical Computer Science,</span>
<span class="sd">           2012 vol. 429 (C) pp. 282-291. http://dx.doi.org/10.1016/j.tcs.2011.12.049&quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">DiGraphVm</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertexIndex</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">s1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">s2</span><span class="p">]),</span> <span class="bp">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">sy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">sy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s2</span><span class="p">]:</span>
                        <span class="n">foo</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="n">sy</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s2</span><span class="p">][</span><span class="n">sy</span><span class="p">]]</span>
                        <span class="n">foo</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                        <span class="n">i2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertexIndex</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">True</span><span class="p">)</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span>
</div>
<div class="viewcode-block" id="DFA.subword"><a class="viewcode-back" href="../index.html#fa.DFA.subword">[docs]</a>    <span class="k">def</span> <span class="nf">subword</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Returns a dfa that recognizes subword(L(self))</span>

<span class="sd">        :rtype: dfa</span>

<span class="sd">        .. versionadded:: 1.1</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasTrapStateP</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">sigmaStarDFA</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()</span><span class="o">.</span><span class="n">subword</span><span class="p">()</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="DFA.pref"><a class="viewcode-back" href="../index.html#fa.DFA.pref">[docs]</a>    <span class="k">def</span> <span class="nf">pref</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dfa that recognizes pref(L(self))</span>

<span class="sd">        :rtype: DFA</span>

<span class="sd">        .. versionadded:: 1.1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">foo</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">foo</span><span class="o">.</span><span class="n">emptyP</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">foo</span>
        <span class="n">foo</span><span class="o">.</span><span class="n">setFinal</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">States</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">foo</span>
</div>
<div class="viewcode-block" id="DFA.suff"><a class="viewcode-back" href="../index.html#fa.DFA.suff">[docs]</a>    <span class="k">def</span> <span class="nf">suff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a dfa that recognizes suff(L(self))</span>

<span class="sd">        :rtype: DFA</span>

<span class="sd">        .. versionadded:: 0.9.8&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">ini</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usefulStates</span><span class="p">()</span>
        <span class="n">lStates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">d</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">ini</span><span class="p">))</span>
        <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ini</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">ini</span><span class="p">):</span>
            <span class="n">d</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">slist</span> <span class="o">=</span> <span class="n">lStates</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">slist</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">stl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">slist</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s1</span><span class="p">]])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stl</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">stl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lStates</span><span class="p">:</span>
                    <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                    <span class="n">foo</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">stl</span><span class="p">):</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">foo</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                <span class="n">d</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">foo</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lStates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="DFA.infix"><a class="viewcode-back" href="../index.html#fa.DFA.infix">[docs]</a>    <span class="k">def</span> <span class="nf">infix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a dfa that recognizes infix(L(a))</span>

<span class="sd">        :rtype: DFA</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span>
        <span class="n">m</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">Trap</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Trap</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">Trap</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sigmaStarDFA</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
            <span class="n">d</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
            <span class="n">ini</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">States</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">({</span><span class="n">Trap</span><span class="p">})</span>
            <span class="n">d</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">ini</span><span class="p">))</span>
            <span class="n">lStates</span> <span class="o">=</span> <span class="p">[</span><span class="n">ini</span><span class="p">]</span>
            <span class="n">d</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">slist</span> <span class="o">=</span> <span class="n">lStates</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">si</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">stateName</span><span class="p">(</span><span class="n">slist</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                    <span class="n">stl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">slist</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s1</span><span class="p">]])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">stl</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">stl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lStates</span><span class="p">:</span>
                        <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                        <span class="n">foo</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">stl</span> <span class="o">!=</span> <span class="p">{</span><span class="n">Trap</span><span class="p">}:</span>
                            <span class="n">d</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">foo</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">stateName</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">foo</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lStates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="DFA.hasTrapStateP"><a class="viewcode-back" href="../index.html#fa.DFA.hasTrapStateP">[docs]</a>    <span class="k">def</span> <span class="nf">hasTrapStateP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Tests if the automaton has a dead trap state</span>

<span class="sd">        :rtype: bool</span>

<span class="sd">        .. versionadded:: 1.1&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">foo</span><span class="o">.</span><span class="n">completeP</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">foo</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">foo</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">foo</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
    <span class="k">def</span> <span class="nf">_xA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the minimal words that reach each state of DFA</span>

<span class="sd">        :rtype: dictionary with words&quot;&quot;&quot;</span>
        <span class="n">xList</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rank</span><span class="p">:</span>
            <span class="n">xList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Epsilon</span>
            <span class="n">todo</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">todo</span><span class="p">:</span>
            <span class="n">nrank</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rank</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="ow">and</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sym</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
                                    <span class="n">xList</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">sConcat</span><span class="p">(</span><span class="n">xList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sym</span><span class="p">)</span>
                                    <span class="n">todo</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                                    <span class="n">nrank</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">q</span> <span class="o">=</span> <span class="n">ss</span>
                            <span class="k">if</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
                                <span class="n">xList</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">sConcat</span><span class="p">(</span><span class="n">xList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sym</span><span class="p">)</span>
                                <span class="n">todo</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                                <span class="n">nrank</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">nrank</span>
        <span class="k">return</span> <span class="n">xList</span>

<div class="viewcode-block" id="DFA.sop"><a class="viewcode-back" href="../index.html#fa.DFA.sop">[docs]</a>    <span class="k">def</span> <span class="nf">sop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Strange operation</span>

<span class="sd">        :param other: the other automaton</span>
<span class="sd">        :type other: DFA</span>
<span class="sd">        :rtype: DFA</span>

<span class="sd">        .. versionadded:: 1.2b2&quot;&quot;&quot;</span>

        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">completeP</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">completeP</span><span class="p">()</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAnotComplete</span><span class="p">()</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">NFA</span><span class="p">()</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">addState</span><span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">aux</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">aux</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">pool</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="n">_initPool</span><span class="p">()</span>
        <span class="n">_addPool</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">nt</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">c</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">_addPool</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">aux</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">nt</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">c</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">_addPool</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">aux</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nt</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">c</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">_addPool</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">aux</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">aux</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">aux</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">pool</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="n">_initPool</span><span class="p">()</span>
        <span class="n">_addPool</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">aux</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">dest</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                    <span class="n">foo</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">aux</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">aux</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">set</span><span class="p">()):</span>
                        <span class="n">dest</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">aux</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                <span class="n">_addPool</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">new</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
            <span class="n">final</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">final</span> <span class="o">=</span> <span class="n">final</span> <span class="ow">and</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">Final</span> <span class="ow">or</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">final</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="DFA.dist"><a class="viewcode-back" href="../index.html#fa.DFA.dist">[docs]</a>    <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the distinguishability language for a DFA</span>

<span class="sd">        :rtype: DFA</span>

<span class="sd">        .. seealso::</span>
<span class="sd">           Cezar Câmpeanu, Nelma Moreira, Rogério Reis:</span>
<span class="sd">           The distinguishability operation on regular languages. NCMA 2014: 85-100</span>

<span class="sd">        .. versionadded:: 0.9.8&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">completeP</span><span class="p">():</span>
            <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
            <span class="n">foo</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">d</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">ini</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">States</span><span class="p">)))</span>
        <span class="n">lStates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">d</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">ini</span><span class="p">))</span>
        <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ini</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">foo</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">ini</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ini</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
            <span class="n">d</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">slist</span> <span class="o">=</span> <span class="n">lStates</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">slist</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">foo</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">stl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">foo</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">slist</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">foo</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s1</span><span class="p">]])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stl</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">stl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lStates</span><span class="p">:</span>
                    <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">foo</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stl</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                <span class="n">d</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lStates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="DFA.distMin"><a class="viewcode-back" href="../index.html#fa.DFA.distMin">[docs]</a>    <span class="k">def</span> <span class="nf">distMin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Evaluates the list of minimal words that distinguish each pair of states</span>

<span class="sd">        :returns: set of minimal distinguishing words</span>
<span class="sd">        :rtype: FL</span>

<span class="sd">        .. versionadded:: 0.9.8</span>

<span class="sd">        .. attention::</span>
<span class="sd">            If the DFA is not minimal, the method loops forever&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">fl</span>

        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fl</span><span class="o">.</span><span class="n">FL</span><span class="p">()</span>
        <span class="n">distList</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sz</span><span class="p">)]</span>
        <span class="n">wrds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">words</span><span class="p">()</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
                <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">distList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Epsilon</span><span class="p">)</span>
        <span class="n">delFromList</span><span class="p">(</span><span class="n">todo</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wrds</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalWordP</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">^</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalWordP</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                        <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                        <span class="n">distList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="n">delFromList</span><span class="p">(</span><span class="n">todo</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">todo</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">fl</span><span class="o">.</span><span class="n">FL</span><span class="p">(</span><span class="n">distList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DFA.distR"><a class="viewcode-back" href="../index.html#fa.DFA.distR">[docs]</a>    <span class="k">def</span> <span class="nf">distR</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the right distinguishability language for a DFA</span>

<span class="sd">        :rtype: DFA</span>

<span class="sd">        ..seealso:: Cezar Câmpeanu, Nelma Moreira, Rogério Reis:</span>
<span class="sd">           The distinguishability operation on regular languages. NCMA 2014: 85-100&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span>
        <span class="n">foo</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">foo</span><span class="o">.</span><span class="n">delFinals</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">foo</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">foo</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">foo</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">foo</span>
</div>
<div class="viewcode-block" id="DFA.distTS"><a class="viewcode-back" href="../index.html#fa.DFA.distTS">[docs]</a>    <span class="k">def</span> <span class="nf">distTS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the two-sided distinguishability language for a DFA</span>

<span class="sd">        :rtype: DFA</span>

<span class="sd">        ..seealso:: Cezar Câmpeanu, Nelma Moreira, Rogério Reis:</span>
<span class="sd">           The distinguishability operation on regular languages. NCMA 2014: 85-100&quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span>
        <span class="n">m</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">Trap</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Trap</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Trap</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([])</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">Trap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sigmaStarDFA</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
            <span class="n">d</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
            <span class="n">ini</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">States</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">Trap</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">ini</span><span class="p">))</span>
            <span class="n">lStates</span> <span class="o">=</span> <span class="p">[</span><span class="n">ini</span><span class="p">]</span>
            <span class="n">d</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">slist</span> <span class="o">=</span> <span class="n">lStates</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">si</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">stateName</span><span class="p">(</span><span class="n">slist</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                    <span class="n">stl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">slist</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s1</span><span class="p">]])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">stl</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">stl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lStates</span><span class="p">:</span>
                        <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                        <span class="n">foo</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">stl</span> <span class="o">!=</span> <span class="n">Trap</span><span class="p">:</span>
                            <span class="n">d</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">foo</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">stateName</span><span class="p">(</span><span class="n">stl</span><span class="p">)</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">foo</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lStates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="DFA.distRMin"><a class="viewcode-back" href="../index.html#fa.DFA.distRMin">[docs]</a>    <span class="k">def</span> <span class="nf">distRMin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute distRMin for DFA</span>

<span class="sd">        :rtype FL</span>

<span class="sd">        ..seealso:: Cezar Câmpeanu, Nelma Moreira, Rogério Reis:</span>
<span class="sd">           The distinguishability operation on regular languages. NCMA 2014: 85-100&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_epstr</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&#39;&#39;</span>
            <span class="k">return</span> <span class="n">d</span>

        <span class="k">def</span> <span class="nf">_strep</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Epsilon</span>
            <span class="k">return</span> <span class="n">d</span>

        <span class="kn">import</span> <span class="nn">fl</span>

        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span>
        <span class="n">rev</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">reversal</span><span class="p">()</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span>
        <span class="n">rev</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rev</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fl</span><span class="o">.</span><span class="n">FL</span><span class="p">()</span>
        <span class="n">dpreList</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">xlist</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">_xA</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xlist</span><span class="p">:</span>
            <span class="n">xlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_epstr</span><span class="p">(</span><span class="n">xlist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sz</span><span class="p">)]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">rev</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">rev</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">s1</span> <span class="o">==</span> <span class="n">DeadName</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s2</span> <span class="o">!=</span> <span class="n">DeadName</span><span class="p">:</span>
                    <span class="n">md</span> <span class="o">=</span> <span class="nb">min</span><span class="p">({</span><span class="n">xlist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">s2</span><span class="p">})</span>
                    <span class="n">dpreList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">s2</span> <span class="o">==</span> <span class="n">DeadName</span><span class="p">:</span>
                <span class="n">md</span> <span class="o">=</span> <span class="nb">min</span><span class="p">({</span><span class="n">xlist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">s1</span><span class="p">})</span>
                <span class="n">dpreList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d12</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">^</span> <span class="n">s2</span>
                <span class="n">md</span> <span class="o">=</span> <span class="nb">min</span><span class="p">({</span><span class="n">xlist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d12</span><span class="p">})</span>
                <span class="n">dpreList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
            <span class="n">todo</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">fl</span><span class="o">.</span><span class="n">FL</span><span class="p">({</span><span class="n">_strep</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dpreList</span><span class="p">},</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DFA.completeProduct"><a class="viewcode-back" href="../index.html#fa.DFA.completeProduct">[docs]</a>    <span class="k">def</span> <span class="nf">completeProduct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Product structure</span>

<span class="sd">        :param other: the other DFA&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">SemiDFA</span><span class="p">()</span>
        <span class="n">n</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">])</span>
        <span class="n">n</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                    <span class="n">n</span><span class="o">.</span><span class="n">delta</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">n</span><span class="o">.</span><span class="n">delta</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">s</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">s</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">n</span>
</div>
<div class="viewcode-block" id="DFA.syncWords"><a class="viewcode-back" href="../index.html#fa.DFA.syncWords">[docs]</a>    <span class="k">def</span> <span class="nf">syncWords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the regular expression corresponding to the synchronizing pwords of the automata.</span>

<span class="sd">        :return: a regular expression of the sync words of the automata</span>
<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">syncPower</span><span class="p">()</span><span class="o">.</span><span class="n">reCG</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="DFA.evalWordP"><a class="viewcode-back" href="../index.html#fa.DFA.evalWordP">[docs]</a>    <span class="k">def</span> <span class="nf">evalWordP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verifies if the DFA recognises a given word</span>

<span class="sd">        :param word: word to be recognised</span>
<span class="sd">        :type word: list of symbols.</span>
<span class="sd">        :param initial: starting state index</span>
<span class="sd">        :type initial: int</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">initial</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">DFAstopped</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="DFA.evalSymbol"><a class="viewcode-back" href="../index.html#fa.DFA.evalSymbol">[docs]</a>    <span class="k">def</span> <span class="nf">evalSymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">sym</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the  state reached from given state through a given symbol.</span>

<span class="sd">        :param init: set of current states indexes</span>
<span class="sd">        :type init: set or list of int</span>
<span class="sd">        :param sym: symbol to be consumed</span>
<span class="sd">        :type sym: str</span>
<span class="sd">        :returns: reached state</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        :raises DFAsymbolUnknown: if symbol not in alphabet</span>
<span class="sd">        :raises DFAstopped: if transition function is not defined for the given input&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAsymbolUnknown</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">Next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">init</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAstopped</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAstopped</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Next</span>
</div>
<div class="viewcode-block" id="DFA.evalSymbolL"><a class="viewcode-back" href="../index.html#fa.DFA.evalSymbolL">[docs]</a>    <span class="k">def</span> <span class="nf">evalSymbolL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls</span><span class="p">,</span> <span class="n">sym</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the set of states reached from a given set of states through a given symbol</span>

<span class="sd">        :param ls: set of states indexes</span>
<span class="sd">        :type ls: set of int</span>
<span class="sd">        :param sym: symbol to be read</span>
<span class="sd">        :type sym: str</span>
<span class="sd">        :returns: set of reached states</span>
<span class="sd">        :rtype: set of int&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="DFA.reverseTransitions"><a class="viewcode-back" href="../index.html#fa.DFA.reverseTransitions">[docs]</a>    <span class="k">def</span> <span class="nf">reverseTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rev</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate reverse transition function.</span>

<span class="sd">        :param rev: DFA in which the reverse function will be stored</span>
<span class="sd">        :type rev: DFA&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">rev</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">a</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DFA.initialComp"><a class="viewcode-back" href="../index.html#fa.DFA.initialComp">[docs]</a>    <span class="k">def</span> <span class="nf">initialComp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the connected component starting at the initial state.</span>

<span class="sd">        :returns: list of state indexes in the component</span>
<span class="sd">        :rtype: list of int&quot;&quot;&quot;</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">c</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                    <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">lst</span>
</div>
<div class="viewcode-block" id="DFA.minimal"><a class="viewcode-back" href="../index.html#fa.DFA.minimal">[docs]</a>    <span class="k">def</span> <span class="nf">minimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;minimalHopcroft&quot;</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the equivalent minimal complete DFA</span>

<span class="sd">        :param method: method to use in the minimization</span>
<span class="sd">        :param complete: should the result be completed?</span>
<span class="sd">        :type complete: bool</span>
<span class="sd">        :returns: equivalent minimal DFA</span>
<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">complete</span><span class="p">:</span>
            <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="n">method</span><span class="p">)()</span>
            <span class="n">foo</span><span class="o">.</span><span class="n">completeMinimal</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">foo</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="n">method</span><span class="p">)()</span>
</div>
<div class="viewcode-block" id="DFA.minimalP"><a class="viewcode-back" href="../index.html#fa.DFA.minimalP">[docs]</a>    <span class="k">def</span> <span class="nf">minimalP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;minimalHopcroft&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if the DFA is minimal</span>

<span class="sd">        :param method: the minimization algorithm to be used</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        ..note: if DFA non complete test if  complete minimal has   one more state</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">completeP</span><span class="p">():</span>
            <span class="n">foo</span><span class="o">.</span><span class="n">completeMinimal</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">foo</span><span class="o">.</span><span class="n">completeP</span><span class="p">():</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DFA.minimalMoore"><a class="viewcode-back" href="../index.html#fa.DFA.minimalMoore">[docs]</a>    <span class="k">def</span> <span class="nf">minimalMoore</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the equivalent minimal automata with Moore&#39;s algorithm</span>

<span class="sd">        .. seealso::</span>
<span class="sd">           John E. Hopcroft and Jeffrey D. Ullman, Introduction to Automata Theory, Languages, and Computation, AW,</span>
<span class="sd">           1979</span>

<span class="sd">        :returns: minimal complete DFA</span>
<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="n">trashIdx</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># just to satisfy the checker</span>
        <span class="n">scc</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initialComp</span><span class="p">())</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="o">&amp;</span> <span class="n">scc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
            <span class="n">new</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new</span>
        <span class="n">equiv</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">scc</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">scc</span><span class="p">]:</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)):</span>
                    <span class="n">equiv</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">completeP</span><span class="p">():</span>
            <span class="n">Complete</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))</span>
                      <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">scc</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)]:</span>
                <span class="n">equiv</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="bp">None</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Complete</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">stable</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">stable</span><span class="p">:</span>
            <span class="n">stable</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">equiv</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">xi</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                    <span class="n">xj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">_sortWithNone</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">xj</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">xi</span> <span class="o">!=</span> <span class="n">xj</span> <span class="ow">and</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">equiv</span><span class="p">:</span>
                        <span class="n">stable</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="n">equiv</span> <span class="o">=</span> <span class="n">equiv</span> <span class="o">-</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)}</span>
                        <span class="k">break</span>
        <span class="n">nStatEquiv</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nNames</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">equiv</span><span class="p">)</span>
        <span class="n">foo</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">_cmpPair2</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">_deref</span><span class="p">(</span><span class="n">nStatEquiv</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">nStatEquiv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">nNames</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">nNames</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="n">nStatEquiv</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">]:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Complete</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                    <span class="n">xi</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
                    <span class="n">xj</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nStatEquiv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">xj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">:</span>
                <span class="n">trashIdx</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">trashIdx</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">trashIdx</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">]:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                    <span class="c"># noinspection PyNoneFunctionAssignment</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">xj</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nStatEquiv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                        <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">xj</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">trashIdx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nStatEquiv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">nStatEquiv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">))</span>
        <span class="n">new</span><span class="o">.</span><span class="n">renameStates</span><span class="p">([</span><span class="n">nNames</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="s">&quot;Dead&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="DFA.minimalNCompleteP"><a class="viewcode-back" href="../index.html#fa.DFA.minimalNCompleteP">[docs]</a>    <span class="k">def</span> <span class="nf">minimalNCompleteP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if a non necessarely complete DFA is minimal, i.e., if the DFA is non complete,</span>
<span class="sd">        if the minimal complete has only one more state.</span>

<span class="sd">        :returns: True if not minimal</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        .. attention::</span>
<span class="sd">            obsolete: use minimalP&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span>
        <span class="n">foo</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">completeP</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DFA.completeMinimal"><a class="viewcode-back" href="../index.html#fa.DFA.completeMinimal">[docs]</a>    <span class="k">def</span> <span class="nf">completeMinimal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Completes a DFA assuming it is a minimal and avoiding de destruction of its minimality If the automaton is</span>
<span class="sd">        not complete, all the non final states are checked to see if tey are not already a dead state. Only in the</span>
<span class="sd">        negative case a new (dead) state is added to the automaton.</span>

<span class="sd">        :rtype: DFA</span>

<span class="sd">        .. attention::</span>
<span class="sd">           The object is modified in place. If the alphabet is empty nothing is done&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="n">deadS</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">complete</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="n">complete</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                    <span class="n">deadS</span> <span class="o">=</span> <span class="n">s</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                        <span class="n">complete</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                            <span class="n">foo</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span> <span class="ow">or</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                            <span class="n">foo</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="n">foo</span><span class="p">:</span>
                    <span class="n">deadS</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">complete</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">deadS</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">deadS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;dead&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="ow">or</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">deadS</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="DFA.minimalMooreSq"><a class="viewcode-back" href="../index.html#fa.DFA.minimalMooreSq">[docs]</a>    <span class="k">def</span> <span class="nf">minimalMooreSq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the equivalent minimal complete DFA using Moore&#39;s (quadratic) algorithm</span>

<span class="sd">        .. seealso::</span>
<span class="sd">           John E. Hopcroft and Jeffrey D. Ullman, Introduction to Automata Theory, Languages, and Computation, AW,</span>
<span class="sd">           1979</span>

<span class="sd">        :returns: equivalent minimal DFA</span>
<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="n">duped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">n_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">duped</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">_mooreMarked</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">_moorePairList</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
                <span class="n">duped</span><span class="o">.</span><span class="n">_moorePairList</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">duped</span><span class="o">.</span><span class="n">_mooreMarked</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">q</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
                    <span class="n">duped</span><span class="o">.</span><span class="n">_mooreMarked</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">p</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">q</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">Final</span><span class="p">)):</span>
                    <span class="n">exists_marked</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                        <span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="n">duped</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">a</span><span class="p">],</span> <span class="n">duped</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">a</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">duped</span><span class="o">.</span><span class="n">_mooreMarked</span><span class="p">[</span><span class="n">foo</span><span class="p">]:</span>
                            <span class="n">exists_marked</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">exists_marked</span><span class="p">:</span>
                        <span class="n">duped</span><span class="o">.</span><span class="n">_mooreMarked</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="n">duped</span><span class="o">.</span><span class="n">_mooreMarkList</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">duped</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">!=</span> <span class="n">duped</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">a</span><span class="p">]:</span>
                                <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">duped</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">a</span><span class="p">],</span> <span class="n">duped</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">a</span><span class="p">])</span>
                                <span class="n">duped</span><span class="o">.</span><span class="n">_moorePairList</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
        <span class="n">eqstates</span> <span class="o">=</span> <span class="n">duped</span><span class="o">.</span><span class="n">_mooreEquivClasses</span><span class="p">()</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">joinStates</span><span class="p">(</span><span class="n">eqstates</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">duped</span>
</div>
<div class="viewcode-block" id="DFA.minimalMooreSqP"><a class="viewcode-back" href="../index.html#fa.DFA.minimalMooreSqP">[docs]</a>    <span class="k">def</span> <span class="nf">minimalMooreSqP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if a DFA is minimal using the quadratic version of Moore&#39;s algorithm</span>

<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimalMooreSq</span><span class="p">()</span>
        <span class="n">foo</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniqueRepr</span><span class="p">()</span> <span class="o">==</span> <span class="n">foo</span><span class="o">.</span><span class="n">uniqueRepr</span><span class="p">()</span>

    <span class="c"># noinspection PyUnresolvedReferences</span></div>
    <span class="k">def</span> <span class="nf">_mooreMarkList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Marks pairs of states already known to be not non-equivalent</span>

<span class="sd">        :param p:</span>
<span class="sd">        :param q:&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">p_</span><span class="p">,</span> <span class="n">q_</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moorePairList</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mooreMarked</span><span class="p">[(</span><span class="n">p_</span><span class="p">,</span> <span class="n">q_</span><span class="p">)]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mooreMarked</span><span class="p">[(</span><span class="n">p_</span><span class="p">,</span> <span class="n">q_</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mooreMarkList</span><span class="p">(</span><span class="n">p_</span><span class="p">,</span> <span class="n">q_</span><span class="p">)</span>

    <span class="c"># noinspection PyUnresolvedReferences</span>
    <span class="k">def</span> <span class="nf">_mooreEquivClasses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns equivalence classes</span>

<span class="sd">        :returns: list of equivalence classes</span>
<span class="sd">        :rtype:list&quot;&quot;&quot;</span>
        <span class="n">uf</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">auto_create</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c"># eqstates = []</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mooreMarked</span><span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)]:</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="n">uf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="n">B</span> <span class="o">=</span> <span class="n">uf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                    <span class="n">uf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="n">classes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">lider</span> <span class="o">=</span> <span class="n">uf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lider</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
                <span class="n">classes</span><span class="p">[</span><span class="n">lider</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">classes</span><span class="p">[</span><span class="n">lider</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">classes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_compute_delta_inv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a delta_inv feature. Used by minimalHopcroft.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_inv</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta_inv</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">to</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">to</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta_inv</span><span class="p">[</span><span class="n">s2</span><span class="p">][</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_undelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Traverses Automata backwards</span>

<span class="sd">        :param states: destination</span>
<span class="sd">        :param x: symbol</span>
<span class="sd">        :return: list of states&quot;&quot;&quot;</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="n">lst</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_inv</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">lst</span>

    <span class="c"># noinspection PyUnresolvedReferences</span>
    <span class="k">def</span> <span class="nf">_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split classes in Hopcroft algorithm</span>

<span class="sd">        :param B:</span>
<span class="sd">        :param C:</span>
<span class="sd">        :param a:</span>
<span class="sd">        :return:&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_undelta</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
        <span class="n">bar</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">-</span> <span class="n">foo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">B</span> <span class="o">&amp;</span> <span class="n">foo</span><span class="p">,</span> <span class="n">B</span> <span class="o">&amp;</span> <span class="n">bar</span>

<div class="viewcode-block" id="DFA.minimalHopcroft"><a class="viewcode-back" href="../index.html#fa.DFA.minimalHopcroft">[docs]</a>    <span class="k">def</span> <span class="nf">minimalHopcroft</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the equivalent minimal complete DFA using Hopcroft algorithm</span>

<span class="sd">        :returns: equivalent minimal DFA</span>
<span class="sd">        :rtype: DFA</span>

<span class="sd">        .. seealso::</span>
<span class="sd">           John Hopcroft,An n\log{n} algorithm for minimizing states in a  finite automaton.The Theory of Machines</span>
<span class="sd">           and Computations.AP. 1971&quot;&quot;&quot;</span>
        <span class="n">duped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">_compute_delta_inv</span><span class="p">()</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">duped</span><span class="o">.</span><span class="n">States</span><span class="p">)))</span>
        <span class="n">final</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">duped</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
        <span class="n">not_final</span> <span class="o">=</span> <span class="n">duped</span><span class="o">.</span><span class="n">states</span> <span class="o">-</span> <span class="n">final</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_final</span><span class="p">):</span>
            <span class="n">P</span> <span class="o">=</span> <span class="p">{</span><span class="n">not_final</span><span class="p">,</span> <span class="n">final</span><span class="p">}</span>
            <span class="n">L</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">final</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="p">{</span><span class="n">final</span><span class="p">,</span> <span class="n">not_final</span><span class="p">}</span>
            <span class="n">L</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">not_final</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">)</span> <span class="o">=</span> <span class="n">duped</span><span class="o">.</span><span class="n">_split</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="n">P</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">B1</span><span class="p">:</span>
                        <span class="n">P</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">B1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">B2</span><span class="p">:</span>
                        <span class="n">P</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">B2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">B1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">B2</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">B1</span><span class="p">:</span>
                            <span class="n">L</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">B1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">B2</span><span class="p">:</span>
                            <span class="n">L</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">B2</span><span class="p">)</span>
        <span class="n">eqstates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">eqstates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">joinStates</span><span class="p">(</span><span class="n">eqstates</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">duped</span>
</div>
<div class="viewcode-block" id="DFA.minimalHopcroftP"><a class="viewcode-back" href="../index.html#fa.DFA.minimalHopcroftP">[docs]</a>    <span class="k">def</span> <span class="nf">minimalHopcroftP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if a DFA is minimal</span>

<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimalHopcroft</span><span class="p">()</span>
        <span class="n">foo</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">uniqueRepr</span><span class="p">()</span> <span class="o">==</span> <span class="n">foo</span><span class="o">.</span><span class="n">uniqueRepr</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="DFA.minimalNotEquivP"><a class="viewcode-back" href="../index.html#fa.DFA.minimalNotEquivP">[docs]</a>    <span class="k">def</span> <span class="nf">minimalNotEquivP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if the DFA is minimal by computing the set of distinguishable (not equivalent) pairs of states</span>

<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="n">all_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
                <span class="n">all_pairs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="n">not_final</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span>
        <span class="n">neq</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">not_final</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">pair</span> <span class="o">=</span> <span class="n">_normalizePair</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">neq</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">neq</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_delta_inv</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">source</span><span class="p">:</span>
            <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">p_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_inv</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">a</span><span class="p">]</span>
                <span class="n">q_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_inv</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">a</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p_</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">q_</span><span class="p">:</span>
                        <span class="n">pair</span> <span class="o">=</span> <span class="n">_normalizePair</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neq</span><span class="p">:</span>
                            <span class="n">neq</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
                            <span class="n">source</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
        <span class="n">equiv</span> <span class="o">=</span> <span class="n">all_pairs</span> <span class="o">-</span> <span class="n">neq</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">equiv</span>
</div>
<div class="viewcode-block" id="DFA.minimalHKP"><a class="viewcode-back" href="../index.html#fa.DFA.minimalHKP">[docs]</a>    <span class="k">def</span> <span class="nf">minimalHKP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests the DFA&#39;s minimality using Hopcroft and Karp&#39;s state equivalence algorithm</span>

<span class="sd">        :returns: bool</span>

<span class="sd">        .. seealso::</span>
<span class="sd">           J. E. Hopcroft and R. M. Karp.A Linear Algorithm for Testing Equivalence of Finite Automata.TR 71--114. U.</span>
<span class="sd">           California. 1971</span>

<span class="sd">        .. attention::</span>
<span class="sd">           The automaton must be complete.&quot;&quot;&quot;</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
                <span class="n">pairs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="n">equiv</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">q0</span><span class="p">)</span> <span class="o">=</span> <span class="n">pairs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">sets</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">auto_create</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">sets</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">q0</span><span class="p">)</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p0</span><span class="p">,</span> <span class="n">q0</span><span class="p">)]</span>
            <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
                <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
                    <span class="n">equiv</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">break</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                    <span class="n">r1</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">a</span><span class="p">])</span>
                    <span class="n">r2</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">a</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">r1</span> <span class="o">!=</span> <span class="n">r2</span><span class="p">:</span>
                        <span class="n">sets</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">equiv</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="DFA.minimalIncremental"><a class="viewcode-back" href="../index.html#fa.DFA.minimalIncremental">[docs]</a>    <span class="k">def</span> <span class="nf">minimalIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimal_test</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Minimizes the DFA with an incremental method using the Union-Find algorithm and memoized non-equivalence</span>
<span class="sd">        intermediate results</span>

<span class="sd">        :param minimal_test: starts by verifying that the automaton is not minimal?</span>
<span class="sd">        :type minimal_test: bool</span>
<span class="sd">        :returns: equivalent minimal DFA</span>
<span class="sd">        :rtype: DFA</span>

<span class="sd">        .. seealso::</span>
<span class="sd">           M. Almeida and N. Moreira and and R. Reis.Incremental DFA minimisation. CIAA 2010. LNCS 6482. pp 39-48. 2010&quot;&quot;&quot;</span>
        <span class="n">duped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">minimalIncr_neq</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">n_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">duped</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">q</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                    <span class="n">duped</span><span class="o">.</span><span class="n">minimalIncr_neq</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_normalizePair</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">minimalIncr_uf</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">auto_create</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_states</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">minimalIncr_neq</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">duped</span><span class="o">.</span><span class="n">minimalIncr_uf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">duped</span><span class="o">.</span><span class="n">minimalIncr_uf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">duped</span><span class="o">.</span><span class="n">equiv</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">duped</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">duped</span><span class="o">.</span><span class="n">_minimalIncrCheckEquiv</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
                    <span class="c"># when we are only interested in testing</span>
                    <span class="c"># minimality, return None to signal a pair of</span>
                    <span class="c"># equivalent states</span>
                    <span class="k">if</span> <span class="n">minimal_test</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">None</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">equiv</span><span class="p">:</span>
                        <span class="n">duped</span><span class="o">.</span><span class="n">minimalIncr_uf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">duped</span><span class="o">.</span><span class="n">minimalIncr_neq</span> <span class="o">|=</span> <span class="n">duped</span><span class="o">.</span><span class="n">path</span>
        <span class="n">classes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="n">lider</span> <span class="o">=</span> <span class="n">duped</span><span class="o">.</span><span class="n">minimalIncr_uf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lider</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
                <span class="n">classes</span><span class="p">[</span><span class="n">lider</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">classes</span><span class="p">[</span><span class="n">lider</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">joinStates</span><span class="p">(</span><span class="n">classes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">duped</span>

    <span class="c"># noinspection PyUnresolvedReferences</span></div>
    <span class="k">def</span> <span class="nf">_minimalIncrCheckEquiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">rec_level</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c"># p == q is a useless test; union-find offers this for free</span>
        <span class="c"># because p == q =&gt; find(p) == find(q) and the recursive call</span>
        <span class="c"># only happens when find(p) != find(q)</span>

        <span class="c"># if p_ in self.Final ^ q_ in self.Final =&gt; (p_,</span>
        <span class="c"># q_) are already on self.minimalIncr_neq</span>
        <span class="c"># (initialization)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimalIncr_neq</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
            <span class="c"># cycle detected; the states must be equivalent</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="p">(</span><span class="n">p_</span><span class="p">,</span> <span class="n">q_</span><span class="p">)</span> <span class="o">=</span> <span class="n">_normalizePair</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimalIncr_uf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">a</span><span class="p">]),</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">minimalIncr_uf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">a</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">p_</span> <span class="o">!=</span> <span class="n">q_</span> <span class="ow">and</span> <span class="p">((</span><span class="n">p_</span><span class="p">,</span> <span class="n">q_</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">equiv</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">equiv</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">p_</span><span class="p">,</span> <span class="n">q_</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minimalIncrCheckEquiv</span><span class="p">(</span><span class="n">p_</span><span class="p">,</span> <span class="n">q_</span><span class="p">,</span> <span class="n">rec_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># if the states are equivalent, the &#39;path&#39; doesn&#39;t</span>
                    <span class="c"># really interest; by removing the states here, we</span>
                    <span class="c"># can make &#39;path&#39; a global variable and avoid any</span>
                    <span class="c"># copy() operations. removing the last inserted</span>
                    <span class="c"># item is necessary when the states are equivalent</span>
                    <span class="c"># because the next recursive call (next symbol)</span>
                    <span class="c"># needs an &quot;empty path&quot;, ie, the states reached by</span>
                    <span class="c"># the previous symbol cannot be considered</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">discard</span><span class="p">((</span><span class="n">p_</span><span class="p">,</span> <span class="n">q_</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equiv</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">True</span>

<div class="viewcode-block" id="DFA.minimalIncrementalP"><a class="viewcode-back" href="../index.html#fa.DFA.minimalIncrementalP">[docs]</a>    <span class="k">def</span> <span class="nf">minimalIncrementalP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if a DFA is minimal</span>

<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimalIncremental</span><span class="p">(</span><span class="n">minimal_test</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">foo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="DFA.minimalWatson"><a class="viewcode-back" href="../index.html#fa.DFA.minimalWatson">[docs]</a>    <span class="k">def</span> <span class="nf">minimalWatson</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_only</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the equivalent minimal complete DFA using Waton&#39;s incremental algorithm</span>

<span class="sd">        :param test_only: is it only to test minimality</span>
<span class="sd">        :type test_only: bool</span>
<span class="sd">        :returns: equivalent minimal DFA</span>
<span class="sd">        :rtype: DFA</span>

<span class="sd">        :raises  DFAnotComplete: if automaton is not complete</span>

<span class="sd">        ..attention::</span>
<span class="sd">          automaton must be complete&quot;&quot;&quot;</span>
        <span class="n">duped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">Equiv</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">auto_create</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">Dist</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">nstates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="n">max_depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nstates</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nstates</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nstates</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">duped</span><span class="o">.</span><span class="n">Equiv</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">duped</span><span class="o">.</span><span class="n">Equiv</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">Dist</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">duped</span><span class="o">.</span><span class="n">minimalWatson_stack</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
                <span class="k">if</span> <span class="n">duped</span><span class="o">.</span><span class="n">_watson_equivP</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">):</span>
                    <span class="c"># when we are only interested in testing</span>
                    <span class="c"># minimality, return None to signal a pair of</span>
                    <span class="c"># equivalent states</span>
                    <span class="k">if</span> <span class="n">test_only</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">None</span>
                    <span class="n">duped</span><span class="o">.</span><span class="n">Equiv</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">duped</span><span class="o">.</span><span class="n">Dist</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
        <span class="n">classes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">duped</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
            <span class="n">lider</span> <span class="o">=</span> <span class="n">duped</span><span class="o">.</span><span class="n">Equiv</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lider</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
                <span class="n">classes</span><span class="p">[</span><span class="n">lider</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">classes</span><span class="p">[</span><span class="n">lider</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="n">duped</span><span class="o">.</span><span class="n">joinStates</span><span class="p">(</span><span class="n">classes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">duped</span>

    <span class="c"># noinspection PyUnresolvedReferences</span></div>
    <span class="k">def</span> <span class="nf">_watson_equivP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">((</span><span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">))</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimalWatson_stack</span><span class="p">:</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">((</span><span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minimalWatson_stack</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">eq</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">eq</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_watson_equivP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">a</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">a</span><span class="p">],</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">DFAnotComplete</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minimalWatson_stack</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">eq</span>

<div class="viewcode-block" id="DFA.minimalWatsonP"><a class="viewcode-back" href="../index.html#fa.DFA.minimalWatsonP">[docs]</a>    <span class="k">def</span> <span class="nf">minimalWatsonP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if a DFA is minimal using Watson&#39;s incremental algorithm</span>

<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimalWatson</span><span class="p">(</span><span class="n">test_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">foo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="DFA.markNonEquivalent"><a class="viewcode-back" href="../index.html#fa.DFA.markNonEquivalent">[docs]</a>    <span class="k">def</span> <span class="nf">markNonEquivalent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mark states with indexes s1 and s2 in given map as non equivalent states. If any back-effects exist,</span>
<span class="sd">        apply them.</span>

<span class="sd">        :param s1: one state&#39;s index</span>
<span class="sd">        :type s1: int</span>
<span class="sd">        :param s2: the other state&#39;s index</span>
<span class="sd">        :type s2: int</span>
<span class="sd">        :param data: the matrix relating s1 and s2&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s2</span><span class="p">)])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">backEffects</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">s2</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">backEffects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">sb1</span><span class="p">,</span> <span class="n">sb2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">backEffects</span><span class="p">:</span>
            <span class="k">del</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">s2</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">s2</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">sb1</span><span class="p">,</span> <span class="n">sb2</span><span class="p">))])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">markNonEquivalent</span><span class="p">(</span><span class="n">sb1</span><span class="p">,</span> <span class="n">sb2</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DFA.print_data"><a class="viewcode-back" href="../index.html#fa.DFA.print_data">[docs]</a>    <span class="k">def</span> <span class="nf">print_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prints table of compatibility (in the context of the minimalization algorithm).</span>

<span class="sd">        :param data: data to print&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                    <span class="k">print</span> <span class="s">&quot;_ &quot;</span><span class="p">,</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;X &quot;</span><span class="p">,</span>
            <span class="k">print</span> <span class="n">s</span>
</div>
<div class="viewcode-block" id="DFA.joinStates"><a class="viewcode-back" href="../index.html#fa.DFA.joinStates">[docs]</a>    <span class="k">def</span> <span class="nf">joinStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lst</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge a list of states.</span>

<span class="sd">        :param lst: set of equivalent states</span>
<span class="sd">        :type lst: iterable of state indexes.&quot;&quot;&quot;</span>
        <span class="n">lst</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">subst</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
            <span class="n">sl</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">in</span> <span class="n">sl</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">sl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sl</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">subst</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="ow">in</span> <span class="n">subst</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">subst</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sl</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">subst</span><span class="p">[</span><span class="n">s</span><span class="p">]]:</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="ow">in</span> <span class="n">subst</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">subst</span><span class="p">[</span><span class="n">s</span><span class="p">]][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">subst</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">subst</span><span class="p">[</span><span class="n">s</span><span class="p">]][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
                    <span class="k">del</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="DFA.compat"><a class="viewcode-back" href="../index.html#fa.DFA.compat">[docs]</a>    <span class="k">def</span> <span class="nf">compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests compatibility between two states.</span>

<span class="sd">        :param data:</span>
<span class="sd">        :param s1: state index</span>
<span class="sd">        :type s1: int</span>
<span class="sd">        :param s2: state index</span>
<span class="sd">        :type s2: int</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">s1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">s2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">s2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="o">!=</span> <span class="n">s2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="k">del</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s2</span><span class="p">)])</span>
            <span class="k">del</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">s2</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s1</span><span class="p">)])</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="n">next1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>
            <span class="n">next2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s2</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">next1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">next2</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">next2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">next1</span><span class="p">]):</span>
                <span class="k">del</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s2</span><span class="p">)])</span>
                <span class="k">del</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">s2</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s1</span><span class="p">)])</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="DFA.dup"><a class="viewcode-back" href="../index.html#fa.DFA.dup">[docs]</a>    <span class="k">def</span> <span class="nf">dup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Duplicate the basic structure into a new DFA. Basically a copy.deep.</span>

<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[:]</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">new</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="DFA.equal"><a class="viewcode-back" href="../index.html#fa.DFA.equal">[docs]</a>    <span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify if the two automata are equivalent. Both are verified to be minimum and complete,</span>
<span class="sd">        and then one is matched against the other... Doesn&#39;t destroy either dfa...</span>

<span class="sd">        :param other: the other DFA</span>
<span class="sd">        :type other: DFA</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests equivalence of DFAs</span>

<span class="sd">        :param other: the other DFA</span>
<span class="sd">        :type other: DFA</span>
<span class="sd">        :return: bool&quot;&quot;&quot;</span>
        <span class="n">dfa1</span><span class="p">,</span> <span class="n">dfa2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">dfa1</span> <span class="o">=</span> <span class="n">dfa1</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span>
        <span class="n">dfa2</span> <span class="o">=</span> <span class="n">dfa2</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span>
        <span class="n">dfa1</span><span class="o">.</span><span class="n">completeMinimal</span><span class="p">()</span>
        <span class="n">dfa2</span><span class="o">.</span><span class="n">completeMinimal</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">dfa1</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">!=</span> <span class="n">dfa2</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dfa1</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">dfa2</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dfa1</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dfa2</span><span class="o">.</span><span class="n">States</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dfa1</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dfa2</span><span class="o">.</span><span class="n">Final</span><span class="p">))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">dfa1</span><span class="o">.</span><span class="n">_uniqueStr</span><span class="p">()</span> <span class="o">!=</span> <span class="n">dfa2</span><span class="o">.</span><span class="n">_uniqueStr</span><span class="p">())):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_lstTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">k</span><span class="p">]]))</span>
        <span class="k">return</span> <span class="n">l</span>

    <span class="k">def</span> <span class="nf">_lstInitial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return:</span>
<span class="sd">        :raise: DFAnoInitial if no initial state is defined &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAnoInitial</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_s_lstInitial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lstInitial</span><span class="p">())</span>

<div class="viewcode-block" id="DFA.notequal"><a class="viewcode-back" href="../index.html#fa.DFA.notequal">[docs]</a>    <span class="k">def</span> <span class="nf">notequal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Test non  equivalence of two DFAs</span>

<span class="sd">        :param other: the other DFA</span>
<span class="sd">        :type other: DFA</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ne__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Tests non-equivalence of two DFAs</span>

<span class="sd">        :param other: the other DFA</span>
<span class="sd">        :type other: DFA</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<div class="viewcode-block" id="DFA.hyperMinimal"><a class="viewcode-back" href="../index.html#fa.DFA.hyperMinimal">[docs]</a>    <span class="k">def</span> <span class="nf">hyperMinimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Hyperminization of a minimal DFA</span>

<span class="sd">        :param strict: if strict=True it first minimizes the DFA</span>
<span class="sd">        :type  strict: bool</span>
<span class="sd">        :returns: an hyperminimal DFA</span>
<span class="sd">        :rtype: DFA</span>

<span class="sd">        .. seealso::</span>
<span class="sd">           M. Holzer and A. Maletti, An nlogn Algorithm for Hyper-Minimizing a (Minimized) Deterministic Automata,</span>
<span class="sd">           TCS 411(38-39): 3404-3413 (2010)</span>

<span class="sd">        .. note:: if strict=False minimality is assumed&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">comp</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">mark</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">computeKernel</span><span class="p">()</span>
        <span class="n">ker</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">mark</span><span class="p">])</span>
        <span class="n">m</span><span class="o">.</span><span class="n">_mergeStatesKernel</span><span class="p">(</span><span class="n">ker</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">aEquiv</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">m</span>
</div>
    <span class="k">def</span> <span class="nf">_mergeStatesKernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ker</span><span class="p">,</span> <span class="n">aequiv</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Merge states of almost equivalent partition. Used by hyperMinimal.</span>

<span class="sd">        :param ker:</span>
<span class="sd">        :param aequiv: partition of almost equivalence&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">aequiv</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">aequiv</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">ker</span><span class="p">)</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">aequiv</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">aequiv</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">ker</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mergeStates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>

<div class="viewcode-block" id="DFA.computeKernel"><a class="viewcode-back" href="../index.html#fa.DFA.computeKernel">[docs]</a>    <span class="k">def</span> <span class="nf">computeKernel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The Kernel of a ICDFA is the set of states that accept  a non finite language.</span>

<span class="sd">        :returns: triple (comp, center , mark) where comp are the strongly connected components,</span>
<span class="sd">                  center the set of center states and mark the kernel states</span>
<span class="sd">        :rtype: tuple</span>

<span class="sd">        .. note:</span>
<span class="sd">           DFA must be initially connected</span>

<span class="sd">        .. seealso:</span>
<span class="sd">           Holzer and A. Maletti, An nlogn Algorithm for Hyper-Minimizing a (Minimized) Deterministic Automata,</span>
<span class="sd">           TCS 411(38-39): 3404-3413 (2010)&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_SCC</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">ind</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span>
            <span class="n">low</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="c"># noinspection PyNoneFunctionAssignment</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">t1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">t1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                    <span class="n">_SCC</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
                    <span class="n">low</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">low</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">t1</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">t1</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">:</span>
                        <span class="n">low</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">low</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">ind</span><span class="p">[</span><span class="n">t1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">low</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="n">ind</span><span class="p">[</span><span class="n">t</span><span class="p">]:</span>
                <span class="n">comp</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">while</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">t</span><span class="p">:</span>
                    <span class="n">comp</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_DFS</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">mark</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">a1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="c"># noinspection PyNoneFunctionAssignment</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">t1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">t1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mark</span><span class="p">:</span>
                    <span class="n">_DFS</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">low</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">center</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">])</span>
        <span class="n">_SCC</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">center</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
        <span class="n">mark</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">mark</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">center</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="c"># noinspection PyNoneFunctionAssignment</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">s1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">s1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mark</span><span class="p">:</span>
                    <span class="n">_DFS</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span>
        <span class="k">return</span> <span class="n">comp</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">mark</span>
</div>
<div class="viewcode-block" id="DFA.aEquiv"><a class="viewcode-back" href="../index.html#fa.DFA.aEquiv">[docs]</a>    <span class="k">def</span> <span class="nf">aEquiv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes almost equivalence, used by hyperMinimial</span>

<span class="sd">        :returns: partition of states</span>
<span class="sd">        :rtype: dictionary</span>

<span class="sd">        .. note::</span>
<span class="sd">           may be optimized to avoid dupped&quot;&quot;&quot;</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dupped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">dupped</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
            <span class="n">pi</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">q</span><span class="p">}</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">I</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dupped</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dupped</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="n">dupped</span><span class="o">.</span><span class="n">_compute_delta_inv</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">I</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">succ</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">dupped</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">dupped</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">dupped</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">q</span><span class="p">)][</span><span class="n">a</span><span class="p">]]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dupped</span><span class="o">.</span><span class="n">Sigma</span>
                          <span class="k">if</span> <span class="n">dupped</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dupped</span><span class="o">.</span><span class="n">delta</span> <span class="ow">and</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dupped</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">dupped</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">q</span><span class="p">)]])</span>
            <span class="k">if</span> <span class="n">succ</span> <span class="ow">in</span> <span class="n">h</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">succ</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="n">q</span><span class="p">]):</span>
                    <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span>
                <span class="n">P</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">I</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">P</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dupped</span><span class="o">.</span><span class="n">Sigma</span>
                          <span class="k">if</span> <span class="n">dupped</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dupped</span><span class="o">.</span><span class="n">delta_inv</span><span class="p">[</span><span class="n">dupped</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">p</span><span class="p">)][</span><span class="n">a</span><span class="p">]])</span>
                <span class="n">dupped</span><span class="o">.</span><span class="n">mergeStates</span><span class="p">(</span><span class="n">dupped</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">dupped</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
                <span class="n">dupped</span><span class="o">.</span><span class="n">_compute_delta_inv</span><span class="p">()</span>
                <span class="n">pi</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
                <span class="k">del</span> <span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
            <span class="n">h</span><span class="p">[</span><span class="n">succ</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>
        <span class="k">return</span> <span class="n">pi</span>
</div>
<div class="viewcode-block" id="DFA.mergeStates"><a class="viewcode-back" href="../index.html#fa.DFA.mergeStates">[docs]</a>    <span class="k">def</span> <span class="nf">mergeStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge the first given state into the second. If the first state is an initial state the second becomes the</span>
<span class="sd">        initial state.</span>

<span class="sd">        :param f: index of state to be absorbed</span>
<span class="sd">        :type f: int</span>
<span class="sd">        :param t: index of remaining state</span>
<span class="sd">        :type t:  int</span>

<span class="sd">        .. attention::</span>
<span class="sd">           It is up to the caller to remove the disconnected state. This can be achieved with ```trim()``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">to</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">to</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialP</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deleteStates</span><span class="p">([</span><span class="n">f</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="DFA.toADFA"><a class="viewcode-back" href="../index.html#fa.DFA.toADFA">[docs]</a>    <span class="k">def</span> <span class="nf">toADFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Try to convert DFA to ADFA</span>

<span class="sd">        :return: the same automaton as a ADFA</span>
<span class="sd">        :rtype: ADFA</span>
<span class="sd">        :raises notAcyclic: if this is not an acyclic DFA</span>

<span class="sd">        .. versionadded:: 1.2&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">fl</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">acyclicP</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">notAcyclic</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">fl</span><span class="o">.</span><span class="n">ADFA</span><span class="p">()</span>
            <span class="n">new</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
            <span class="n">new</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="DFA.toDFA"><a class="viewcode-back" href="../index.html#fa.DFA.toDFA">[docs]</a>    <span class="k">def</span> <span class="nf">toDFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dummy function. It is already a DFA</span>

<span class="sd">        :returns: a self deep copy</span>
<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">_uniqueStr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a canonical representation of the automaton.</span>

<span class="sd">        :returns: canonical representation of the skeleton and the list of final states, in a pair</span>
<span class="sd">        :rtype: pair of lists of int</span>

<span class="sd">        .. note:</span>
<span class="sd">           Automata is supposed to be a icdfa. It, now, should cope with non complete automata&quot;&quot;&quot;</span>
        <span class="n">SSigma</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">SSigma</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">tf</span><span class="p">,</span> <span class="n">tr</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="n">string</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">tf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">SSigma</span><span class="p">:</span>
                <span class="c"># noinspection PyNoneFunctionAssignment</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                <span class="c"># foo = self.delta[tr[i]][c]</span>
                <span class="k">if</span> <span class="n">foo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">foo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tf</span><span class="p">:</span>
                        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">tf</span><span class="p">[</span><span class="n">foo</span><span class="p">],</span> <span class="n">tr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">foo</span>
                    <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="p">[</span><span class="n">foo</span><span class="p">])</span>
            <span class="n">string</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
        <span class="n">lst</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">string</span><span class="p">,</span> <span class="n">lst</span>

<div class="viewcode-block" id="DFA.uniqueRepr"><a class="viewcode-back" href="../index.html#fa.DFA.uniqueRepr">[docs]</a>    <span class="k">def</span> <span class="nf">uniqueRepr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normalise unique string for the string icdfa&#39;s representation.</span>

<span class="sd">        .. seealso::</span>
<span class="sd">           TCS 387(2):93-102, 2007 http://www.ncc.up.pt/~nam/publica/tcsamr06.pdf</span>

<span class="sd">        :returns: normalised representation</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        :raises DFAnotComplete: if DFA is not complete&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniqueStr</span><span class="p">()</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">finals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">finals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">],</span> <span class="n">finals</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAnotComplete</span>
</div>
    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a DFA that recognises the complementary language:  ~X. Basically change all non-final states to</span>
<span class="sd">        final and vice-versa. After ensuring that it is complete.</span>

<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">fa</span><span class="o">.</span><span class="n">eliminateDeadName</span><span class="p">()</span>
        <span class="n">fa</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">fa</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fa</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">fa</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fa</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">FAdoGeneralError</span><span class="p">(</span><span class="s">&quot;Incompatible objects&quot;</span><span class="p">)</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">complete</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fa</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="ow">or</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">fa</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fa</span><span class="o">.</span><span class="n">_namesToString</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="DFA.simDiff"><a class="viewcode-back" href="../index.html#fa.DFA.simDiff">[docs]</a>    <span class="k">def</span> <span class="nf">simDiff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Symetrical difference</span>

<span class="sd">        :param other:</span>
<span class="sd">        :return:&quot;&quot;&quot;</span>
        <span class="c"># noinspection PyUnresolvedReferences</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">other</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">other</span> <span class="o">-</span> <span class="bp">self</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DFA</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">FAdoGeneralError</span><span class="p">(</span><span class="s">&quot;Incompatible objects&quot;</span><span class="p">)</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">complete</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fa</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="ow">and</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">fa</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fa</span><span class="o">.</span><span class="n">_namesToString</span><span class="p">()</span>

<div class="viewcode-block" id="DFA.product"><a class="viewcode-back" href="../index.html#fa.DFA.product">[docs]</a>    <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a DFA resulting of the simultaneous execution of two DFA. No final states set.</span>

<span class="sd">        :param other: the other DFA</span>
<span class="sd">        :param complete: evaluate product as a complete DFA</span>
<span class="sd">        :type complete: bool</span>
<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="n">NSigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">fa1</span><span class="p">,</span> <span class="n">fa2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">fa1</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">NSigma</span><span class="p">)</span>
        <span class="n">fa2</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">NSigma</span><span class="p">)</span>
        <span class="n">fa1</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">fa2</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">fa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">NSigma</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">addState</span><span class="p">((</span><span class="n">fa1</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="n">fa2</span><span class="o">.</span><span class="n">Initial</span><span class="p">))</span>
        <span class="n">fa</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">fa</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">fa1</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">c</span><span class="p">],</span> <span class="n">fa2</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i2</span><span class="p">][</span><span class="n">c</span><span class="p">])</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                <span class="n">fa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">foo</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fa</span><span class="o">.</span><span class="n">States</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">complete</span><span class="p">:</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">fa1</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">DeadName</span><span class="p">)</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">fa2</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">DeadName</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">DFAstateUnknown</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fa</span><span class="o">.</span><span class="n">deleteState</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fa</span>
</div>
<div class="viewcode-block" id="DFA.witness"><a class="viewcode-back" href="../index.html#fa.DFA.witness">[docs]</a>    <span class="k">def</span> <span class="nf">witness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Witness of non emptyness</span>

<span class="sd">        :return: word</span>
<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">notDone</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">pref</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">si</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
        <span class="n">pref</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">Epsilon</span>
        <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">notDone</span><span class="p">:</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">notDone</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pref</span><span class="p">[</span><span class="n">si</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">syi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">so</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">si</span><span class="p">][</span><span class="n">syi</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">so</span> <span class="ow">in</span> <span class="n">done</span> <span class="ow">or</span> <span class="n">so</span> <span class="ow">in</span> <span class="n">notDone</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">pref</span><span class="p">[</span><span class="n">so</span><span class="p">]</span> <span class="o">=</span> <span class="n">sConcat</span><span class="p">(</span><span class="n">pref</span><span class="p">[</span><span class="n">si</span><span class="p">],</span> <span class="n">syi</span><span class="p">)</span>
                <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">so</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="DFA.concat"><a class="viewcode-back" href="../index.html#fa.DFA.concat">[docs]</a>    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fa2</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenation of two DFAs. If DFAs are not complete, they are completed.</span>

<span class="sd">        :param strict: should alphabets be checked?</span>
<span class="sd">        :type strict: Boolean</span>
<span class="sd">        :param fa2: the second DFA</span>
<span class="sd">        :type fa2: DFA</span>
<span class="sd">        :returns: the result of the concatenation</span>
<span class="sd">        :rtype: DFA</span>
<span class="sd">        :raises DFAdifferentSigma: if alphabet are not equal&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">!=</span> <span class="n">fa2</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAdifferentSigma</span>
        <span class="n">NSigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">fa2</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">(),</span> <span class="n">fa2</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">d1</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">NSigma</span><span class="p">)</span>
        <span class="n">d2</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">NSigma</span><span class="p">)</span>
        <span class="n">d1</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">d2</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">d2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
                <span class="n">new</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">States</span><span class="p">[:]</span>
                <span class="n">new</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">Initial</span>
                <span class="n">new</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">d1</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">if</span> <span class="n">new</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">d1</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                            <span class="n">new</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">d1</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                            <span class="n">new</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">new</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">lStates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="nb">set</span><span class="p">([]))</span>
        <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d1</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">Initial</span><span class="p">):</span>
            <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d2</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">Initial</span><span class="p">):</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">stu</span> <span class="o">=</span> <span class="n">lStates</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stu</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">d1</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">stn</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">stu</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sym</span><span class="p">),</span> <span class="n">d2</span><span class="o">.</span><span class="n">evalSymbolL</span><span class="p">(</span><span class="n">stu</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sym</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">d1</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">stn</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">stn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lStates</span><span class="p">:</span>
                    <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">d2</span><span class="o">.</span><span class="n">Final</span> <span class="o">&amp;</span> <span class="n">stn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lStates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">c</span>
</div>
<div class="viewcode-block" id="DFA.star"><a class="viewcode-back" href="../index.html#fa.DFA.star">[docs]</a>    <span class="k">def</span> <span class="nf">star</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Star of a DFA. If the DFA is not complete, it is completed.</span>

<span class="sd">        ..versionchanged: 0.9.6</span>

<span class="sd">        :param flag: plus instead of star</span>
<span class="sd">        :type flag: bool</span>
<span class="sd">        :returns: the result of the star</span>
<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># to keep the checker happy</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">Sigma</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Epsilon automaton</span>
            <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">c</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>
            <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="n">F0</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">Final</span> <span class="o">-</span> <span class="p">{</span><span class="n">d</span><span class="o">.</span><span class="n">Initial</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;initial&quot;</span><span class="p">)</span>
            <span class="n">c</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">lStates</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;initial&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">stn</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="n">sym</span><span class="p">)}</span>
                <span class="c"># correction</span>
                <span class="k">if</span> <span class="n">F0</span> <span class="o">&amp;</span> <span class="n">stn</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
                    <span class="n">stn</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lStates</span><span class="p">:</span>
                    <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">Final</span> <span class="o">&amp;</span> <span class="n">stn</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
                <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">({</span><span class="n">d</span><span class="o">.</span><span class="n">Initial</span><span class="p">})</span>
            <span class="n">c</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">Initial</span><span class="p">):</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">lStates</span> <span class="o">=</span> <span class="p">[{</span><span class="n">d</span><span class="o">.</span><span class="n">Initial</span><span class="p">}]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">stu</span> <span class="o">=</span> <span class="n">lStates</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stu</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">stn</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">evalSymbolL</span><span class="p">(</span><span class="n">stu</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">F0</span> <span class="o">&amp;</span> <span class="n">stn</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
                    <span class="n">stn</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lStates</span><span class="p">:</span>
                    <span class="c"># noinspection PyTypeChecker</span>
                    <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">Final</span> <span class="o">&amp;</span> <span class="n">stn</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lStates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">c</span>
</div>
<div class="viewcode-block" id="DFA.evalSymbolI"><a class="viewcode-back" href="../index.html#fa.DFA.evalSymbolI">[docs]</a>    <span class="k">def</span> <span class="nf">evalSymbolI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">sym</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the state reached from a given state.</span>

<span class="sd">        :arg init: current state</span>
<span class="sd">        :type init: int</span>
<span class="sd">        :arg sym: symbol to be consumed</span>
<span class="sd">        :type sym: str</span>
<span class="sd">        :returns: reached state or -1</span>
<span class="sd">        :rtype: set of int</span>

<span class="sd">        :raise DFAsymbolUnknown: if symbol not in alphabet</span>

<span class="sd">        .. versionadded:: 0.9.5</span>

<span class="sd">        .. note:: this is to be used with non complete DFAs&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAsymbolUnknown</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">Next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">init</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">Next</span>
</div>
<div class="viewcode-block" id="DFA.evalSymbolLI"><a class="viewcode-back" href="../index.html#fa.DFA.evalSymbolLI">[docs]</a>    <span class="k">def</span> <span class="nf">evalSymbolLI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls</span><span class="p">,</span> <span class="n">sym</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the set of states reached from a given set of states through a given symbol</span>

<span class="sd">        :arg ls: set of current states</span>
<span class="sd">        :type ls: set of int</span>
<span class="sd">        :arg sym: symbol to be consumed</span>
<span class="sd">        :type sym: str</span>
<span class="sd">        :returns: set of reached states</span>
<span class="sd">        :rtype: set of int</span>


<span class="sd">        .. versionadded:: 0.9.5</span>

<span class="sd">        .. note:: this is to be used with non complete DFAs&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">evalSymbolI</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ls</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalSymbolI</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="DFA.concatI"><a class="viewcode-back" href="../index.html#fa.DFA.concatI">[docs]</a>    <span class="k">def</span> <span class="nf">concatI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fa2</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenation of two DFAs.</span>

<span class="sd">        :param fa2: the second DFA</span>
<span class="sd">        :type fa2: DFA</span>
<span class="sd">        :arg strict: should alphabets be checked?</span>
<span class="sd">        :type strict: Boolean</span>
<span class="sd">        :returns: the result of the concatenation</span>
<span class="sd">        :rtype: DFA</span>

<span class="sd">        :raises DFAdifferentSigma: if alphabet are not equal</span>

<span class="sd">        .. versionadded:: 0.9.5</span>

<span class="sd">        .. note:: this is to be used with non complete DFAs&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">!=</span> <span class="n">fa2</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAdifferentSigma</span>
        <span class="n">NSigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">fa2</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">(),</span> <span class="n">fa2</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">d1</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">NSigma</span><span class="p">)</span>
        <span class="n">d2</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">NSigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">d2</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">lStates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="nb">set</span><span class="p">([]))</span>
        <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d1</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">Initial</span><span class="p">):</span>
            <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d2</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">Initial</span><span class="p">):</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">stu</span> <span class="o">=</span> <span class="n">lStates</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stu</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">d1</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">stn</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">evalSymbolI</span><span class="p">(</span><span class="n">stu</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sym</span><span class="p">),</span> <span class="n">d2</span><span class="o">.</span><span class="n">evalSymbolLI</span><span class="p">(</span><span class="n">stu</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sym</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">stn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">stn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">}))</span> <span class="o">|</span> <span class="p">((</span><span class="n">stn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">stn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]))):</span>
                    <span class="k">if</span> <span class="n">d1</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">stn</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">stn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lStates</span><span class="p">:</span>
                        <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                        <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">d2</span><span class="o">.</span><span class="n">Final</span> <span class="o">&amp;</span> <span class="n">stn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
                            <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lStates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">c</span>
</div>
<div class="viewcode-block" id="DFA.starI"><a class="viewcode-back" href="../index.html#fa.DFA.starI">[docs]</a>    <span class="k">def</span> <span class="nf">starI</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Star of an incomplete DFA.</span>

<span class="sd">        .. varsionadded::: 0.9.5</span>

<span class="sd">        :returns: the Kleene closure DFA</span>
<span class="sd">        :rtype: DFA&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">Sigma</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Epsilon automaton</span>
            <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">c</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>
            <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="n">F0</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">Final</span> <span class="o">-</span> <span class="p">{</span><span class="n">d</span><span class="o">.</span><span class="n">Initial</span><span class="p">}</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;initial&quot;</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">lStates</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;initial&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="n">stn</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="o">.</span><span class="n">evalSymbolI</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="n">sym</span><span class="p">)}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">stn</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">stn</span> <span class="o">!=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">}):</span>
                <span class="c"># correction</span>
                <span class="k">if</span> <span class="n">F0</span> <span class="o">&amp;</span> <span class="n">stn</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
                    <span class="n">stn</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lStates</span><span class="p">:</span>
                    <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">Final</span> <span class="o">&amp;</span> <span class="n">stn</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">stu</span> <span class="o">=</span> <span class="n">lStates</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stu</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">stn</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">evalSymbolLI</span><span class="p">(</span><span class="n">stu</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stn</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
                    <span class="k">if</span> <span class="n">F0</span> <span class="o">&amp;</span> <span class="n">stn</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
                        <span class="n">stn</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lStates</span><span class="p">:</span>
                        <span class="n">lStates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                        <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">Final</span> <span class="o">&amp;</span> <span class="n">stn</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([]):</span>
                            <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lStates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">c</span>
</div>
<div class="viewcode-block" id="DFA.shuffle"><a class="viewcode-back" href="../index.html#fa.DFA.shuffle">[docs]</a>    <span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shuffle of two languages: L1 W L2</span>

<span class="sd">        :param other: second automaton</span>
<span class="sd">        :type other: DFA</span>
<span class="sd">        :param strict: should the alphabets be necessary equal?</span>
<span class="sd">        :type strict: bool</span>
<span class="sd">        :rtype: DFA</span>

<span class="sd">        .. seealso::</span>
<span class="sd">           C. Câmpeanu, K. Salomaa and S. Yu, *Tight lower bound for the state complexity of shuffle of regular</span>
<span class="sd">           languages.* J. Autom. Lang. Comb. 7 (2002) 303–310.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DFAdifferentSigma</span>
        <span class="n">NSigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="n">d1</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">NSigma</span><span class="p">)</span>
        <span class="n">d2</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">NSigma</span><span class="p">)</span>
        <span class="c"># d1.complete(); d2.complete()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">({(</span><span class="n">d1</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="n">d2</span><span class="o">.</span><span class="n">Initial</span><span class="p">)})</span>
        <span class="n">c</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d1</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d2</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">Initial</span><span class="p">):</span>
            <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">sn</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">stn</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">stn</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">d1</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sym</span><span class="p">),</span> <span class="n">st</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="k">except</span> <span class="n">DFAstopped</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">stn</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d2</span><span class="o">.</span><span class="n">evalSymbol</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sym</span><span class="p">)))</span>
                    <span class="k">except</span> <span class="n">DFAstopped</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">if</span> <span class="n">stn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="n">stn</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">d1</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">sti</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">d2</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">sti</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="n">c</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                            <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">stn</span><span class="p">)</span>
                <span class="n">c</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">c</span>
</div>
<div class="viewcode-block" id="DFA.reorder"><a class="viewcode-back" href="../index.html#fa.DFA.reorder">[docs]</a>    <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dicti</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reorders states according to given dictionary. Given a dictionary (not necessarily complete)... reorders</span>
<span class="sd">        states accordingly.</span>

<span class="sd">        :param dicti</span>
<span class="sd">        :type dicti: dictionary&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dicti</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dicti</span><span class="p">:</span>
                    <span class="n">dicti</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="n">delta</span><span class="p">[</span><span class="n">dicti</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">delta</span><span class="p">[</span><span class="n">dicti</span><span class="p">[</span><span class="n">s</span><span class="p">]][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dicti</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="n">dicti</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]</span>
        <span class="n">Final</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">Final</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dicti</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="n">Final</span>
        <span class="n">states</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">states</span><span class="p">[</span><span class="n">dicti</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">states</span>
</div>
<div class="viewcode-block" id="DFA.regexp"><a class="viewcode-back" href="../index.html#fa.DFA.regexp">[docs]</a>    <span class="k">def</span> <span class="nf">regexp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a regexp for the current DFA considering the recursive method. Very inefficent.</span>

<span class="sd">        :returns: a regexp equivalent to the current DFA</span>
<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">nstates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">emptyset</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RPath</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">uSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">),</span> <span class="n">nstates</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">disj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_RPath</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nstates</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">r</span>
</div>
    <span class="k">def</span> <span class="nf">_RPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursive path. (Dijsktra algorithm) The recursive function that plays a central role in the creation of</span>
<span class="sd">        the RE from a DFA. This suppose that there are no disconnected states.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">initial</span> <span class="o">==</span> <span class="n">final</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">epsilon</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">initial</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">initial</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="n">initial</span><span class="p">:</span>
                            <span class="n">r</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">disj</span><span class="p">(</span><span class="n">r</span><span class="p">,</span>
                                          <span class="n">reex</span><span class="o">.</span><span class="n">regexp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span>
                                          <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">emptyset</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">initial</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">initial</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="n">final</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">emptyP</span><span class="p">():</span>
                                <span class="n">r</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">disj</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">reex</span><span class="o">.</span><span class="n">regexp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">r</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">regexp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">disj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_RPath</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                          <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_RPath</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                                      <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_RPath</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                                                            <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">_RPath</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">final</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                                                  <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span>
                                      <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>

<div class="viewcode-block" id="DFA.witnessDiff"><a class="viewcode-back" href="../index.html#fa.DFA.witnessDiff">[docs]</a>    <span class="k">def</span> <span class="nf">witnessDiff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a witness for the difference of two DFAs and:</span>

<span class="sd">        +---+------------------------------------------------------+</span>
<span class="sd">        | 0 | if the witness belongs to the **other** language     |</span>
<span class="sd">        +---+------------------------------------------------------+</span>
<span class="sd">        | 1 | if the witness belongs to the **self** language      |</span>
<span class="sd">        +---+------------------------------------------------------+</span>

<span class="sd">        :param other: the other DFA</span>
<span class="sd">        :type other: DFA</span>
<span class="sd">        :returns: a witness word</span>
<span class="sd">        :rtype: list of symbols</span>
<span class="sd">        :raises DFAequivalent: if automata are equivalent&quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span> <span class="o">&amp;</span> <span class="n">other</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">witness</span><span class="p">()</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">~</span><span class="n">other</span> <span class="o">&amp;</span> <span class="bp">self</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">witness</span><span class="p">()</span>
            <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DFAequivalent</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">v</span>
</div>
<div class="viewcode-block" id="DFA.usefulStates"><a class="viewcode-back" href="../index.html#fa.DFA.usefulStates">[docs]</a>    <span class="k">def</span> <span class="nf">usefulStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_states</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of states reacheable from the given initial state(s) that have a path to a final state.</span>

<span class="sd">        :param initial_states: starting states</span>
<span class="sd">        :type initial_states: iterable of int</span>

<span class="sd">        :returns: set of state indexes</span>
<span class="sd">        :rtype: set of int&quot;&quot;&quot;</span>
        <span class="c"># ATTENTION CODER: This is mostly a copy&amp;paste of</span>
        <span class="c"># NFA.usefulStates(), except that the inner loop for adjacent</span>
        <span class="c"># states is removed, and default initial_states is a list with</span>
        <span class="c"># self.Initial and is considered useful</span>
        <span class="k">if</span> <span class="n">initial_states</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">initial_states</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]</span>
            <span class="n">useful</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">initial_states</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">useful</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">initial_states</span>
                          <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">])</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">initial_states</span><span class="p">)</span>
        <span class="n">preceding</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">preceding</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                <span class="n">adjacent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]</span>
                <span class="n">is_useful</span> <span class="o">=</span> <span class="n">adjacent</span> <span class="ow">in</span> <span class="n">useful</span>
                <span class="k">if</span> <span class="n">adjacent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="ow">or</span> <span class="n">is_useful</span><span class="p">:</span>
                    <span class="n">useful</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_useful</span><span class="p">:</span>
                        <span class="n">useful</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">adjacent</span><span class="p">)</span>
                        <span class="n">preceding</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adjacent</span><span class="p">)</span>
                    <span class="n">inpath_stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">preceding</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">useful</span><span class="p">]</span>
                    <span class="n">preceding</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">while</span> <span class="n">inpath_stack</span><span class="p">:</span>
                        <span class="n">previous</span> <span class="o">=</span> <span class="n">inpath_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="n">useful</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>
                        <span class="n">inpath_stack</span> <span class="o">+=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">preceding</span><span class="p">[</span><span class="n">previous</span><span class="p">]</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">useful</span><span class="p">]</span>
                        <span class="n">preceding</span><span class="p">[</span><span class="n">previous</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">adjacent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">preceding</span><span class="p">:</span>
                    <span class="n">preceding</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">state</span><span class="p">]</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adjacent</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">preceding</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">useful</span>
</div>
<div class="viewcode-block" id="DFA.finalCompP"><a class="viewcode-back" href="../index.html#fa.DFA.finalCompP">[docs]</a>    <span class="k">def</span> <span class="nf">finalCompP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Verifies if there is a final state in  strongly connected component containing ``s``.</span>

<span class="sd">        :param s: state</span>
<span class="sd">        :type s: int</span>
<span class="sd">        :returns: 1 if yes, 0 if no&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">foo</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">c</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">True</span>
                    <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="DFA.unmark"><a class="viewcode-back" href="../index.html#fa.DFA.unmark">[docs]</a>    <span class="k">def</span> <span class="nf">unmark</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unmarked NFA that corresponds to a marked DFA: in which each alfabetic symbol is a tuple (symbol, index)</span>

<span class="sd">        :returns: a NFA</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">nfa</span> <span class="o">=</span> <span class="n">NFA</span><span class="p">()</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">setInitial</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">])</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">setFinal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">marked_symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">sym</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">marked_symbol</span>
                <span class="n">nfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">marked_symbol</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">nfa</span>
</div>
<div class="viewcode-block" id="DFA.toNFA"><a class="viewcode-back" href="../index.html#fa.DFA.toNFA">[docs]</a>    <span class="k">def</span> <span class="nf">toNFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Migrates a DFA to a NFA as dup()</span>

<span class="sd">        :returns: DFA seen as new NFA</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">NFA</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[:]</span>
        <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="DFA.toGFA"><a class="viewcode-back" href="../index.html#fa.DFA.toGFA">[docs]</a>    <span class="k">def</span> <span class="nf">toGFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a GFA equivalent to DFA</span>

<span class="sd">        :returns: GFA deep copy</span>
<span class="sd">        :rtype: GFA &quot;&quot;&quot;</span>
        <span class="n">gfa</span> <span class="o">=</span> <span class="n">GFA</span><span class="p">()</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[:]</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">setFinal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
        <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gfa</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">gfa</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">gfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">gfa</span>
</div>
<div class="viewcode-block" id="DFA.stateChildren"><a class="viewcode-back" href="../index.html#fa.DFA.stateChildren">[docs]</a>    <span class="k">def</span> <span class="nf">stateChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of children of a state</span>

<span class="sd">        :param strict: if not strict a state is never its own child even if a self loop is in place</span>
<span class="sd">        :param state: state id queried</span>
<span class="sd">        :type state: int</span>
<span class="sd">        :type strict: bool</span>
<span class="sd">        :returns: map children -&gt; multiplicity</span>
<span class="sd">        :rtype: dictionary&quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">l</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                <span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
                <span class="n">l</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">strict</span> <span class="ow">and</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">l</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">l</span>
</div>
    <span class="k">def</span> <span class="nf">_smAtomic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monoid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluation of the atomic transformations of a DFA</span>

<span class="sd">        :arg monoid:</span>
<span class="sd">        :type monoid: bool</span>
<span class="sd">        :returns: list of transformations</span>
<span class="sd">        :rtype: set of list of int&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">completeP</span><span class="p">():</span>
            <span class="n">aut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
            <span class="n">aut</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aut</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">aut</span><span class="p">)</span>
        <span class="n">mon</span> <span class="o">=</span> <span class="n">SSemiGroup</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">monoid</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
            <span class="n">mon</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">mon</span><span class="o">.</span><span class="n">words</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
            <span class="n">mon</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">mon</span><span class="o">.</span><span class="n">Monoid</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">aut</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">mon</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">mon</span><span class="o">.</span><span class="n">addGen</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mon</span>

    <span class="k">def</span> <span class="nf">_ssg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monoid</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param monoid:</span>
<span class="sd">        :type monoid: bool</span>
<span class="sd">        :return:&quot;&quot;&quot;</span>
        <span class="n">sm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smAtomic</span><span class="p">(</span><span class="n">monoid</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sm</span><span class="o">.</span><span class="n">gen</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">sm</span>
        <span class="k">if</span> <span class="n">sm</span><span class="o">.</span><span class="n">Monoid</span><span class="p">:</span>
            <span class="n">natomic</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">gen</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">natomic</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">gen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">gen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">g0</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g0</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">gen</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">gen</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">t1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">natomic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">g0</span><span class="p">:</span><span class="n">g1</span><span class="p">]):</span>
                    <span class="n">t12</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">t2</span><span class="p">[</span><span class="n">t1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="p">))))</span>
                    <span class="n">ll</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">t12</span><span class="p">,</span> <span class="n">pr</span> <span class="o">+</span> <span class="n">g0</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">words</span><span class="p">[</span><span class="n">sym</span> <span class="o">+</span> <span class="n">shift</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">ll</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">sm</span><span class="o">.</span><span class="n">addGen</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">sm</span>

<div class="viewcode-block" id="DFA.sMonoid"><a class="viewcode-back" href="../index.html#fa.DFA.sMonoid">[docs]</a>    <span class="k">def</span> <span class="nf">sMonoid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluation of the syntactic monoid of a DFA</span>

<span class="sd">        :returns: the semigroup</span>
<span class="sd">        :rtype: SSemiGroup&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssg</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DFA.sSemigroup"><a class="viewcode-back" href="../index.html#fa.DFA.sSemigroup">[docs]</a>    <span class="k">def</span> <span class="nf">sSemigroup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluation of the syntactic semigroup of a DFA</span>

<span class="sd">        :returns: the semigroup</span>
<span class="sd">        :rtype: SSemiGroup&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssg</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="DFA.enumDFA"><a class="viewcode-back" href="../index.html#fa.DFA.enumDFA">[docs]</a>    <span class="k">def</span> <span class="nf">enumDFA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the set of words of words of length up to n accepted by self</span>
<span class="sd">        :param n: highest length or all words if finite</span>
<span class="sd">        :type n: int</span>

<span class="sd">        :rtype: list of strings or None</span>

<span class="sd">        .. note: use with care because the number of words can be huge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">EnumDFA</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">words</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">e</span><span class="o">.</span><span class="n">enumCrossSection</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">words</span> <span class="o">+=</span> <span class="n">e</span><span class="o">.</span><span class="n">Words</span>
        <span class="k">return</span> <span class="n">words</span>
</div></div>
<div class="viewcode-block" id="GFA"><a class="viewcode-back" href="../index.html#fa.GFA">[docs]</a><span class="k">class</span> <span class="nc">GFA</span><span class="p">(</span><span class="n">OFA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Class for Generalized Finite Automata: NFA with a unique initial state and transitions are labeled with regexp.</span>

<span class="sd">    .. inheritance-diagram:: GFA&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">finalCompP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NImplemented</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">evalSymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NImplemented</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NImplemented</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">deleteStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">del_states</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NImplemented</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">initialComp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NImplemented</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_getTags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NImplemented</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NImplemented</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">succintTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NImplemented</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">toGFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NImplemented</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">usefulStates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NImplemented</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">uniqueRepr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NImplemented</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GFA</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;GFA string representation</span>
<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&#39;GFA({0:&gt;s})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__str__</span><span class="p">())</span>

<div class="viewcode-block" id="GFA.addTransition"><a class="viewcode-back" href="../index.html#fa.GFA.addTransition">[docs]</a>    <span class="k">def</span> <span class="nf">addTransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">sti2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a new transition from ``sti1`` to ``sti2`` consuming symbol ``sym``. Label of the transition function</span>
<span class="sd">         is a regexp.</span>

<span class="sd">        :param sti1: state index of departure</span>
<span class="sd">        :type sti1: int</span>
<span class="sd">        :param sti2: state index of arrival</span>
<span class="sd">        :type sti2: int</span>
<span class="sd">        :param sym: symbol consumed</span>
<span class="sd">        :type sym: str</span>
<span class="sd">        :raises DFAepsilonRedefenition: if sym is Epsilon&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addSigma</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">regexp</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">DFAepsilonRedefinition</span><span class="p">:</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">epsilon</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">sti1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">sti2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sti2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sti2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">disj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sti2</span><span class="p">],</span> <span class="n">sym</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="c"># TODO: write cleaner code and get rid of the general catch</span>
        <span class="c"># noinspection PyBroadException</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">sti2</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sti1</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
</div>
<div class="viewcode-block" id="GFA.reorder"><a class="viewcode-back" href="../index.html#fa.GFA.reorder">[docs]</a>    <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictio</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reorder states indexes according to given dictionary.</span>

<span class="sd">        :param dictio: order</span>
<span class="sd">        :type dictio: dictionary</span>

<span class="sd">        .. note::</span>
<span class="sd">           dictionary does not have to be complete&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dictio</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictio</span><span class="p">:</span>
                    <span class="n">dictio</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="n">delta</span><span class="p">[</span><span class="n">dictio</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">dictio</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">preds</span><span class="p">:</span>
                <span class="n">preds</span><span class="p">[</span><span class="n">dictio</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">delta</span><span class="p">[</span><span class="n">dictio</span><span class="p">[</span><span class="n">s</span><span class="p">]][</span><span class="n">dictio</span><span class="p">[</span><span class="n">s1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">s1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">dictio</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">preds</span><span class="p">:</span>
                    <span class="n">preds</span><span class="p">[</span><span class="n">dictio</span><span class="p">[</span><span class="n">s1</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dictio</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">preds</span><span class="p">[</span><span class="n">dictio</span><span class="p">[</span><span class="n">s1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">dictio</span><span class="p">[</span><span class="n">s</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span> <span class="o">=</span> <span class="n">preds</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="n">dictio</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]</span>
        <span class="n">Final</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">Final</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dictio</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="n">Final</span>
        <span class="n">states</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="n">states</span><span class="p">[</span><span class="n">dictio</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">states</span>
</div>
<div class="viewcode-block" id="GFA.eliminate"><a class="viewcode-back" href="../index.html#fa.GFA.eliminate">[docs]</a>    <span class="k">def</span> <span class="nf">eliminate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Eliminate a state.</span>

<span class="sd">        :param st: state to be eliminated</span>
<span class="sd">        :type st: int&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="ow">and</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">]:</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">][</span><span class="n">st</span><span class="p">],</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)))</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">][</span><span class="n">st</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">st</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">st</span><span class="p">])</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">st</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">]:</span>
                <span class="n">r3</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">][</span><span class="n">s1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">r2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r3</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">disj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">s1</span><span class="p">],</span> <span class="n">r</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="GFA.eliminateAll"><a class="viewcode-back" href="../index.html#fa.GFA.eliminateAll">[docs]</a>    <span class="k">def</span> <span class="nf">eliminateAll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Eliminate a list of states.</span>

<span class="sd">        :param lr: list of states indexes</span>
<span class="sd">        :type lr: list&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eliminate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="GFA.dup"><a class="viewcode-back" href="../index.html#fa.GFA.dup">[docs]</a>    <span class="k">def</span> <span class="nf">dup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a copy of a GFA</span>

<span class="sd">        :rtype: GFA&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">GFA</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">predecessors</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="GFA.normalize"><a class="viewcode-back" href="../index.html#fa.GFA.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a single initial and final state with Epsilon transitions.</span>

<span class="sd">        .. attention::</span>
<span class="sd">           works in place&quot;&quot;&quot;</span>
        <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;First&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>

        <span class="n">last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;Last&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">last</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">last</span><span class="p">])</span>

    <span class="c"># noinspection PyUnresolvedReferences</span></div>
    <span class="k">def</span> <span class="nf">_do_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">rp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Labels for testing if a automaton is SP. used by SPRegExp</span>

<span class="sd">        :param v1: state (node)</span>
<span class="sd">        :type v1: int</span>
<span class="sd">        :param t: a label</span>
<span class="sd">        :type t: SPlabel</span>
<span class="sd">        :param rp: regexp</span>
<span class="sd">        :type rp: regexp&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_index</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">v1</span><span class="p">][</span><span class="n">v2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">v1</span><span class="p">][</span><span class="n">v2</span><span class="p">],</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>

    <span class="c"># noinspection PyUnresolvedReferences</span>
    <span class="k">def</span> <span class="nf">_simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used by SPRegExp.</span>
<span class="sd">        :param v2:</span>
<span class="sd">        :param i:</span>
<span class="sd">        :return:</span>
<span class="sd">        :raise NotSP:&quot;&quot;&quot;</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">v2</span><span class="p">]:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span><span class="o">.</span><span class="n">val</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">size</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">]</span>
        <span class="n">vi</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">vo</span> <span class="ow">in</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">vi</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span><span class="o">.</span><span class="n">lastref</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">vo</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span><span class="o">.</span><span class="n">lastref</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">vi</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span><span class="o">.</span><span class="n">val</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">vo</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span><span class="o">.</span><span class="n">val</span><span class="p">()):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">vi</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span><span class="o">.</span><span class="n">val</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_index</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">vo</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">vi</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">vi</span><span class="p">][</span><span class="n">v2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">disj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">vo</span><span class="p">][</span><span class="n">v2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">vi</span><span class="p">][</span><span class="n">v2</span><span class="p">],</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_index</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">vi</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">[(</span><span class="n">vi</span><span class="p">,</span> <span class="n">v2</span><span class="p">)]</span><span class="o">.</span><span class="n">val</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">vi</span><span class="p">][</span><span class="n">v2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">v</span><span class="p">])[</span><span class="mi">0</span><span class="p">]][</span><span class="n">v</span><span class="p">],</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">vi</span><span class="p">][</span><span class="n">v2</span><span class="p">],</span>
                                                         <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">vo</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">raise</span> <span class="n">NotSP</span>

<div class="viewcode-block" id="GFA.DFS"><a class="viewcode-back" href="../index.html#fa.GFA.DFS">[docs]</a>    <span class="k">def</span> <span class="nf">DFS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">io</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Depth first search</span>

<span class="sd">        :param io:&quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfs_visit</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">io</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="GFA.dfs_visit"><a class="viewcode-back" href="../index.html#fa.GFA.dfs_visit">[docs]</a>    <span class="k">def</span> <span class="nf">dfs_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">io</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param s: state</span>
<span class="sd">        :param visited: list od states visited</span>
<span class="sd">        :param io:&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">dest</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                    <span class="c"># lists are unhashable</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="o">=</span> <span class="n">io</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                    <span class="n">io</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="o">=</span> <span class="n">io</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span>
                    <span class="n">io</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dfs_visit</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">io</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="GFA.weight"><a class="viewcode-back" href="../index.html#fa.GFA.weight">[docs]</a>    <span class="k">def</span> <span class="nf">weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the weight of a state based on a heuristic</span>

<span class="sd">        :param state: state</span>
<span class="sd">        :type state: int</span>
<span class="sd">        :returns: the weight of the state</span>
<span class="sd">        :rtype: int&quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">state</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">alphabeticLength</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">state</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">alphabeticLength</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">state</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">alphabeticLength</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">state</span><span class="p">])</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>
</div>
<div class="viewcode-block" id="GFA.weightWithCycles"><a class="viewcode-back" href="../index.html#fa.GFA.weightWithCycles">[docs]</a>    <span class="k">def</span> <span class="nf">weightWithCycles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">cycles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param state:</span>
<span class="sd">        :param cycles:</span>
<span class="sd">        :return:&quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">state</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">alphabeticLength</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">state</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">alphabeticLength</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">state</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">alphabeticLength</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">state</span><span class="p">])</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">*=</span> <span class="p">(</span><span class="n">cycles</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>
</div>
<div class="viewcode-block" id="GFA.deleteState"><a class="viewcode-back" href="../index.html#fa.GFA.deleteState">[docs]</a>    <span class="k">def</span> <span class="nf">deleteState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; deletes a state from the GFA</span>
<span class="sd">        :param sti:&quot;&quot;&quot;</span>
        <span class="n">newOrder</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">sti</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">newOrder</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">newOrder</span><span class="p">[</span><span class="n">sti</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">newOrder</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">st</span><span class="p">]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">st</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">st</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="GFA.eliminateState"><a class="viewcode-back" href="../index.html#fa.GFA.eliminateState">[docs]</a>    <span class="k">def</span> <span class="nf">eliminateState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Deletes a state and updates the automaton</span>

<span class="sd">        :param st: the state to be deleted</span>
<span class="sd">        :type st: state index</span>

<span class="sd">        .. attention:</span>
<span class="sd">           works in place&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">st</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">st</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">st</span><span class="p">:</span>
                    <span class="n">re</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">st</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">]:</span>
                        <span class="n">re</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">][</span><span class="n">st</span><span class="p">],</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                    <span class="n">re</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">re</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">disj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">re</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deleteState</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="GFA.completeDelta"><a class="viewcode-back" href="../index.html#fa.GFA.completeDelta">[docs]</a>    <span class="k">def</span> <span class="nf">completeDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds empty set transitions between the automatons final and initial states in order to make it complete.</span>
<span class="sd">        It&#39;s only meant to be used in the final stage of SEA...&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">emptyset</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="GFA.stateChildren"><a class="viewcode-back" href="../index.html#fa.GFA.stateChildren">[docs]</a>    <span class="k">def</span> <span class="nf">stateChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of children of a state</span>

<span class="sd">        :param strict: a state is never its own children even if a self loop is in place</span>
<span class="sd">        :param state: state id queried</span>
<span class="sd">        :type state: int</span>
<span class="sd">        :type strict: bool</span>
<span class="sd">        :returns: map: children -&gt; alphabetic length</span>
<span class="sd">        :rtype: dictionary&quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">l</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
            <span class="n">l</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">alphabeticLength</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">strict</span> <span class="ow">and</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">l</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">l</span>
</div>
    <span class="k">def</span> <span class="nf">_re0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">fi</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">fi</span><span class="p">][</span><span class="n">fi</span><span class="p">]</span>

        <span class="c"># bd*</span>
        <span class="n">re1</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="c"># a + bd*c</span>
        <span class="n">re2</span> <span class="o">=</span> <span class="n">reex</span><span class="o">.</span><span class="n">disj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">re1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="c"># (a + bd*c)* bd*</span>
        <span class="k">return</span> <span class="n">reex</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">reex</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">re2</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)),</span> <span class="n">re1</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>

    <span class="c"># noinspection PyUnresolvedReferences</span>
<div class="viewcode-block" id="GFA.assignNum"><a class="viewcode-back" href="../index.html#fa.GFA.assignNum">[docs]</a>    <span class="k">def</span> <span class="nf">assignNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param st:&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">assignNum</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="c"># noinspection PyUnresolvedReferences</span></div>
<div class="viewcode-block" id="GFA.assignLow"><a class="viewcode-back" href="../index.html#fa.GFA.assignLow">[docs]</a>    <span class="k">def</span> <span class="nf">assignLow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">st</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param st:&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">[</span><span class="n">st</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">[</span><span class="n">st</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">assignLow</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">st</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cuts</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">st</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">!=</span> <span class="n">d</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">st</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num</span><span class="p">[</span><span class="n">st</span><span class="p">]</span>


<span class="c"># noinspection PyTypeChecker</span></div></div>
<div class="viewcode-block" id="SSemiGroup"><a class="viewcode-back" href="../index.html#fa.SSemiGroup">[docs]</a><span class="k">class</span> <span class="nc">SSemiGroup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class support for the Syntactic SemiGroup.</span>

<span class="sd">    :var elements: list of tuples representing the transformations</span>
<span class="sd">    :var words: a list of pairs (index of the prefix transformation, index of the suffix char)</span>
<span class="sd">    :var gen: a list of the max index of each generation</span>
<span class="sd">    :var Sigma: set of symbols&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">words</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gen</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Monoid</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Size of the semigroup</span>

<span class="sd">        :return: size of the semigroup</span>
<span class="sd">        :rtype: int &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;SSemiGroup representation</span>

<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="s">&quot;Semigroup:</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="n">foo</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> </span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">foo</span>

<div class="viewcode-block" id="SSemiGroup.WordI"><a class="viewcode-back" href="../index.html#fa.SSemiGroup.WordI">[docs]</a>    <span class="k">def</span> <span class="nf">WordI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Representative of an element given as index</span>

<span class="sd">        :arg i: index of the element</span>
<span class="sd">        :type i: int</span>
<span class="sd">        :returns: the first word originating the element</span>
<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">WordPS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="SSemiGroup.WordPS"><a class="viewcode-back" href="../index.html#fa.SSemiGroup.WordPS">[docs]</a>    <span class="k">def</span> <span class="nf">WordPS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pref</span><span class="p">,</span> <span class="n">sym</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Representative of an element given as prefix symb</span>

<span class="sd">        :arg pref: prefix index</span>
<span class="sd">        :type pref: int</span>
<span class="sd">        :arg sym: symbol index</span>
<span class="sd">        :type sym: int</span>
<span class="sd">        :returns: word</span>
<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pref</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">sym</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">WordPS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">words</span><span class="p">[</span><span class="n">pref</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">words</span><span class="p">[</span><span class="n">pref</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="n">sym</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="SSemiGroup.add"><a class="viewcode-back" href="../index.html#fa.SSemiGroup.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">pref</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">tmpLists</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to add a new transformation to the monoid</span>

<span class="sd">        :arg tr: transformation</span>
<span class="sd">        :type tr: tuple of int</span>
<span class="sd">        :arg pref: prefix of the generating word</span>
<span class="sd">        :type pref: int or None</span>
<span class="sd">        :arg sym: suffix symbol</span>
<span class="sd">        :type sym: int</span>
<span class="sd">        :arg tmpLists: this generation lists</span>
<span class="sd">        :type tmpLists: pairs of lists as (elements,words)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="ow">and</span> <span class="n">tr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tmpLists</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">tmpLists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
            <span class="n">tmpLists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pref</span><span class="p">,</span> <span class="n">sym</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tmpLists</span>
</div>
<div class="viewcode-block" id="SSemiGroup.addGen"><a class="viewcode-back" href="../index.html#fa.SSemiGroup.addGen">[docs]</a>    <span class="k">def</span> <span class="nf">addGen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmpLists</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new generation to the monoid</span>

<span class="sd">        :arg tmpLists: the new generation data</span>
<span class="sd">        :type tmpLists: pair of lists as (elements, words)&quot;&quot;&quot;</span>
        <span class="n">gn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmpLists</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">+=</span> <span class="n">tmpLists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">words</span> <span class="o">+=</span> <span class="n">tmpLists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">gn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gn</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="EnumL"><a class="viewcode-back" href="../index.html#fa.EnumL">[docs]</a><span class="k">class</span> <span class="nc">EnumL</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c"># noinspection PyUnresolvedReferences</span>
    <span class="sd">&quot;&quot;&quot;Class for enumerate FA languages</span>

<span class="sd">        :var aut: Automaton of the language</span>
<span class="sd">        :type aut: DFA</span>
<span class="sd">        :var tmin: table for minimal words for each s in aut.States</span>
<span class="sd">        :type tmin: dict</span>
<span class="sd">        :var Words: list of words (if stored)</span>
<span class="sd">        :type Words: list</span>
<span class="sd">        :var Sigma: alphabet</span>
<span class="sd">        :type Sigma: list</span>
<span class="sd">        :type stack: deque</span>

<span class="sd">        .. versionadded:: 0.9.8</span>

<span class="sd">        .. seealso::</span>
<span class="sd">            Efficient enumeration of words in regular languages, M. Ackerman and J. Shallit,</span>
<span class="sd">            Theor. Comput. Sci. 410, 37, pp 3461-3470. 2009.</span>
<span class="sd">            http://dx.doi.org/10.1016/j.tcs.2009.03.018&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aut</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aut</span> <span class="o">=</span> <span class="n">aut</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Words</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">aut</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initStack</span><span class="p">()</span>

    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="EnumL.initStack"><a class="viewcode-back" href="../index.html#fa.EnumL.initStack">[docs]</a>    <span class="k">def</span> <span class="nf">initStack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Abstract method&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="EnumL.minWordT"><a class="viewcode-back" href="../index.html#fa.EnumL.minWordT">[docs]</a>    <span class="k">def</span> <span class="nf">minWordT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Abstract method</span>
<span class="sd">        :param n:</span>
<span class="sd">        :type n: int&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="EnumL.minWord"><a class="viewcode-back" href="../index.html#fa.EnumL.minWord">[docs]</a>    <span class="k">def</span> <span class="nf">minWord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the minimal word of length m accepted by the automaton</span>
<span class="sd">        :param m:</span>
<span class="sd">        :type m: int&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minWordT</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;&quot;</span>
        <span class="n">possiblew</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span> <span class="ow">and</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">[</span><span class="n">q</span><span class="p">]]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">possiblew</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">possiblew</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="EnumL.iCompleteP"><a class="viewcode-back" href="../index.html#fa.EnumL.iCompleteP">[docs]</a>    <span class="k">def</span> <span class="nf">iCompleteP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if state q is i-complete</span>

<span class="sd">        :param i: int</span>
<span class="sd">        :type i: int</span>
<span class="sd">        :param q: state index</span>
<span class="sd">        :type q: int&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
</div>
    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="EnumL.fillStack"><a class="viewcode-back" href="../index.html#fa.EnumL.fillStack">[docs]</a>    <span class="k">def</span> <span class="nf">fillStack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Abstract method</span>
<span class="sd">        :param w:</span>
<span class="sd">        :type w: str&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@abstractmethod</span>
<div class="viewcode-block" id="EnumL.nextWord"><a class="viewcode-back" href="../index.html#fa.EnumL.nextWord">[docs]</a>    <span class="k">def</span> <span class="nf">nextWord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Abstract method</span>
<span class="sd">        :param w:</span>
<span class="sd">        :type w: str&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="EnumL.enumCrossSection"><a class="viewcode-back" href="../index.html#fa.EnumL.enumCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">enumCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Enumerates the nth cross-section of L(A)</span>

<span class="sd">        :param n: nonnegative integer</span>
<span class="sd">        :type n: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initStack</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Words</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minWord</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fillStack</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Words</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nextWord</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initStack</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="EnumL.enum"><a class="viewcode-back" href="../index.html#fa.EnumL.enum">[docs]</a>    <span class="k">def</span> <span class="nf">enum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enumerates the first m words of L(A) according to the lexicographic order if there are at least m words.</span>
<span class="sd">        Otherwise, enumerates all words accepted by A.</span>

<span class="sd">        :param m:</span>
<span class="sd">        :type m: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lim</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">numCEC</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="p">,</span> <span class="n">DFA</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">Initial</span><span class="p">))</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="p">,</span> <span class="n">NFA</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">Initial</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">Final</span><span class="p">))):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Words</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">numCEC</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Words</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">numCEC</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initStack</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minWord</span><span class="p">(</span><span class="n">lim</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">numCEC</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numCEC</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Words</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fillStack</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nextWord</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">lim</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initStack</span><span class="p">()</span>

</div></div>
<span class="k">class</span> <span class="nc">EnumDFA</span><span class="p">(</span><span class="n">EnumL</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for enumerating languages defined by DFAs&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">minWordT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes for each state the minimal word of length i&lt;n</span>
<span class="sd">        accepted by the automaton. Stores the values in tmin</span>

<span class="sd">        :param n: length of the word</span>
<span class="sd">        :type n: integer</span>

<span class="sd">        .. note:: Makinen algorithm for DFAs&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span> <span class="ow">and</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sym</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{})[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span>
                    <span class="k">break</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="p">)):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">[</span><span class="n">q</span><span class="p">]:</span>
                                <span class="n">m</span> <span class="o">=</span> <span class="n">sym</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                                <span class="k">break</span>
                                <span class="c"># if nfa compare with others</span>
                                <span class="c"># if m == None or sym+  self.tmin[q][j-1] &lt; min</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>

    <span class="k">def</span> <span class="nf">fillStack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes S_1,...,S_n-1 where S_i is the set of (n-i)-complete states reachable from S_i-1</span>

<span class="sd">        :param w: word&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initStack</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({})</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span> <span class="ow">and</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">iCompleteP</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">w</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]):</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">w</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">initStack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the stack with initial states &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([{</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">Initial</span><span class="p">}])</span>

    <span class="k">def</span> <span class="nf">nextWord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given an word, returns next word on the nth cross-section of L(aut)</span>
<span class="sd">        according to the radix order</span>

<span class="sd">        :param w: word</span>
<span class="sd">        :type w: str</span>
<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iCompleteP</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">sym</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sym</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">sym</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span>
                                    <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span>
                                <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iCompleteP</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">b</span><span class="p">]):</span>
                            <span class="n">s1</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">b</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
                <span class="n">mw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minWord</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">mw</span>
        <span class="k">return</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">EnumNFA</span><span class="p">(</span><span class="n">EnumL</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for enumerating languages defined by NFAs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">initStack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the stack with initial states</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">Initial</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">minWordT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes for each state the minimal word of length i &lt;= n</span>
<span class="sd">        accepted by the automaton. Stores the values in tmin.</span>

<span class="sd">        :param n: length of the word</span>
<span class="sd">        :type n: integer</span>

<span class="sd">        .. note: Makinen algorithm for NFAs&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span> <span class="ow">and</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">Final</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{})[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span>
                        <span class="k">break</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="p">)):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sym</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">[</span><span class="n">q</span><span class="p">]:</span>
                                    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">sym</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
                                        <span class="n">m</span> <span class="o">=</span> <span class="n">sym</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{})[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>

    <span class="k">def</span> <span class="nf">fillStack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes S_1,...,S_n-1 where S_i is the set of</span>
<span class="sd">        (n-i)-complete states reachable from S_i-1</span>

<span class="sd">        :param w: word&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initStack</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span> <span class="ow">and</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">w</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iCompleteP</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
                            <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nextWord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given an word, returns next word in the the nth cross-section of L(aut)</span>
<span class="sd">        according to the radix order</span>

<span class="sd">        :param w: word</span>
<span class="sd">        :type w: str&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">sym</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iCompleteP</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
                                    <span class="k">if</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sym</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">sym</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span>
                                            <span class="n">b</span> <span class="o">=</span> <span class="n">sym</span>
                                        <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">b</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iCompleteP</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
                                <span class="n">s1</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
                <span class="n">mw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minWord</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">mw</span>
        <span class="k">return</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">equivalentP</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Verifies if the two languages given by some representative (DFA, NFA or re) are equivalent</span>

<span class="sd">    :arg first: language</span>
<span class="sd">    :arg second: language</span>
<span class="sd">    :rtype: bool</span>

<span class="sd">    .. versionadded:: 0.9.6&quot;&quot;&quot;</span>
    <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">second</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">reex</span><span class="o">.</span><span class="n">regexp</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">reex</span><span class="o">.</span><span class="n">regexp</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="n">equivalentP</span><span class="p">(</span><span class="n">second</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">t1</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">DFA</span><span class="p">()):</span>
        <span class="k">return</span> <span class="n">first</span> <span class="o">==</span> <span class="n">second</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">t1</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">NFA</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">t2</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">DFA</span><span class="p">()):</span>
            <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span> <span class="o">==</span> <span class="n">second</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first</span> <span class="o">==</span> <span class="n">second</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">t2</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">NFA</span><span class="p">()):</span>
            <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()</span> <span class="o">==</span> <span class="n">second</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span> <span class="o">==</span> <span class="n">second</span>


<div class="viewcode-block" id="stringToDFA"><a class="viewcode-back" href="../index.html#fa.stringToDFA">[docs]</a><span class="k">def</span> <span class="nf">stringToDFA</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Converts a string icdfa&#39;s representation to dfa.</span>

<span class="sd">    :param s: canonical string representation</span>
<span class="sd">    :type s: list</span>
<span class="sd">    :param f: bit map of final states</span>
<span class="sd">    :type f: list</span>
<span class="sd">    :param n: number of states</span>
<span class="sd">    :type n: int</span>
<span class="sd">    :param k: number of symbols</span>
<span class="sd">    :type k: int</span>
<span class="sd">    :returns: a complete dfa with Sigma [``k``], States [``n``]</span>
<span class="sd">    :rtype: DFA</span>

<span class="sd">    .. versionchanged:: 0.9.8 symbols are converted to str&quot;&quot;&quot;</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
    <span class="n">fa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">([])</span>
    <span class="n">fa</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">fa</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">fa</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">fa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">k</span><span class="p">),</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">fa</span>

</div>
<span class="k">def</span> <span class="nf">_cmpPair2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Auxiliary comparision for sorting lists of pairs. Sorting on the second member of the pair.&quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">w</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">_normalizePair</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pair</span>


<span class="k">def</span> <span class="nf">_sortWithNone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">elif</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_deref</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">mp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_deref</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">mp</span><span class="p">[</span><span class="n">val</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">_dictGetKeyFromValue</span><span class="p">(</span><span class="n">elm</span><span class="p">,</span> <span class="n">dic</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dic</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">elm</span> <span class="ow">in</span> <span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">key</span>


<span class="k">def</span> <span class="nf">statePP</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pretty print state</span>

<span class="sd">    :param state:</span>
<span class="sd">    :return:&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_spp</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">copy</span><span class="p">(</span><span class="n">st</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">bar</span> <span class="o">=</span> <span class="s">&quot;(&quot;</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
                <span class="n">bar</span> <span class="o">+=</span> <span class="n">_spp</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span>
            <span class="k">return</span> <span class="n">bar</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="nb">set</span><span class="p">:</span>
            <span class="n">bar</span> <span class="o">=</span> <span class="s">&quot;{&quot;</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
                <span class="n">bar</span> <span class="o">+=</span> <span class="n">_spp</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span>
            <span class="k">return</span> <span class="n">bar</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot;}&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>

    <span class="n">foo</span> <span class="o">=</span> <span class="n">_spp</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="n">foo</span> <span class="o">+</span> <span class="s">&#39;&quot;&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">foo</span>


<div class="viewcode-block" id="saveToString"><a class="viewcode-back" href="../index.html#fa.saveToString">[docs]</a><span class="k">def</span> <span class="nf">saveToString</span><span class="p">(</span><span class="n">aut</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&quot;&amp;&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finite automata definition as a string using the input format.</span>

<span class="sd">    .. versionadded:: 0.9.5</span>
<span class="sd">    .. versionchanged:: 0.9.6 Names are now used instead of indexes.</span>
<span class="sd">    .. versionchanged:: 0.9.7 New format with quotes and alphabet</span>

<span class="sd">    :param aut: the FA</span>
<span class="sd">    :type aut: FA</span>
<span class="sd">    :arg sep: separation between `lines`</span>
<span class="sd">    :type sep: str</span>
<span class="sd">    :returns: the representation</span>
<span class="sd">    :rtype: str &quot;&quot;&quot;</span>
    <span class="n">buff</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">aut</span><span class="o">.</span><span class="n">Initial</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&quot;Error: no initial state defined&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aut</span><span class="p">,</span> <span class="n">DFA</span><span class="p">):</span>
        <span class="n">buff</span> <span class="o">+=</span> <span class="s">&quot;@DFA &quot;</span>
        <span class="n">NFAp</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aut</span><span class="p">,</span> <span class="n">NFA</span><span class="p">):</span>
        <span class="n">buff</span> <span class="o">+=</span> <span class="s">&quot;@NFA &quot;</span>
        <span class="n">NFAp</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">DFAerror</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">NFAp</span> <span class="ow">and</span> <span class="n">aut</span><span class="o">.</span><span class="n">Initial</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">aut</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="n">aut</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">aut</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
        <span class="n">buff</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;{0:&gt;s} &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">statePP</span><span class="p">(</span><span class="n">aut</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sf</span><span class="p">])))</span>
    <span class="k">if</span> <span class="n">NFAp</span><span class="p">:</span>
        <span class="n">buff</span> <span class="o">+=</span> <span class="s">&quot; * &quot;</span>
        <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">aut</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">buff</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;{0:&gt;s} &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">statePP</span><span class="p">(</span><span class="n">aut</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sf</span><span class="p">])))</span>
    <span class="n">buff</span> <span class="o">+=</span> <span class="n">sep</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aut</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">a</span><span class="p">],</span> <span class="nb">set</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">a</span><span class="p">]:</span>
                        <span class="n">buff</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;{0:&gt;s} {1:&gt;s} {2:&gt;s}{3:&gt;s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">statePP</span><span class="p">(</span><span class="n">aut</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">s</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
                                                                     <span class="n">statePP</span><span class="p">(</span><span class="n">aut</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">s1</span><span class="p">]),</span> <span class="n">sep</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">buff</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;{0:&gt;s} {1:&gt;s} {2:&gt;s}{3:&gt;s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">statePP</span><span class="p">(</span><span class="n">aut</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">s</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
                                                                 <span class="n">statePP</span><span class="p">(</span><span class="n">aut</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">a</span><span class="p">]]),</span> <span class="n">sep</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">buff</span> <span class="o">+=</span> <span class="s">&quot;{0:&gt;s} {1:&gt;s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">statePP</span><span class="p">(</span><span class="n">aut</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">s</span><span class="p">]),</span> <span class="n">sep</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">buff</span>

</div>
<span class="k">def</span> <span class="nf">sConcat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Concat words</span>

<span class="sd">    :param x: first word</span>
<span class="sd">    :param y: second word</span>
<span class="sd">    :return: concatenation word&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">y</span>
    <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">sigmaStarDFA</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a alphabet S returns the minimal DFA for S*</span>

<span class="sd">    :param sigma: set of symbols</span>
<span class="sd">    :return: DFA</span>

<span class="sd">    .. versionadded:: 1.2&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">DFA</span><span class="p">()</span>
    <span class="n">d</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
    <span class="n">d</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">d</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
        <span class="n">d</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span> <span class="nf">_addPool</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Adds to a pool with exception list</span>

<span class="sd">    :param pool: pool to be added</span>
<span class="sd">    :type pool: set</span>
<span class="sd">    :param done: exception list</span>
<span class="sd">    :type done: set</span>
<span class="sd">    :param val: value&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_initPool</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Initialize pool structure</span>

<span class="sd">    :return: pool and done objects</span>
<span class="sd">    :rtype: tuple&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">FAdo 1.2 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 1999-2014, Rogério Reis &amp; Nelma Moreira.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>transducers &mdash; FAdo 1.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="FAdo 1.2 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">FAdo 1.2 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for transducers</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;**Finite Tranducer Support**</span>

<span class="sd">Transducer manipulation.</span>

<span class="sd">.. versionadded:: 1.0</span>

<span class="sd">.. *Authors:* Rogério Reis, Nelma Moreira &amp; Stavros Konstantinidis</span>

<span class="sd">.. *This is part of FAdo project*   http://fado.dcc.fc.up.pt.</span>

<span class="sd">.. *Copyright:* 1999-2014 Rogério Reis &amp; Nelma Moreira {rvr,nam}@dcc.fc.up.pt</span>

<span class="sd">.. This program is free software; you can redistribute it and/or</span>
<span class="sd">   modify it under the terms of the GNU General Public License as published</span>
<span class="sd">   by the Free Software Foundation; either version 2 of the License, or</span>
<span class="sd">   (at your option) any later version.</span>

<span class="sd">   This program is distributed in the hope that it will be useful,</span>
<span class="sd">   but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="sd">   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="sd">   for more details.</span>

<span class="sd">   You should have received a copy of the GNU General Public License along</span>
<span class="sd">   with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="sd">   675 Mass Ave, Cambridge, MA 02139, USA.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">exceptions</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">fa</span>
<span class="kn">import</span> <span class="nn">common</span>
<span class="kn">from</span> <span class="nn">common</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">fl</span>


<span class="k">class</span> <span class="nc">ZERO</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple exception for functionality testing algorithm&quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">_concat</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">concatN</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Concatenation of tuples of words</span>
<span class="sd">    :param x: iterable</span>
<span class="sd">    :param y: iterable</span>
<span class="sd">    :return: iterable&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">_concat</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)])</span>


<span class="k">def</span> <span class="nf">isLimitExceed</span><span class="p">(</span><span class="n">NFA0Delta</span><span class="p">,</span> <span class="n">NFA1Delta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decide if the size of NFA0 and NFA1 exceed the limit.</span>

<span class="sd">    Size of NFA0 is denoted as N, and size of NFA1 is denoted as M. If N*N*M exceeds 1000000, return False,</span>
<span class="sd">    else return True. If bothNFA is False, then NFA0 should be NFA, and NFA1 should be Transducer. If both NFA is</span>
<span class="sd">    True, then NFA0 and NFA1 are both NFAs.</span>

<span class="sd">    :param dict NFA0Delta: NFA0&#39;s transition Delta</span>
<span class="sd">    :param dict NFA1Delta: NFA1&#39;s transition Delta</span>
<span class="sd">    :rtype: bool&quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">NFA0Delta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">NFA0Delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
            <span class="n">N</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NFA0Delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">s1</span><span class="p">])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">NFA1Delta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">NFA1Delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
            <span class="n">M</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">NFA1Delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">s1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">M</span> <span class="o">&gt;</span> <span class="mi">1000000</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>


<div class="viewcode-block" id="Transducer"><a class="viewcode-back" href="../index.html#transducers.Transducer">[docs]</a><span class="k">class</span> <span class="nc">Transducer</span><span class="p">(</span><span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for Transducers</span>

<span class="sd">    .. inheritance-diagram:: Transducer&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Transducer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Output</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<div class="viewcode-block" id="Transducer.succintTransitions"><a class="viewcode-back" href="../index.html#transducers.Transducer.succintTransitions">[docs]</a>    <span class="k">def</span> <span class="nf">succintTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Collects the transition information in a concat way suitable for graphical representation.</span>
<span class="sd">        :rtype: list of tupples&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">oc</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
                        <span class="n">foo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">foo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">oc</span><span class="p">))</span>
        <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">foo</span><span class="p">:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="n">foo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;{0:s}/{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">graphvizTranslate</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])),</span> <span class="n">graphvizTranslate</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])))</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;, {0:s}/{1:s}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">graphvizTranslate</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">graphvizTranslate</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">l</span>
</div>
<div class="viewcode-block" id="Transducer.setOutput"><a class="viewcode-back" href="../index.html#transducers.Transducer.setOutput">[docs]</a>    <span class="k">def</span> <span class="nf">setOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listOfSymbols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set Output</span>

<span class="sd">        :param set|list listOfSymbols: output symbols&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Output</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">listOfSymbols</span><span class="p">))</span>

</div></div>
<span class="k">class</span> <span class="nc">GFT</span><span class="p">(</span><span class="n">Transducer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;General Form Transducer</span>

<span class="sd">    .. inheritance-diagram:: GFT&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GFT</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Output</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string representing the details of the current transducer instance.</span>

<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string adding type &#39;Transducer&#39; in front of the representation</span>

<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&#39;Transducer(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">addTransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stsrc</span><span class="p">,</span> <span class="n">wi</span><span class="p">,</span> <span class="n">wo</span><span class="p">,</span> <span class="n">sti2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a new transition</span>

<span class="sd">        :param int stsrc: state index of departure</span>
<span class="sd">        :param int sti2: state index of arrival</span>
<span class="sd">        :param str wi: word consumed</span>
<span class="sd">        :param str wo: word outputed&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">wi</span> <span class="o">!=</span> <span class="n">Epsilon</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">wi</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wo</span> <span class="o">!=</span> <span class="n">Epsilon</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">wo</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Output</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stsrc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">stsrc</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">wi</span><span class="p">:</span> <span class="p">{(</span><span class="n">wo</span><span class="p">,</span> <span class="n">sti2</span><span class="p">)}}</span>
        <span class="k">elif</span> <span class="n">wi</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">stsrc</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">stsrc</span><span class="p">][</span><span class="n">wi</span><span class="p">]</span> <span class="o">=</span> <span class="p">{(</span><span class="n">wo</span><span class="p">,</span> <span class="n">sti2</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">stsrc</span><span class="p">][</span><span class="n">wi</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">wo</span><span class="p">,</span> <span class="n">sti2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">toSFT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conversion to an equivalent SFT</span>

<span class="sd">        rtype: SFT &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Output</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Output</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setFinal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">st1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">wi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st1</span><span class="p">]:</span>
                <span class="n">cst</span> <span class="o">=</span> <span class="n">st1</span>
                <span class="k">if</span> <span class="n">wi</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">st2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st1</span><span class="p">][</span><span class="n">wi</span><span class="p">]:</span>
                        <span class="n">lst</span> <span class="o">=</span> <span class="n">st2</span>
                        <span class="k">if</span> <span class="n">wo</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">cst</span><span class="p">,</span> <span class="n">wi</span><span class="p">,</span> <span class="n">wo</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">wo</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="n">mst</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
                                <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">cst</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mst</span><span class="p">)</span>
                                <span class="n">cst</span> <span class="o">=</span> <span class="n">mst</span>
                            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">cst</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">wo</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">lst</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">st2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">st1</span><span class="p">][</span><span class="n">wi</span><span class="p">]:</span>
                        <span class="n">lst</span> <span class="o">=</span> <span class="n">st2</span>
                        <span class="k">if</span> <span class="n">wo</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">wi</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="n">mst</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
                                <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">cst</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">mst</span><span class="p">)</span>
                                <span class="n">cst</span> <span class="o">=</span> <span class="n">mst</span>
                            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">cst</span><span class="p">,</span> <span class="n">wi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">z</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">wi</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
                            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span>
                            <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wo</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
                                <span class="n">z</span> <span class="o">+=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">wi</span><span class="p">[</span><span class="n">m</span><span class="p">:],</span> <span class="p">[</span><span class="n">Epsilon</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">))</span>
                            <span class="k">elif</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
                                <span class="n">z</span> <span class="o">+=</span> <span class="nb">zip</span><span class="p">([</span><span class="n">Epsilon</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">n</span><span class="p">),</span> <span class="n">wo</span><span class="p">[</span><span class="n">n</span><span class="p">:])</span>
                            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                            <span class="k">for</span> <span class="p">(</span><span class="n">symi</span><span class="p">,</span> <span class="n">symo</span><span class="p">)</span> <span class="ow">in</span> <span class="n">z</span><span class="p">[:</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                                <span class="n">mst</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
                                <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">cst</span><span class="p">,</span> <span class="n">symi</span><span class="p">,</span> <span class="n">symo</span><span class="p">,</span> <span class="n">mst</span><span class="p">)</span>
                                <span class="n">cst</span> <span class="o">=</span> <span class="n">mst</span>
                            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">cst</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">lst</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">listOfTransitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Collects into a sorted list the transitions of the transducer.</span>
<span class="sd">        :param GFT t</span>
<span class="sd">        :rtype: set of tuples&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_comp</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
            <span class="p">(</span><span class="n">v11</span><span class="p">,</span> <span class="n">v12</span><span class="p">,</span> <span class="n">v13</span><span class="p">,</span> <span class="n">v14</span><span class="p">)</span> <span class="o">=</span> <span class="n">v1</span>
            <span class="p">(</span><span class="n">v21</span><span class="p">,</span> <span class="n">v22</span><span class="p">,</span> <span class="n">v23</span><span class="p">,</span> <span class="n">v24</span><span class="p">)</span> <span class="o">=</span> <span class="n">v2</span>
            <span class="k">if</span> <span class="n">v11</span> <span class="o">&lt;</span> <span class="n">v21</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">v11</span> <span class="o">&gt;</span> <span class="n">v21</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">v12</span> <span class="o">&lt;</span> <span class="n">v22</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">v12</span> <span class="o">&gt;</span> <span class="n">v22</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">v13</span> <span class="o">&lt;</span> <span class="n">v23</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">v13</span> <span class="o">&gt;</span> <span class="n">v23</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">trList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">oc</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="n">trList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">oc</span><span class="p">,</span> <span class="n">s1</span><span class="p">))</span>
        <span class="n">trList</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">_comp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trList</span>

    <span class="k">def</span> <span class="nf">codeOfTransducer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Appends into one string the codes of the alphabets and initial and final</span>
<span class="sd">        state sets and the set of transitions</span>
<span class="sd">        :param GFT t</span>
<span class="sd">        :rtype: tuple&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_codeOfSet</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Collects into a sorted list the elements of the set S and then</span>
<span class="sd">                returns the string representation of the list. The set S normally</span>
<span class="sd">                consists of integers or strings</span>
<span class="sd">            :param set S</span>
<span class="sd">            :rtype: str&quot;&quot;&quot;</span>
            <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">S</span><span class="p">]</span>
            <span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="s">&#39;GFT&#39;</span><span class="p">,</span> <span class="n">_codeOfSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span> <span class="o">+</span> <span class="n">_codeOfSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Output</span><span class="p">)</span> <span class="o">+</span> <span class="n">_codeOfSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span> <span class="o">+</span>\
               <span class="n">_codeOfSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listOfTransitions</span><span class="p">()))</span>


<div class="viewcode-block" id="SFT"><a class="viewcode-back" href="../index.html#transducers.SFT">[docs]</a><span class="k">class</span> <span class="nc">SFT</span><span class="p">(</span><span class="n">GFT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Standard Form Tranducer</span>

<span class="sd">    :var set Output: output alphabet</span>

<span class="sd">    .. inheritance-diagram:: SFT&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string representing the details of the current transducer instance.</span>

<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string adding type &#39;Transducer&#39;in front of the representation</span>

<span class="sd">        :rtype: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&#39;SFT(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>

<div class="viewcode-block" id="SFT.dup"><a class="viewcode-back" href="../index.html#transducers.SFT.dup">[docs]</a>    <span class="k">def</span> <span class="nf">dup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Duplicate of itself</span>
<span class="sd">        :rtype: SFT</span>

<span class="sd">        .. attention::</span>
<span class="sd">           only duplicates the initially connected component&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">syi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">si</span><span class="p">]:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">syo</span><span class="p">,</span> <span class="n">so</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">si</span><span class="p">][</span><span class="n">syi</span><span class="p">]:</span>
                    <span class="n">i1</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">si</span><span class="p">],</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">i2</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">so</span><span class="p">],</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">syi</span><span class="p">,</span> <span class="n">syo</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">si</span><span class="p">])</span>
            <span class="k">except</span> <span class="n">common</span><span class="o">.</span><span class="n">DFAstateUnknown</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">si</span><span class="p">])</span>
            <span class="k">except</span> <span class="n">common</span><span class="o">.</span><span class="n">DFAstateUnknown</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="SFT.deleteStates"><a class="viewcode-back" href="../index.html#transducers.SFT.deleteStates">[docs]</a>    <span class="k">def</span> <span class="nf">deleteStates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lstates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete given iterable collection of states from the automaton.</span>

<span class="sd">        :param set|list lstates: collection of int representing states&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lstates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deleteState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="SFT.deleteState"><a class="viewcode-back" href="../index.html#transducers.SFT.deleteState">[docs]</a>    <span class="k">def</span> <span class="nf">deleteState</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove given state and transitions related with that state.</span>

<span class="sd">        :param int sti: index of the state to be removed</span>
<span class="sd">        :raises DFAstateUnknown: if state index does not exist&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sti</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DFAstateUnknown</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_deleteRefInDelta</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">sti</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleteRefInitial</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sti</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">sti</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="SFT.toSFT"><a class="viewcode-back" href="../index.html#transducers.SFT.toSFT">[docs]</a>    <span class="k">def</span> <span class="nf">toSFT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pacifying rule</span>

<span class="sd">        :rtype: SFT&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="SFT.toNFT"><a class="viewcode-back" href="../index.html#transducers.SFT.toNFT">[docs]</a>    <span class="k">def</span> <span class="nf">toNFT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Transformation into Nomal Form Transducer</span>

<span class="sd">        :rtype: NFT&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">NFT</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Output</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalP</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">syo</span><span class="p">,</span> <span class="n">so</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sy</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">sy</span> <span class="o">==</span> <span class="n">Epsilon</span> <span class="ow">or</span> <span class="n">syo</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                        <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">syo</span><span class="p">,</span> <span class="n">so</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ns</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
                        <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
                        <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">syo</span><span class="p">,</span> <span class="n">so</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
    <span class="k">def</span> <span class="nf">_deleteRefInDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletion of a reference in Delta</span>

<span class="sd">        :param int src: source state</span>
<span class="sd">        :param int sym: symbol</span>
<span class="sd">        :param int dest: destination state&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span> <span class="k">if</span> <span class="n">s2</span> <span class="o">&lt;</span> <span class="n">dest</span><span class="p">]</span>
        <span class="n">bar</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span> <span class="k">if</span> <span class="n">s2</span> <span class="o">&gt;</span> <span class="n">dest</span><span class="p">]</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">foo</span> <span class="o">+</span> <span class="n">bar</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ff</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">]:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">ff</span>

<div class="viewcode-block" id="SFT.delTransition"><a class="viewcode-back" href="../index.html#transducers.SFT.delTransition">[docs]</a>    <span class="k">def</span> <span class="nf">delTransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sti1</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">symo</span><span class="p">,</span> <span class="n">sti2</span><span class="p">,</span> <span class="n">_no_check</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove a transition if existing and perform cleanup on the transition function&#39;s internal data structure.</span>

<span class="sd">        :param symo: symbol output</span>
<span class="sd">        :param int sti1: state index of departure</span>
<span class="sd">        :param int sti2: state index of arrival</span>
<span class="sd">        :param sym: symbol consumed</span>
<span class="sd">        :param bool _no_check: dismiss secure code&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sym</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">symo</span><span class="p">,</span> <span class="n">sti2</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sym</span><span class="p">]:</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">][</span><span class="n">sym</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">]:</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti1</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="SFT.trim"><a class="viewcode-back" href="../index.html#transducers.SFT.trim">[docs]</a>    <span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove states that do not lead to a final state, or, inclusively,</span>
<span class="sd">        that can&#39;t be reached from the initial state. Only useful states</span>
<span class="sd">        remain.</span>

<span class="sd">        .. attention::</span>
<span class="sd">           in place transformation&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toInNFA</span><span class="p">()</span>
        <span class="n">n</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">States</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deleteStates</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="SFT.addTransitionQ"><a class="viewcode-back" href="../index.html#transducers.SFT.addTransitionQ">[docs]</a>    <span class="k">def</span> <span class="nf">addTransitionQ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">futQ</span><span class="p">,</span> <span class="n">pastQ</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add transition to the new transducer instance.</span>

<span class="sd">        :param src: source state</span>
<span class="sd">        :param dest: destination state</span>
<span class="sd">        :param sym: symbol</span>
<span class="sd">        :param out: output</span>
<span class="sd">        :param set futQ: queue for later</span>
<span class="sd">        :param set pastQ: past queue&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pastQ</span><span class="p">:</span>
            <span class="n">futQ</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SFT.outputS"><a class="viewcode-back" href="../index.html#transducers.SFT.outputS">[docs]</a>    <span class="k">def</span> <span class="nf">outputS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Output label coming out of the state i</span>

<span class="sd">        :param int s: index state</span>
<span class="sd">        :rtype: set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">[])]</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">z</span><span class="p">]}</span>
</div>
<div class="viewcode-block" id="SFT.setInitial"><a class="viewcode-back" href="../index.html#transducers.SFT.setInitial">[docs]</a>    <span class="k">def</span> <span class="nf">setInitial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the initial state of a Transducer</span>

<span class="sd">        :param list sts: list of states&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sts</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SFT.addOutput"><a class="viewcode-back" href="../index.html#transducers.SFT.addOutput">[docs]</a>    <span class="k">def</span> <span class="nf">addOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sym</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new symbol to the output alphabet</span>

<span class="sd">        There is no problem with duplicate symbols because Output is a Set. No symbol Epsilon can be added</span>

<span class="sd">        :param str sym: symbol or regular expression to be added&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">common</span><span class="o">.</span><span class="n">DFAepsilonRedefinition</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Output</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SFT.addTransition"><a class="viewcode-back" href="../index.html#transducers.SFT.addTransition">[docs]</a>    <span class="k">def</span> <span class="nf">addTransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stsrc</span><span class="p">,</span> <span class="n">symi</span><span class="p">,</span> <span class="n">symo</span><span class="p">,</span> <span class="n">sti2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a new transition</span>

<span class="sd">        :param int stsrc: state index of departure</span>
<span class="sd">        :param int sti2: state index of arrival</span>
<span class="sd">        :param str symi: symbol consumed</span>
<span class="sd">        :param str symo: symbol output&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">symi</span> <span class="o">!=</span> <span class="n">Epsilon</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">symi</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">symo</span> <span class="o">!=</span> <span class="n">Epsilon</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Output</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">symo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stsrc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">stsrc</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">symi</span><span class="p">:</span> <span class="p">{(</span><span class="n">symo</span><span class="p">,</span> <span class="n">sti2</span><span class="p">)}}</span>
        <span class="k">elif</span> <span class="n">symi</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">stsrc</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">stsrc</span><span class="p">][</span><span class="n">symi</span><span class="p">]</span> <span class="o">=</span> <span class="p">{(</span><span class="n">symo</span><span class="p">,</span> <span class="n">sti2</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">stsrc</span><span class="p">][</span><span class="n">symi</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">symo</span><span class="p">,</span> <span class="n">sti2</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; infix version of union</span>

<span class="sd">        :param other: other operand</span>
<span class="sd">        :rtype: SFT&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="SFT.union"><a class="viewcode-back" href="../index.html#transducers.SFT.union">[docs]</a>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Union of the two transducers</span>

<span class="sd">        :param SFT other: the other operand</span>
<span class="sd">        :rtype: SFT&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">syi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">]:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">syo</span><span class="p">,</span> <span class="n">sto</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">][</span><span class="n">syi</span><span class="p">]:</span>
                    <span class="n">nsti</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">])</span>
                    <span class="n">isti</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nsti</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">nsto</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sto</span><span class="p">])</span>
                    <span class="n">isto</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nsto</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">isti</span><span class="p">,</span> <span class="n">syi</span><span class="p">,</span> <span class="n">syo</span><span class="p">,</span> <span class="n">isto</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">]),</span> <span class="bp">True</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">]),</span> <span class="bp">True</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">syi</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">]:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">syo</span><span class="p">,</span> <span class="n">sto</span><span class="p">)</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">][</span><span class="n">syi</span><span class="p">]:</span>
                    <span class="n">nsti</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">])</span>
                    <span class="n">isti</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nsti</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">nsto</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sto</span><span class="p">])</span>
                    <span class="n">isto</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nsto</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">isti</span><span class="p">,</span> <span class="n">syi</span><span class="p">,</span> <span class="n">syo</span><span class="p">,</span> <span class="n">isto</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">])))</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">])))</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="SFT.concat"><a class="viewcode-back" href="../index.html#transducers.SFT.concat">[docs]</a>    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenation of transducers</span>

<span class="sd">        :param SFT other: the other operand</span>
<span class="sd">        :rtype: SFT&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">syi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">]:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">syo</span><span class="p">,</span> <span class="n">sto</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">][</span><span class="n">syi</span><span class="p">]:</span>
                    <span class="n">nsti</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">])</span>
                    <span class="n">isti</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nsti</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">nsto</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sto</span><span class="p">])</span>
                    <span class="n">isto</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nsto</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">isti</span><span class="p">,</span> <span class="n">syi</span><span class="p">,</span> <span class="n">syo</span><span class="p">,</span> <span class="n">isto</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">]),</span> <span class="bp">True</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">syi</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">]:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">syo</span><span class="p">,</span> <span class="n">sto</span><span class="p">)</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">][</span><span class="n">syi</span><span class="p">]:</span>
                    <span class="n">nsti</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">])</span>
                    <span class="n">isti</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nsti</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">nsto</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sto</span><span class="p">])</span>
                    <span class="n">isto</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nsto</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">isti</span><span class="p">,</span> <span class="n">syi</span><span class="p">,</span> <span class="n">syo</span><span class="p">,</span> <span class="n">isto</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">]),</span> <span class="bp">True</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sto</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">])),</span>
                                  <span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span>
                                  <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sto</span><span class="p">])))</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="SFT.star"><a class="viewcode-back" href="../index.html#transducers.SFT.star">[docs]</a>    <span class="k">def</span> <span class="nf">star</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Kleene star</span>

<span class="sd">        :param bool flag: plus instead of star</span>
<span class="sd">        :returns: the resulting Transducer</span>
<span class="sd">        :rtype: SFT&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">syi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">]:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">syo</span><span class="p">,</span> <span class="n">sto</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">][</span><span class="n">syi</span><span class="p">]:</span>
                    <span class="n">nsti</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sti</span><span class="p">])</span>
                    <span class="n">isti</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nsti</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">nsto</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sto</span><span class="p">])</span>
                    <span class="n">isto</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">nsto</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">isti</span><span class="p">,</span> <span class="n">syi</span><span class="p">,</span> <span class="n">syo</span><span class="p">,</span> <span class="n">isto</span><span class="p">)</span>
        <span class="n">stin</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&#39;Initial&#39;</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">stin</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">so</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">iso</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">so</span><span class="p">]))</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">stin</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">iso</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">so</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
            <span class="n">iso</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">so</span><span class="p">]))</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">iso</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">stin</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">iso</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">stin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="SFT.toInNFA"><a class="viewcode-back" href="../index.html#transducers.SFT.toInNFA">[docs]</a>    <span class="k">def</span> <span class="nf">toInNFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the output labels in the transducer. Translate it into an NFA</span>

<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">aut</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">()</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">setFinal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">aut</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">aut</span>
</div>
<div class="viewcode-block" id="SFT.toOutNFA"><a class="viewcode-back" href="../index.html#transducers.SFT.toOutNFA">[docs]</a>    <span class="k">def</span> <span class="nf">toOutNFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the result of considering the output symbols of the transducer as input symbols of a NFA (ignoring</span>
<span class="sd">        the input symbol, thus)</span>

<span class="sd">        :return: the NFA</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span><span class="o">.</span><span class="n">toInNFA</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="SFT.runOnWord"><a class="viewcode-back" href="../index.html#transducers.SFT.runOnWord">[docs]</a>    <span class="k">def</span> <span class="nf">runOnWord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the automaton accepting the outup of the transducer on the input word</span>

<span class="sd">        :param word: the word</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">lang</span> <span class="o">=</span> <span class="n">fl</span><span class="o">.</span><span class="n">FL</span><span class="p">([</span><span class="n">word</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">runOnNFA</span><span class="p">(</span><span class="n">lang</span><span class="o">.</span><span class="n">trieFA</span><span class="p">()</span><span class="o">.</span><span class="n">toNFA</span><span class="p">())</span>
</div>
    <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inIntersection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="SFT.inIntersection"><a class="viewcode-back" href="../index.html#transducers.SFT.inIntersection">[docs]</a>    <span class="k">def</span> <span class="nf">inIntersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Conjunction of transducer and automata: X &amp; Y.</span>

<span class="sd">        :param DFA|NFA other: the automata needs to be operated.</span>
<span class="sd">        :rtype: SFT&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fa</span><span class="o">.</span><span class="n">DFA</span><span class="p">):</span>
            <span class="n">nother</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()</span><span class="o">.</span><span class="n">renameStates</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">):</span>
            <span class="n">nother</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">renameStates</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">common</span><span class="o">.</span><span class="n">FAdoGeneralError</span><span class="p">(</span><span class="s">&quot;Incompatible objects&quot;</span><span class="p">)</span>
        <span class="n">et</span><span class="p">,</span> <span class="n">en</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">(),</span> <span class="n">nother</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">en</span><span class="p">:</span>
            <span class="n">par1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
            <span class="n">par1</span><span class="o">.</span><span class="n">addEpsilonLoops</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">par1</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">et</span><span class="p">:</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">nother</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
            <span class="n">par2</span><span class="o">.</span><span class="n">addEpsilonLoops</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">nother</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">par1</span><span class="o">.</span><span class="n">productInput</span><span class="p">(</span><span class="n">par2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">par1</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">par2</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">par1</span><span class="o">.</span><span class="n">Final</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">par2</span><span class="o">.</span><span class="n">Final</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="SFT.productInput"><a class="viewcode-back" href="../index.html#transducers.SFT.productInput">[docs]</a>    <span class="k">def</span> <span class="nf">productInput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a transducer (skeleton) resulting from the execution of the transducer with the automaton as</span>
<span class="sd">        filter on the input.</span>

<span class="sd">        :param NFA other: the automaton used as filter</span>
<span class="sd">        :rtype: SFT&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="n">notDone</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">Initial</span><span class="p">]:</span>
                <span class="n">sname</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
                <span class="n">sti</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">sname</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
                <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sname</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">notDone</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">notDone</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span>
            <span class="n">sti</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="n">other</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span>
            <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputS</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span> <span class="n">other</span><span class="o">.</span><span class="n">inputS</span><span class="p">(</span><span class="n">i2</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">k2</span><span class="p">):</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">symo</span><span class="p">,</span> <span class="n">o1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">k</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">o2</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i2</span><span class="p">][</span><span class="n">k</span><span class="p">]:</span>
                        <span class="n">new</span><span class="o">.</span><span class="n">addTransitionQ</span><span class="p">(</span><span class="n">sti</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">o1</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">o2</span><span class="p">]),</span> <span class="n">k</span><span class="p">,</span> <span class="n">symo</span><span class="p">,</span> <span class="n">notDone</span><span class="p">,</span> <span class="n">done</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="SFT.composition"><a class="viewcode-back" href="../index.html#transducers.SFT.composition">[docs]</a>    <span class="k">def</span> <span class="nf">composition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Composition operation of a transducer with a transducer.</span>

<span class="sd">           :param SFT other: the second transducer</span>
<span class="sd">           :rtype: SFT&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SFT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">common</span><span class="o">.</span><span class="n">FAdoGeneralError</span><span class="p">(</span><span class="s">&quot;Incompatible objects&quot;</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
        <span class="n">notDone</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonOutP</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">e1</span><span class="p">:</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">par2</span><span class="o">.</span><span class="n">addEpsilonLoops</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">e2</span><span class="p">:</span>
            <span class="n">par1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">par1</span><span class="o">.</span><span class="n">addEpsilonLoops</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">par1</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="p">[</span><span class="n">par1</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">par1</span><span class="o">.</span><span class="n">Initial</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="p">[</span><span class="n">par2</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">par2</span><span class="o">.</span><span class="n">Initial</span><span class="p">]:</span>
                <span class="n">sname</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
                <span class="n">sti</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">sname</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
                <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sname</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">notDone</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">notDone</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">par1</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="n">par2</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span>
            <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">par1</span><span class="o">.</span><span class="n">outputS</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span> <span class="n">par2</span><span class="o">.</span><span class="n">inputS</span><span class="p">(</span><span class="n">i2</span><span class="p">))</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">par1</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">so1</span><span class="p">,</span> <span class="n">o1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">par1</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">s</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">so1</span> <span class="ow">in</span> <span class="n">K</span><span class="p">:</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">so2</span><span class="p">,</span> <span class="n">o2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">par2</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i2</span><span class="p">][</span><span class="n">so1</span><span class="p">]:</span>
                            <span class="n">new</span><span class="o">.</span><span class="n">addTransitionQ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">par1</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">o1</span><span class="p">],</span> <span class="n">par1</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">o2</span><span class="p">]),</span> <span class="n">s</span><span class="p">,</span> <span class="n">so2</span><span class="p">,</span> <span class="n">notDone</span><span class="p">,</span> <span class="n">done</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">par1</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">par2</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">par1</span><span class="o">.</span><span class="n">Final</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">par2</span><span class="o">.</span><span class="n">Final</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="SFT.functionalP"><a class="viewcode-back" href="../index.html#transducers.SFT.functionalP">[docs]</a>    <span class="k">def</span> <span class="nf">functionalP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if a  transducer is functional using Allauzer &amp; Mohri and Béal&amp;Carton&amp;Prieur&amp;Sakarovitch algorithms.</span>

<span class="sd">        :rtype: bool</span>

<span class="sd">        .. seealso:: Cyril Allauzer and Mehryar Mohri, Journal of Automata Languages and Combinatorics,</span>
<span class="sd">            Efficient Algorithms for Testing the Twins Property, 8(2): 117-144, 2003.</span>

<span class="sd">        .. seealso:: M.P. Béal, O. Carton, C. Prieur and J. Sakarovitch. Squaring transducers: An efficient</span>
<span class="sd">            procedure for deciding functionality and sequentiality. Theoret. Computer Science 292:1 (2003), 45-63.</span>

<span class="sd">        .. note::</span>
<span class="sd">           This is implemented using nonFunctionalW()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonFunctionalW</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_functionalP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="n">notDone</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">done</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">notDone</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">done</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">notDone</span><span class="p">:</span>
            <span class="n">sti</span> <span class="o">=</span> <span class="n">notDone</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="p">(</span><span class="n">preInput</span><span class="p">,</span> <span class="n">preOutput</span><span class="p">)</span> <span class="o">=</span> <span class="n">done</span><span class="p">[</span><span class="n">sti</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sti</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">symi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">symo</span><span class="p">,</span> <span class="n">sto</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">][</span><span class="n">symi</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">preInput</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                            <span class="n">newInput</span> <span class="o">=</span> <span class="n">symi</span>
                        <span class="k">elif</span> <span class="n">symi</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                            <span class="n">newInput</span> <span class="o">=</span> <span class="n">preInput</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">newInput</span> <span class="o">=</span> <span class="n">preInput</span> <span class="o">+</span> <span class="n">symi</span>
                        <span class="k">if</span> <span class="n">preOutput</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                            <span class="n">newOutput</span> <span class="o">=</span> <span class="n">symo</span>
                        <span class="k">elif</span> <span class="n">symo</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                            <span class="n">newOutput</span> <span class="o">=</span> <span class="n">preOutput</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">newOutput</span> <span class="o">=</span> <span class="n">preOutput</span> <span class="o">+</span> <span class="n">symo</span>
                        <span class="k">if</span> <span class="n">newOutput</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">newInput</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">newInput</span> <span class="o">==</span> <span class="n">newOutput</span><span class="p">:</span>
                                <span class="n">newInput</span> <span class="o">=</span> <span class="n">newOutput</span> <span class="o">=</span> <span class="n">Epsilon</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">newOutput</span> <span class="o">=</span> <span class="n">newOutput</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">newInput</span><span class="p">):]</span>
                                <span class="n">newInput</span> <span class="o">=</span> <span class="n">Epsilon</span>
                        <span class="k">elif</span> <span class="n">newInput</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">newOutput</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">newInput</span> <span class="o">==</span> <span class="n">newOutput</span><span class="p">:</span>
                                <span class="n">newInput</span> <span class="o">=</span> <span class="n">newOutput</span> <span class="o">=</span> <span class="n">Epsilon</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">newInput</span> <span class="o">=</span> <span class="n">newInput</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">newOutput</span><span class="p">):]</span>
                                <span class="n">newOutput</span> <span class="o">=</span> <span class="n">Epsilon</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">newInput</span> <span class="o">!=</span> <span class="n">Epsilon</span> <span class="ow">and</span> <span class="n">newOutput</span> <span class="o">!=</span> <span class="n">Epsilon</span> <span class="ow">and</span> <span class="n">newInput</span> <span class="o">!=</span> <span class="n">newOutput</span><span class="p">:</span>
                                <span class="k">return</span> <span class="bp">False</span>
                        <span class="k">if</span> <span class="n">sto</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="ow">and</span> <span class="p">(</span><span class="n">newInput</span> <span class="o">!=</span> <span class="n">Epsilon</span> <span class="ow">or</span> <span class="n">newOutput</span> <span class="o">!=</span> <span class="n">Epsilon</span><span class="p">):</span>
                            <span class="k">return</span> <span class="bp">False</span>
                        <span class="k">if</span> <span class="n">sto</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                            <span class="n">notDone</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sto</span><span class="p">)</span>
                            <span class="n">done</span><span class="p">[</span><span class="n">sto</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">newInput</span><span class="p">,</span> <span class="n">newOutput</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">done</span><span class="p">[</span><span class="n">sto</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">newInput</span><span class="p">,</span> <span class="n">newOutput</span><span class="p">):</span>
                                <span class="k">continue</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>

<div class="viewcode-block" id="SFT.runOnNFA"><a class="viewcode-back" href="../index.html#transducers.SFT.runOnNFA">[docs]</a>    <span class="k">def</span> <span class="nf">runOnNFA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nfa</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Result of applying a transducer to an automaton</span>

<span class="sd">        :param DFA|NFA nfa: input language to transducer</span>
<span class="sd">        :return: resulting language</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inIntersection</span><span class="p">(</span><span class="n">nfa</span><span class="p">)</span><span class="o">.</span><span class="n">toOutNFA</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="SFT.outIntersectionDerived"><a class="viewcode-back" href="../index.html#transducers.SFT.outIntersectionDerived">[docs]</a>    <span class="k">def</span> <span class="nf">outIntersectionDerived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Naive version of outIntersection</span>

<span class="sd">        :param DFA|NFA other: the automaton used as a filter of the output</span>
<span class="sd">        :rtype: SFT&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="SFT.outIntersection"><a class="viewcode-back" href="../index.html#transducers.SFT.outIntersection">[docs]</a>    <span class="k">def</span> <span class="nf">outIntersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conjunction of transducer and automaton: X &amp; Y using output intersect operation.</span>

<span class="sd">        :param DFA|NFA other: the automaton used as a filter of the output</span>
<span class="sd">        :rtype: SFT&quot;&quot;&quot;</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()</span><span class="o">.</span><span class="n">renameStates</span><span class="p">()</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Output</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Output</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="n">notDone</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="p">[</span><span class="n">foo</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">foo</span><span class="o">.</span><span class="n">Initial</span><span class="p">]:</span>
                <span class="n">sname</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">sname</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">sname</span><span class="p">))</span>
                <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>
        <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonOutP</span><span class="p">(),</span> <span class="n">foo</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">e1</span><span class="p">:</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
            <span class="n">par2</span><span class="o">.</span><span class="n">addEpsilonLoops</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">par2</span> <span class="o">=</span> <span class="n">foo</span>
        <span class="k">if</span> <span class="n">e2</span><span class="p">:</span>
            <span class="n">par1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
            <span class="n">par1</span><span class="o">.</span><span class="n">addEpsilonLoops</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">par1</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">notDone</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">notDone</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">par1</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="n">par2</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span>
            <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">par1</span><span class="o">.</span><span class="n">outputS</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span> <span class="n">par2</span><span class="o">.</span><span class="n">inputS</span><span class="p">(</span><span class="n">i2</span><span class="p">))</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">par1</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">symo</span><span class="p">,</span> <span class="n">sout1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">par1</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">s</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">symo</span> <span class="ow">in</span> <span class="n">K</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">sout2</span> <span class="ow">in</span> <span class="n">par2</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i2</span><span class="p">][</span><span class="n">symo</span><span class="p">]:</span>
                            <span class="n">new</span><span class="o">.</span><span class="n">addTransitionQ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">par1</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sout1</span><span class="p">],</span> <span class="n">par2</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sout2</span><span class="p">]),</span> <span class="n">s</span><span class="p">,</span> <span class="n">symo</span><span class="p">,</span> <span class="n">notDone</span><span class="p">,</span> <span class="n">done</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">par1</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">par2</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">par1</span><span class="o">.</span><span class="n">Final</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">par2</span><span class="o">.</span><span class="n">Final</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="SFT.inverse"><a class="viewcode-back" href="../index.html#transducers.SFT.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Switch the input label with the output label.</span>

<span class="sd">        No initial or final state changed.</span>

<span class="sd">        :return: Transducer with transitions switched.</span>
<span class="sd">        :rtype: SFT&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setFinal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">))</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Output</span><span class="p">))</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Output</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">symi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">]:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">symo</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">symi</span><span class="p">]:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">symo</span><span class="p">,</span> <span class="n">symi</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="SFT.reversal"><a class="viewcode-back" href="../index.html#transducers.SFT.reversal">[docs]</a>    <span class="k">def</span> <span class="nf">reversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a transducer that recognizes the reversal of the relation.</span>

<span class="sd">        :return: Transducer recognizing reversal language</span>
<span class="sd">        :rtype: SFT&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">States</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setFinal</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">))</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">))</span>
        <span class="n">new</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Output</span><span class="p">))</span>
        <span class="n">new</span><span class="o">.</span><span class="n">Output</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">symi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">]:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">symo</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">symi</span><span class="p">]:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">symo</span><span class="p">,</span> <span class="n">symi</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="SFT.epsilonP"><a class="viewcode-back" href="../index.html#transducers.SFT.epsilonP">[docs]</a>    <span class="k">def</span> <span class="nf">epsilonP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test whether this transducer has input epsilon-transitions</span>

<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">Epsilon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="SFT.addEpsilonLoops"><a class="viewcode-back" href="../index.html#transducers.SFT.addEpsilonLoops">[docs]</a>    <span class="k">def</span> <span class="nf">addEpsilonLoops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a loop transition with epsilon input and output to every state in the transducer.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SFT.evalWordP"><a class="viewcode-back" href="../index.html#transducers.SFT.evalWordP">[docs]</a>    <span class="k">def</span> <span class="nf">evalWordP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests whether the transducer returns the second word using the first one as input</span>

<span class="sd">        :param tuple wp: pair of words</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">fl</span>
        <span class="p">(</span><span class="n">win</span><span class="p">,</span> <span class="n">wout</span><span class="p">)</span> <span class="o">=</span> <span class="n">wp</span>
        <span class="n">inT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inIntersection</span><span class="p">(</span><span class="n">fl</span><span class="o">.</span><span class="n">FL</span><span class="p">([</span><span class="n">win</span><span class="p">])</span><span class="o">.</span><span class="n">trieFA</span><span class="p">()</span><span class="o">.</span><span class="n">toNFA</span><span class="p">())</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">inT</span><span class="o">.</span><span class="n">outIntersection</span><span class="p">(</span><span class="n">fl</span><span class="o">.</span><span class="n">FL</span><span class="p">([</span><span class="n">wout</span><span class="p">])</span><span class="o">.</span><span class="n">trieFA</span><span class="p">()</span><span class="o">.</span><span class="n">toNFA</span><span class="p">())</span><span class="o">.</span><span class="n">emptyP</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="SFT.emptyP"><a class="viewcode-back" href="../index.html#transducers.SFT.emptyP">[docs]</a>    <span class="k">def</span> <span class="nf">emptyP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if the relation realized  the empty transducer</span>

<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toInNFA</span><span class="p">()</span><span class="o">.</span><span class="n">emptyP</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="SFT.nonEmptyW"><a class="viewcode-back" href="../index.html#transducers.SFT.nonEmptyW">[docs]</a>    <span class="k">def</span> <span class="nf">nonEmptyW</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Witness of non emptyness</span>

<span class="sd">        :return: pair (in-word, out-word)</span>
<span class="sd">        :rtype: tuple&quot;&quot;&quot;</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">notDone</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">pref</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">pref</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">)</span>
            <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">notDone</span><span class="p">:</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">notDone</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pref</span><span class="p">[</span><span class="n">si</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">syi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">syo</span><span class="p">,</span> <span class="n">so</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">si</span><span class="p">][</span><span class="n">syi</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">so</span> <span class="ow">in</span> <span class="n">done</span> <span class="ow">or</span> <span class="n">so</span> <span class="ow">in</span> <span class="n">notDone</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">pref</span><span class="p">[</span><span class="n">so</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatN</span><span class="p">(</span><span class="n">pref</span><span class="p">[</span><span class="n">si</span><span class="p">],</span> <span class="p">(</span><span class="n">syi</span><span class="p">,</span> <span class="n">syo</span><span class="p">))</span>
                    <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">so</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="SFT.nonFunctionalW"><a class="viewcode-back" href="../index.html#transducers.SFT.nonFunctionalW">[docs]</a>    <span class="k">def</span> <span class="nf">nonFunctionalW</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a witness of non funcionality (if is that the case) or a None filled triple</span>

<span class="sd">        :return: witness</span>
<span class="sd">        :rtype: tuple&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_suffix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Epsilon</span>
            <span class="k">elif</span> <span class="n">_len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                <span class="k">return</span> <span class="s">&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">b</span>
                <span class="k">elif</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)]:</span>
                    <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s">&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_newSValue</span><span class="p">((</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">),</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">concatN</span><span class="p">((</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">),</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">_suffix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">s</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">_suffix</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">Epsilon</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ZERO</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_completeCE</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">sq</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="k">for</span> <span class="n">sy</span> <span class="ow">in</span> <span class="n">sq</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="p">(</span><span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">))</span> <span class="o">=</span> <span class="n">sy</span>
                <span class="k">for</span> <span class="n">sto</span> <span class="ow">in</span> <span class="n">sq</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">sy</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">sto</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">_completeCE</span><span class="p">(</span><span class="n">sto</span><span class="p">,</span> <span class="n">concatN</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">)),</span> <span class="n">l</span> <span class="o">+</span> <span class="p">[</span><span class="n">sto</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">r</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilonOutP</span><span class="p">():</span>
            <span class="n">wtrand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
            <span class="n">wtrand</span><span class="o">.</span><span class="n">addEpsilonLoops</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wtrand</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">sq</span> <span class="o">=</span> <span class="n">wtrand</span><span class="o">.</span><span class="n">square_fv</span><span class="p">()</span>
        <span class="n">sq</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="n">valuei</span><span class="p">,</span> <span class="n">svalue</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">notDone</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">(),</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sti</span> <span class="ow">in</span> <span class="n">sq</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
            <span class="n">svalue</span><span class="p">[</span><span class="n">sti</span><span class="p">]</span> <span class="o">=</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span>
            <span class="n">valuei</span><span class="p">[</span><span class="n">sti</span><span class="p">]</span> <span class="o">=</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span>
        <span class="k">while</span> <span class="n">notDone</span><span class="p">:</span>
            <span class="n">sti</span> <span class="o">=</span> <span class="n">notDone</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">svalue</span><span class="p">[</span><span class="n">sti</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sq</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sti</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span> <span class="o">=</span> <span class="n">j</span>
                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">sq</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">sti</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">vi</span> <span class="o">=</span> <span class="n">concatN</span><span class="p">(</span><span class="n">valuei</span><span class="p">[</span><span class="n">sti</span><span class="p">],</span> <span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">vo</span> <span class="o">=</span> <span class="n">_newSValue</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">sq</span><span class="o">.</span><span class="n">Final</span> <span class="ow">and</span> <span class="n">vo</span> <span class="o">!=</span> <span class="p">(</span><span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="n">ZERO</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">svalue</span> <span class="ow">and</span> <span class="n">svalue</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">!=</span> <span class="n">vo</span><span class="p">:</span>
                            <span class="n">suf</span> <span class="o">=</span> <span class="n">_completeCE</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">(</span><span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">),</span> <span class="p">[</span><span class="n">o</span><span class="p">])</span>
                            <span class="n">foo</span> <span class="o">=</span> <span class="n">concatN</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">suf</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">foo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">foo</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                                <span class="k">return</span> <span class="n">concatN</span><span class="p">(</span><span class="n">valuei</span><span class="p">[</span><span class="n">o</span><span class="p">],</span> <span class="n">suf</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">return</span> <span class="n">foo</span>
                    <span class="k">except</span> <span class="n">ZERO</span><span class="p">:</span>
                        <span class="n">suf</span> <span class="o">=</span> <span class="n">_completeCE</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">(</span><span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">),</span> <span class="p">[</span><span class="n">o</span><span class="p">])</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">suf</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">common</span><span class="o">.</span><span class="n">TRError</span><span class="p">()</span>
                        <span class="k">return</span> <span class="n">concatN</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">suf</span><span class="p">)</span>
                    <span class="n">valuei</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">vi</span>
                    <span class="n">svalue</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">vo</span>
                    <span class="k">if</span> <span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                        <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="SFT.square"><a class="viewcode-back" href="../index.html#transducers.SFT.square">[docs]</a>    <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conjunction of transducer with itself</span>

<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">()</span>
        <span class="n">notDone</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">]:</span>
                <span class="n">sname</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">sname</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">notDone</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">notDone</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span>
            <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputS</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputS</span><span class="p">(</span><span class="n">i2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="ow">and</span> <span class="n">i2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">syin</span> <span class="ow">in</span> <span class="n">K</span><span class="p">:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">syout</span><span class="p">,</span> <span class="n">sout</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">syin</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">syout2</span><span class="p">,</span> <span class="n">sout2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i2</span><span class="p">][</span><span class="n">syin</span><span class="p">]:</span>
                        <span class="n">stoutr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sout</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">States</span><span class="p">[</span><span class="n">sout2</span><span class="p">])</span>
                        <span class="n">new</span><span class="o">.</span><span class="n">addTransitionQ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">stoutr</span><span class="p">,</span> <span class="p">(</span><span class="n">syin</span><span class="p">,</span> <span class="p">(</span><span class="n">syout</span><span class="p">,</span> <span class="n">syout2</span><span class="p">)),</span> <span class="n">notDone</span><span class="p">,</span> <span class="n">done</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="SFT.square_fv"><a class="viewcode-back" href="../index.html#transducers.SFT.square_fv">[docs]</a>    <span class="k">def</span> <span class="nf">square_fv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conjunction of transducer with itself (Fast Version)</span>

<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">()</span>
        <span class="n">notDone</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Initial</span><span class="p">:</span>
                <span class="n">sname</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">sname</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">notDone</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sname</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">notDone</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">notDone</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputS</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputS</span><span class="p">(</span><span class="n">i2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span> <span class="ow">and</span> <span class="n">i2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Final</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">syin</span> <span class="ow">in</span> <span class="n">K</span><span class="p">:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">syout</span><span class="p">,</span> <span class="n">sout</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">syin</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">syout2</span><span class="p">,</span> <span class="n">sout2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i2</span><span class="p">][</span><span class="n">syin</span><span class="p">]:</span>
                        <span class="n">stoutr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sout</span><span class="p">,</span> <span class="n">sout2</span><span class="p">)</span>
                        <span class="n">new</span><span class="o">.</span><span class="n">addTransitionQ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">stoutr</span><span class="p">,</span> <span class="p">(</span><span class="n">syin</span><span class="p">,</span> <span class="p">(</span><span class="n">syout</span><span class="p">,</span> <span class="n">syout2</span><span class="p">)),</span> <span class="n">notDone</span><span class="p">,</span> <span class="n">done</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="SFT.epsilonOutP"><a class="viewcode-back" href="../index.html#transducers.SFT.epsilonOutP">[docs]</a>    <span class="k">def</span> <span class="nf">epsilonOutP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if epsilon occurs in transition outputs</span>

<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

</div></div>
<span class="k">class</span> <span class="nc">NFT</span><span class="p">(</span><span class="n">SFT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normal Form Transducer.</span>

<span class="sd">    Transsitions here have labels of the form (s,Epsilon) or (Epsilon,s)</span>

<span class="sd">    .. inheritance-diagram:: SFT&quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">infixTransducer</span><span class="p">(</span><span class="n">alphabet</span><span class="p">,</span> <span class="n">preserving</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates an infix property transducer based on given alphabet</span>

<span class="sd">    :param bool preserving: input preserving transducer, else input altering</span>
<span class="sd">    :param list|set alphabet: alphabet</span>
<span class="sd">    :rtype: SFT &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">preserving</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">setFinal</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">setFinal</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">t</span>


<span class="k">def</span> <span class="nf">prefixTransducer</span><span class="p">(</span><span class="n">alphabet</span><span class="p">,</span> <span class="n">preserving</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates an prefix property transducer based on given alphabet</span>

<span class="sd">    :param bool preserving: input preserving transducer, else input altering</span>
<span class="sd">    :param list|set alphabet: alphabet</span>
<span class="sd">    :rtype: SFT &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
    <span class="n">initial</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">final</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">final</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alphabet</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">initial</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">preserving</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>


<span class="k">def</span> <span class="nf">suffixTransducer</span><span class="p">(</span><span class="n">alphabet</span><span class="p">,</span> <span class="n">preserving</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates an suffix property transducer based on given alphabet</span>

<span class="sd">    :param bool preserving: input preserving transducer, else input altering</span>
<span class="sd">    :param list|set alphabet: alphabet</span>
<span class="sd">    :rtype: SFT &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
    <span class="n">initial</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">final</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">final</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alphabet</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">initial</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">preserving</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>


<span class="k">def</span> <span class="nf">outfixTransducer</span><span class="p">(</span><span class="n">alphabet</span><span class="p">,</span> <span class="n">preserving</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates an outfix property transducer based on given alphabet</span>

<span class="sd">    :param bool preserving: input preserving transducer, else input altering</span>
<span class="sd">    :param list|set alphabet: alphabet</span>
<span class="sd">    :rtype: SFT &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
    <span class="n">initial</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">final</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">final</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alphabet</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">initial</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">middle</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">middle</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">middle</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">middle</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">preserving</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>


<span class="k">def</span> <span class="nf">hypercodeTransducer</span><span class="p">(</span><span class="n">alphabet</span><span class="p">,</span> <span class="n">preserving</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates an hypercode property transducer based on given alphabet</span>

<span class="sd">    :param bool preserving: input preserving transducer, else input altering</span>
<span class="sd">    :param list|set alphabet: alphabet</span>
<span class="sd">    :rtype: SFT &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">SFT</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">setOutput</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
    <span class="n">initial</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">final</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">final</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alphabet</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">initial</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">preserving</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">FAdo 1.2 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 1999-2014, Rogério Reis &amp; Nelma Moreira.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>
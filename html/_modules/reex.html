<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>reex &mdash; FAdo 1.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="FAdo 1.2 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">FAdo 1.2 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for reex</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;**Regular expressions manipulation**</span>

<span class="sd">Regular expression classes and manipulation</span>

<span class="sd">.. *Authors:* Rogério Reis &amp; Nelma Moreira</span>

<span class="sd">.. Contributions by</span>
<span class="sd">    - Marco Almeida</span>
<span class="sd">    - Hugo Gouveia</span>
<span class="sd">    - Eva Maia</span>

<span class="sd">.. *This is part of FAdo project*   http://fado.dcc.fc.up.pt</span>

<span class="sd">.. *Version:* 0.9.8</span>

<span class="sd">.. *Copyright:* 1999-2013 Rogério Reis &amp; Nelma Moreira {rvr,nam}@dcc.fc.up.pt</span>


<span class="sd">.. This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public</span>
<span class="sd">   License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any</span>
<span class="sd">   later version.</span>

<span class="sd">   This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<span class="sd">   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more</span>
<span class="sd">   details.</span>


<span class="sd">   You should have received a copy of the GNU General Public Licensealong with this program; if not, write to the</span>
<span class="sd">   Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="kn">from</span> <span class="nn">yappy_parser</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">common</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">fa</span>
<span class="kn">import</span> <span class="nn">copy</span>


<div class="viewcode-block" id="regexp"><a class="viewcode-back" href="../index.html#reex.regexp">[docs]</a><span class="k">class</span> <span class="nc">regexp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for regular expressions.</span>

<span class="sd">    Used directly to represent a symbol. The type of the symbol is arbitrary.</span>

<span class="sd">    :var Sigma: alphabet set of strings</span>
<span class="sd">    :var val: the actual symbol</span>

<span class="sd">    .. inheritance-diagram:: regexp&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor of a regular expression symbol.</span>

<span class="sd">        :arg val: the actual symbol&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">sigma</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Representation of the regular expression&#39;s syntactical tree.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&#39;regexp({0:&gt;s})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__str__</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation of the regular expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

    <span class="n">_strP</span> <span class="o">=</span> <span class="n">__str__</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Size of the RE (the tree length)</span>

<span class="sd">        :rtype: int&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">treeLength</span><span class="p">()</span>

<div class="viewcode-block" id="regexp.rpn"><a class="viewcode-back" href="../index.html#reex.regexp.rpn">[docs]</a>    <span class="k">def</span> <span class="nf">rpn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;RPN representation</span>
<span class="sd">        :return: printable RPN representation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether the string representations of two regular expressions are equal.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">==</span> <span class="n">r</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">repr</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether the string representations of two regular expressions are different.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hash over regular expression&#39;s string representation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reconstruct the regular expression&#39;s syntactical tree, or, in other words,</span>
<span class="sd">           perform a shallow copy of the tree.</span>
<span class="sd">        :return: regular expression</span>

<span class="sd">        .. note::</span>
<span class="sd">           References to the expression&#39;s symbols in the leafs are preserved.</span>

<span class="sd">        .. attention:: Raw modifications on the regular expression&#39;s tree should be performed over</span>
<span class="sd">        a copy returned by this method, so that cached methods do not interfere.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">regexp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

<div class="viewcode-block" id="regexp.setSigma"><a class="viewcode-back" href="../index.html#reex.regexp.setSigma">[docs]</a>    <span class="k">def</span> <span class="nf">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbolSet</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the alphabet for a regular expression and all its nodes</span>

<span class="sd">        :arg symbolSet: accepted symbols. If None, alphabet is unset.</span>
<span class="sd">        :type symbolSet: list or set of str</span>
<span class="sd">        :arg strict: if True checks if setOfSymbols is included in symbolSet</span>
<span class="sd">        :type strict: bool</span>

<span class="sd">        ..attention: Normally this attribute is not defined in a regexp()&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">symbolSet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setOfSymbols</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">symbolSet</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">regexpInvalidSymbols</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbolSet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setSigma</span><span class="p">(</span><span class="n">strict</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_setSigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param strict:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="regexp.setOfSymbols"><a class="viewcode-back" href="../index.html#reex.regexp.setOfSymbols">[docs]</a>    <span class="k">def</span> <span class="nf">setOfSymbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of symbols that occur in a regular expression..</span>

<span class="sd">        :return: set of symbols</span>
<span class="sd">        :rtype: set of symbols&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">}</span>
</div>
<div class="viewcode-block" id="regexp.stringLength"><a class="viewcode-back" href="../index.html#reex.regexp.stringLength">[docs]</a>    <span class="k">def</span> <span class="nf">stringLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Length of the string representation of the regular expression.</span>

<span class="sd">        :rtype: integer&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="regexp.measure"><a class="viewcode-back" href="../index.html#reex.regexp.measure">[docs]</a>    <span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A list with four measures for regular expressions.</span>

<span class="sd">        :param from_parent:</span>
<span class="sd">        :rtype: [int,int,int,int]</span>

<span class="sd">        [alphabeticLength, treeLength, epsilonLength, starHeight]</span>

<span class="sd">        1. alphabeticLength: number of occurences of symbols of the alphabet;</span>

<span class="sd">        2. treeLength: number of functors in the regular expression, including constants.</span>

<span class="sd">        3. epsilonLength: number of occurrences of the empty word.</span>

<span class="sd">        4. starHeight: highest level of nested Kleene stars, starting at one for one star occurrence.</span>

<span class="sd">        .. attention::</span>
<span class="sd">           Methods for each of the measures are implemented independently. This is the most effective for obtaining</span>
<span class="sd">           more than one measure.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">from_parent</span><span class="p">:</span>
            <span class="n">from_parent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">from_parent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">from_parent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">from_parent</span>
</div>
<div class="viewcode-block" id="regexp.alphabeticLength"><a class="viewcode-back" href="../index.html#reex.regexp.alphabeticLength">[docs]</a>    <span class="k">def</span> <span class="nf">alphabeticLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of occurrences of alphabet symbols in the regular expression.</span>

<span class="sd">        :rtype: integer</span>

<span class="sd">        .. attention:: Doesn&#39;t include the empty word.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>
</div>
<div class="viewcode-block" id="regexp.treeLength"><a class="viewcode-back" href="../index.html#reex.regexp.treeLength">[docs]</a>    <span class="k">def</span> <span class="nf">treeLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of nodes of the regular expression&#39;s syntactical tree.</span>

<span class="sd">        :rtype: integer&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>
</div>
<div class="viewcode-block" id="regexp.epsilonLength"><a class="viewcode-back" href="../index.html#reex.regexp.epsilonLength">[docs]</a>    <span class="k">def</span> <span class="nf">epsilonLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of occurrences of the empty word in the regular expression.</span>

<span class="sd">        :rtype: integer&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>
</div>
<div class="viewcode-block" id="regexp.starHeight"><a class="viewcode-back" href="../index.html#reex.regexp.starHeight">[docs]</a>    <span class="k">def</span> <span class="nf">starHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum level of nested regular expressions with a star operation applied.</span>

<span class="sd">        For instance, starHeight(((a*b)*+b*)*) is 3.</span>

<span class="sd">        :rtype: integer&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>
</div>
<div class="viewcode-block" id="regexp.reduced"><a class="viewcode-back" href="../index.html#reex.regexp.reduced">[docs]</a>    <span class="k">def</span> <span class="nf">reduced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hasEpsilon</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equivalent regular expression with the following cases simplified:</span>

<span class="sd">        1. Epsilon.RE = RE.Epsilon = RE</span>

<span class="sd">        2. EmptySet.RE = RE.EmptySet = EmptySet</span>

<span class="sd">        3. EmptySet + RE = RE + EmptySet = RE</span>

<span class="sd">        4. Epsilon + RE = RE + Epsilon = RE, where Epsilon is in L(RE)</span>

<span class="sd">        5. RE** = RE*</span>

<span class="sd">        6. EmptySet* = Epsilon* = Epsilon</span>

<span class="sd">        :param hasEpsilon: used internally to indicate that the language of which this term is a subterm has the empty</span>
<span class="sd">            word.</span>
<span class="sd">        :return: regular expression</span>

<span class="sd">        .. attention::</span>
<span class="sd">           Returned structure isn&#39;t strictly a duplicate. Use __copy__() for that purpose.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
    <span class="n">_reducedS</span> <span class="o">=</span> <span class="n">reduced</span>

<div class="viewcode-block" id="regexp.linearP"><a class="viewcode-back" href="../index.html#reex.regexp.linearP">[docs]</a>    <span class="k">def</span> <span class="nf">linearP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether the regular expression is linear; i.e., the occurrence of a symbol in the expression is unique.</span>

<span class="sd">        :rtype: boolean&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setOfSymbols</span><span class="p">())</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">alphabeticLength</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="regexp.first"><a class="viewcode-back" href="../index.html#reex.regexp.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_first</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of possible symbols matching the first symbol of a string in the language of the regular expression.</span>

<span class="sd">        :param parent_first:</span>
<span class="sd">        :return: list of symbols&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parent_first</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">parent_first</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parent_first</span>
</div>
<div class="viewcode-block" id="regexp.last"><a class="viewcode-back" href="../index.html#reex.regexp.last">[docs]</a>    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_last</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of possible symbols matching the last symbol of a string in the language of the regular expression.</span>

<span class="sd">        :param parent_last:</span>
<span class="sd">        :return: list of symbols</span>
<span class="sd">        :rtype: list&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parent_last</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">parent_last</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parent_last</span>
</div>
<div class="viewcode-block" id="regexp.followLists"><a class="viewcode-back" href="../index.html#reex.regexp.followLists">[docs]</a>    <span class="k">def</span> <span class="nf">followLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map of each symbol&#39;s follow list in the regular expression.</span>

<span class="sd">        :param lists:</span>
<span class="sd">        :return: map of symbols&#39; follow lists</span>
<span class="sd">        :rtype: {symbol: list of symbols}</span>

<span class="sd">        .. attention::</span>
<span class="sd">           For first() and last() return lists, the follow list for certain symbols might have repetitions in the</span>
<span class="sd">           case  of follow maps calculated from star operators. The union of last(),</span>
<span class="sd">           first() and follow() sets are always disjoint when the regular expression is in star normal form (</span>
<span class="sd">           Brüggemann-Klein, 92), therefore FAdo implements them as lists. You should order exclusively,</span>
<span class="sd">           or take a set from a list in order to resolve repetitions.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">:</span>
            <span class="n">lists</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">lists</span>
</div>
<div class="viewcode-block" id="regexp.followListsD"><a class="viewcode-back" href="../index.html#reex.regexp.followListsD">[docs]</a>    <span class="k">def</span> <span class="nf">followListsD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map of each symbol&#39;s follow list in the regular expression.</span>

<span class="sd">        :param lists:</span>
<span class="sd">        :return: map of symbols&#39; follow lists</span>
<span class="sd">        :rtype: {symbol: list of symbols}</span>

<span class="sd">        .. attention::</span>
<span class="sd">           For first() and last() return lists, the follow list for certain symbols might have repetitions in the case</span>
<span class="sd">           of follow maps calculated from star operators. The union of last(), first() and follow() sets are always</span>
<span class="sd">           disjoint</span>

<span class="sd">        .. seealso:: Sabine Broda, António Machiavelo, Nelma Moreira, and Rogério Reis. On the average size of</span>
<span class="sd">            glushkov and partial derivative automata. International Journal of Foundations of Computer Science,</span>
<span class="sd">            23(5):969-984, 2012.</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">:</span>
            <span class="n">lists</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">lists</span>
</div>
<div class="viewcode-block" id="regexp.followListsStar"><a class="viewcode-back" href="../index.html#reex.regexp.followListsStar">[docs]</a>    <span class="k">def</span> <span class="nf">followListsStar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map of each symbol&#39;s follow list in the regular expression under a star.</span>

<span class="sd">        :param lists:</span>
<span class="sd">        :return: map of symbols&#39; follow lists</span>
<span class="sd">        :rtype: {symbol: list of symbols}&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="p">]}</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">:</span>
            <span class="n">lists</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">lists</span>
</div>
<div class="viewcode-block" id="regexp.marked"><a class="viewcode-back" href="../index.html#reex.regexp.marked">[docs]</a>    <span class="k">def</span> <span class="nf">marked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Regular expression in which every alphabetic symbol is marked with its position.</span>

<span class="sd">        The kind of regular expression returned is known, depending on the literary source, as marked,</span>
<span class="sd">        linear or restricted regular expression.</span>

<span class="sd">        :return: linear regular expression</span>
<span class="sd">        :rtype: regexp</span>

<span class="sd">        .. seealso:: R. McNaughton and H. Yamada, Regular Expressions and State Graphs for Automata,</span>
<span class="sd">            IEEE Transactions on Electronic Computers, V.9 pp:39-47, 1960</span>

<span class="sd">        ..attention: mark and unmark do not preserve the alphabet, neither set the new alphabet &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">_marked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">position</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">pos</span><span class="p">)),</span> <span class="n">pos</span>

<div class="viewcode-block" id="regexp.unmarked"><a class="viewcode-back" href="../index.html#reex.regexp.unmarked">[docs]</a>    <span class="k">def</span> <span class="nf">unmarked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The unmarked form of the regular expression. Each leaf in its syntactical tree becomes a regexp(),</span>
<span class="sd">        the epsilon() or the emptyset().</span>

<span class="sd">        :rtype: (general) regular expression&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="regexp.derivative"><a class="viewcode-back" href="../index.html#reex.regexp.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Derivative of the regular expression in relation to the given symbol.</span>

<span class="sd">        :param sigma: an arbitrary symbol.</span>
<span class="sd">        :rtype: regular expression</span>

<span class="sd">        .. note:: whether the symbols belong to the expression&#39;s alphabet goes unchecked. The given symbol will be</span>
<span class="sd">           matched against the string representation of the regular expression&#39;s symbol.</span>

<span class="sd">        .. seealso:: J. A. Brzozowski, Derivatives of Regular Expressions. J. ACM 11(4): 481-494 (1964)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">epsilon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">emptyset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="regexp.wordDerivative"><a class="viewcode-back" href="../index.html#reex.regexp.wordDerivative">[docs]</a>    <span class="k">def</span> <span class="nf">wordDerivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Derivative of the regular expression in relation to the given word,</span>
<span class="sd">           which is represented by a list of symbols.</span>

<span class="sd">        :param word: list of arbitrary symbols.</span>
<span class="sd">        :rtype: regular expression</span>

<span class="sd">        .. seealso:: J. A. Brzozowski, Derivatives of Regular Expressions. J. ACM 11(4): 481-494 (1964)</span>

<span class="sd">        .. note: semantically, the list represents a catenation of symbols (word), and its alphabet is not checked.&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="regexp.partialDerivatives"><a class="viewcode-back" href="../index.html#reex.regexp.partialDerivatives">[docs]</a>    <span class="k">def</span> <span class="nf">partialDerivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of partial derivatives of the regular expression in relation to given symbol.</span>

<span class="sd">        :param sigma: symbol in relation to which the derivative will be calculated.</span>
<span class="sd">        :return: set of regular expressions</span>

<span class="sd">        .. seealso:: Antimirov, 95&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sigma</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">epsilon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)}</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="regexp.linearForm"><a class="viewcode-back" href="../index.html#reex.regexp.linearForm">[docs]</a>    <span class="k">def</span> <span class="nf">linearForm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Linear form of the regular expression , as a mapping from heads to sets of tails, so that each pair (head,</span>
<span class="sd">        tail) is a monomial in the set of linear forms.</span>

<span class="sd">        :return: dictionary mapping heads to sets of tails</span>
<span class="sd">        :rtype: {symbol: set([regular expressions])}</span>

<span class="sd">        .. seealso:: Antimirov, 95&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">:</span> <span class="p">{</span><span class="n">epsilon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)}}</span>
</div>
<div class="viewcode-block" id="regexp.PD"><a class="viewcode-back" href="../index.html#reex.regexp.PD">[docs]</a>    <span class="k">def</span> <span class="nf">PD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Closure of partial derivatives of the regular expression in relation to all words.</span>

<span class="sd">        :return: set of regular expressions</span>
<span class="sd">        :rtype: set</span>

<span class="sd">        .. seealso:: Antimirov, 95&quot;&quot;&quot;</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">lf</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">linearForm</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">lf</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">tail</span> <span class="ow">in</span> <span class="n">lf</span><span class="p">[</span><span class="n">head</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">tail</span> <span class="ow">in</span> <span class="n">pd</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span>
</div>
<div class="viewcode-block" id="regexp.support"><a class="viewcode-back" href="../index.html#reex.regexp.support">[docs]</a>    <span class="k">def</span> <span class="nf">support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&#39;Support of a regular expression.</span>

<span class="sd">        :return: set of regular expressions</span>
<span class="sd">        :rtype: set</span>

<span class="sd">        .. seealso::</span>
<span class="sd">            Champarnaud, J.M., Ziadi, D.: From Mirkin&#39;s prebases to Antimirov&#39;s word partial derivative.</span>
<span class="sd">            Fundam. Inform. 45(3), 195-205 (2001)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">epsilon</span><span class="p">()}</span>
</div>
    <span class="k">def</span> <span class="nf">_delAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_memoLF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_lf&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">:</span> <span class="p">{</span><span class="n">epsilon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)}}</span>

<div class="viewcode-block" id="regexp.emptyP"><a class="viewcode-back" href="../index.html#reex.regexp.emptyP">[docs]</a>    <span class="k">def</span> <span class="nf">emptyP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether the regular expression is the empty set.</span>

<span class="sd">        :rtype: Boolean&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="regexp.epsilonP"><a class="viewcode-back" href="../index.html#reex.regexp.epsilonP">[docs]</a>    <span class="k">def</span> <span class="nf">epsilonP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether the regular expression is the empty word.</span>

<span class="sd">        :rtype: Boolean&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="regexp.ewp"><a class="viewcode-back" href="../index.html#reex.regexp.ewp">[docs]</a>    <span class="k">def</span> <span class="nf">ewp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether the empty word property holds for this regular expression&#39;s language.</span>

<span class="sd">    :rtype: Boolean&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="regexp.snf"><a class="viewcode-back" href="../index.html#reex.regexp.snf">[docs]</a>    <span class="k">def</span> <span class="nf">snf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hollowdot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Star Normal Form (SNF) of the regular expression.</span>

<span class="sd">        :param hollowdot:</span>
<span class="sd">        :return: regular expression in star normal form</span>

<span class="sd">        .. seealso: Brüggemann-Klein, 92&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="regexp.nfaThompson"><a class="viewcode-back" href="../index.html#reex.regexp.nfaThompson">[docs]</a>    <span class="k">def</span> <span class="nf">nfaThompson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Epsilon-NFA constructed with Thompson&#39;s method that accepts the regular expression&#39;s language.</span>

<span class="sd">        :rtype: NFA</span>

<span class="sd">        .. seealso:: K. Thompson. Regular Expression Search Algorithm. CACM 11(6), 419-422 (1968)&quot;&quot;&quot;</span>
        <span class="n">aut</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">()</span>
        <span class="n">s0</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">setInitial</span><span class="p">([</span><span class="n">s0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">aut</span><span class="o">.</span><span class="n">setSigma</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aut</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">s1</span><span class="p">])</span>  <span class="c"># val</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>  <span class="c"># &gt;(0)----&gt;((1))</span>
        <span class="k">return</span> <span class="n">aut</span>
</div>
<div class="viewcode-block" id="regexp.nfaFollowEpsilon"><a class="viewcode-back" href="../index.html#reex.regexp.nfaFollowEpsilon">[docs]</a>    <span class="k">def</span> <span class="nf">nfaFollowEpsilon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Epsilon-NFA constructed with Ilie and Yu&#39;s method () that accepts the regular expression&#39;s language.</span>

<span class="sd">        :param trim:</span>
<span class="sd">        :return: NFA possibly with epsilon transitions</span>
<span class="sd">        :rtype: NFAe</span>

<span class="sd">        .. seealso:: Ilie &amp; Yu, Follow automta, Inf. Comp. ,v. 186 (1),140-162,2003</span>
<span class="sd">        .. _a link: http://dx.doi.org/10.1016/S0890-5401(03)00090-7&quot;&quot;&quot;</span>
        <span class="n">nfa</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFAr</span><span class="p">()</span>
        <span class="n">initial</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;Initial&quot;</span><span class="p">)</span>
        <span class="n">final</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;Final&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nfaFollowEpsilonStep</span><span class="p">((</span><span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="p">[]))</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> \
                <span class="nb">len</span><span class="p">(</span><span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">initial</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Epsilon</span><span class="p">,</span> <span class="p">[]))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_initial</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">initial</span><span class="p">][</span><span class="n">Epsilon</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">del</span> <span class="p">(</span><span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">initial</span><span class="p">])</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">deltaReverse</span><span class="p">[</span><span class="n">new_initial</span><span class="p">][</span><span class="n">Epsilon</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
            <span class="n">initial</span> <span class="o">=</span> <span class="n">new_initial</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">setInitial</span><span class="p">([</span><span class="n">initial</span><span class="p">])</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">final</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">trim</span><span class="p">:</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">nfa</span>
</div>
    <span class="k">def</span> <span class="nf">_nfaFollowEpsilonStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construction step of the Epsilon-NFA defined by Ilie &amp; Yu for this class.</span>

<span class="sd">        :param conditions: A tuple consisting of an NFA, the initial state, and the final state in the context. A</span>
<span class="sd">        sub-automaton within the given automaton is thus constructed.&quot;&quot;&quot;</span>
        <span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">conditions</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">addSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>

<div class="viewcode-block" id="regexp.nfaGlushkov"><a class="viewcode-back" href="../index.html#reex.regexp.nfaGlushkov">[docs]</a>    <span class="k">def</span> <span class="nf">nfaGlushkov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Position or Glushkov automaton of the regular expression. Recursive method.</span>


<span class="sd">        :return: NFA</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nfa</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">()</span>
        <span class="n">initial</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;Initial&quot;</span><span class="p">)</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nfaGlushkovStep</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span> <span class="n">nfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">Final</span> <span class="o">=</span> <span class="n">final</span>
        <span class="k">return</span> <span class="n">nfa</span>
</div>
    <span class="k">def</span> <span class="nf">_nfaGlushkovStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param nfa:</span>
<span class="sd">        :param initial:</span>
<span class="sd">        :param final:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">DuplicateName</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
            <span class="c"># target = nfa.stateIndex(self.val)</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">initial</span><span class="p">:</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">final</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span>

<div class="viewcode-block" id="regexp.nfaNaiveFollow"><a class="viewcode-back" href="../index.html#reex.regexp.nfaNaiveFollow">[docs]</a>    <span class="k">def</span> <span class="nf">nfaNaiveFollow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NFA that accepts the regular expression&#39;s language, and is equal in structure to the follow automaton.</span>

<span class="sd">        :rtype: NFA</span>

<span class="sd">        .. note:: Included for testing purposes.</span>

<span class="sd">        .. seealso:: Ilie &amp; Yu (Follow Automata, 2003)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">snf</span><span class="p">()</span><span class="o">.</span><span class="n">marked</span><span class="p">()</span><span class="o">.</span><span class="n">nfaGlushkov</span><span class="p">()</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span><span class="o">.</span><span class="n">unmark</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="regexp.nfaFollow"><a class="viewcode-back" href="../index.html#reex.regexp.nfaFollow">[docs]</a>    <span class="k">def</span> <span class="nf">nfaFollow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NFA that accepts the regular expression&#39;s language, whose structure, and construction.</span>

<span class="sd">        :rtype: NFA</span>

<span class="sd">        .. seealso:: Ilie &amp; Yu (Follow Automata, 03)&quot;&quot;&quot;</span>
        <span class="n">nfa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfaFollowEpsilon</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">nfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="n">inverse_topo_order</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nfa</span><span class="o">.</span><span class="n">Initial</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">nfa</span><span class="o">.</span><span class="n">hasTransitionP</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">):</span>
                <span class="n">inverse_topo_order</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inverse_topo_order</span><span class="p">:</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">closeEpsilon</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">nfa</span>
</div>
<div class="viewcode-block" id="regexp.nfaPD"><a class="viewcode-back" href="../index.html#reex.regexp.nfaPD">[docs]</a>    <span class="k">def</span> <span class="nf">nfaPD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NFA that accepts the regular expression&#39;s language,</span>
<span class="sd">           and which is constructed from the expression&#39;s partial derivatives.</span>

<span class="sd">        :return: partial derivatives [or equation] automaton</span>
<span class="sd">        :rtype: NFA</span>

<span class="sd">        .. seealso:: V. M. Antimirov, Partial Derivatives of Regular Expressions and Finite Automaton Constructions</span>
<span class="sd">           .Theor. Comput. Sci.155(2): 291-319 (1996)&quot;&quot;&quot;</span>
        <span class="n">nfa</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
        <span class="n">added_states</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">state</span><span class="p">,</span> <span class="n">state_idx</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">state_lf</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">linearForm</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">state_lf</span><span class="p">:</span>
                <span class="n">tails</span> <span class="o">=</span> <span class="n">state_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span>
                <span class="n">nfa</span><span class="o">.</span><span class="n">addSigma</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">pd</span> <span class="ow">in</span> <span class="n">tails</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pd</span> <span class="ow">in</span> <span class="n">added_states</span><span class="p">:</span>
                        <span class="n">pd_idx</span> <span class="o">=</span> <span class="n">added_states</span><span class="p">[</span><span class="n">pd</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">pd_idx</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span>
                        <span class="k">except</span> <span class="n">DuplicateName</span><span class="p">:</span>
                            <span class="n">pd_idx</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span>
                        <span class="n">added_states</span><span class="p">[</span><span class="n">pd</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd_idx</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pd</span><span class="p">,</span> <span class="n">pd_idx</span><span class="p">))</span>
                    <span class="n">nfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">state_idx</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">pd_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
                <span class="n">nfa</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">state_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nfa</span>
</div>
<div class="viewcode-block" id="regexp.nfaPDO"><a class="viewcode-back" href="../index.html#reex.regexp.nfaPDO">[docs]</a>    <span class="k">def</span> <span class="nf">nfaPDO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NFA that accepts the regular expression&#39;s language, and which is constructed from the expression&#39;s partial</span>
<span class="sd">         derivatives.</span>

<span class="sd">        .. note:: optimized version</span>

<span class="sd">        :return: partial derivatives [or equation] automaton</span>
<span class="sd">        :rtype: NFA&quot;&quot;&quot;</span>
        <span class="n">nfa</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
        <span class="n">added_states</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">state</span><span class="p">,</span> <span class="n">state_idx</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_memoLF</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">_lf</span><span class="p">:</span>
                <span class="n">nfa</span><span class="o">.</span><span class="n">addSigma</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">pd</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">pd</span> <span class="ow">in</span> <span class="n">added_states</span><span class="p">:</span>
                        <span class="n">pd_idx</span> <span class="o">=</span> <span class="n">added_states</span><span class="p">[</span><span class="n">pd</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pd_idx</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span>
                        <span class="n">added_states</span><span class="p">[</span><span class="n">pd</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd_idx</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pd</span><span class="p">,</span> <span class="n">pd_idx</span><span class="p">))</span>
                    <span class="n">nfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">state_idx</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">pd_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
                <span class="n">nfa</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">state_idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delAttr</span><span class="p">(</span><span class="s">&quot;_lf&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nfa</span>
</div>
<div class="viewcode-block" id="regexp.nfaPosition"><a class="viewcode-back" href="../index.html#reex.regexp.nfaPosition">[docs]</a>    <span class="k">def</span> <span class="nf">nfaPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lstar</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Position automaton of the regular expression.</span>

<span class="sd">        :arg lstar: if not None followlists are computed dijunct</span>
<span class="sd">        :type lstar: boolean</span>
<span class="sd">        :return: position NFA</span>
<span class="sd">        :rtype: NFA</span>

<span class="sd">        .. seealso:  Glushkov, 61&quot;&quot;&quot;</span>
        <span class="n">nfa</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">()</span>
        <span class="n">initial</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;Initial&quot;</span><span class="p">)</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">addInitial</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">marked</span><span class="p">()</span><span class="o">.</span><span class="n">_faPosition</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">lstar</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="regexp.dfaPosition"><a class="viewcode-back" href="../index.html#reex.regexp.dfaPosition">[docs]</a>    <span class="k">def</span> <span class="nf">dfaPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deterministic position automaton of a regular expression.</span>

<span class="sd">        :return: position DFA</span>
<span class="sd">        :rtype: DFA</span>

<span class="sd">        :raise common.DFAnotNFAFAdo: if not DFA</span>

<span class="sd">        .. note:: If this expression is not linear (cf. linearP()), exception may be raised</span>
<span class="sd">                  on non-deterministic transitions.</span>

<span class="sd">        .. seealso:  Glushkov, 61&quot;&quot;&quot;</span>
        <span class="n">dfa</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">DFA</span><span class="p">()</span>
        <span class="n">initial</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="s">&quot;Initial&quot;</span><span class="p">)</span>
        <span class="n">dfa</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dfa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">marked</span><span class="p">()</span><span class="o">.</span><span class="n">_faPosition</span><span class="p">(</span><span class="n">dfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_faPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aut</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">lstar</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
            <span class="n">aut</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">added_states</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">state_idx</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sym</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">DuplicateName</span><span class="p">:</span>
                <span class="n">state_idx</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sym</span><span class="p">))</span>
            <span class="n">added_states</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_idx</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sym</span><span class="p">,</span> <span class="n">state_idx</span><span class="p">))</span>
            <span class="n">aut</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbol</span><span class="p">(),</span> <span class="n">state_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lstar</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">follow_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">followLists</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">follow_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">followListsD</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">state</span><span class="p">,</span> <span class="n">state_idx</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">follow_sets</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">added_states</span><span class="p">:</span>
                    <span class="n">next_state_idx</span> <span class="o">=</span> <span class="n">added_states</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">next_state_idx</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sym</span><span class="p">))</span>
                    <span class="n">added_states</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_state_idx</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sym</span><span class="p">,</span> <span class="n">next_state_idx</span><span class="p">))</span>
                <span class="n">aut</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">state_idx</span><span class="p">,</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbol</span><span class="p">(),</span> <span class="n">next_state_idx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">last</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">added_states</span><span class="p">:</span>
                <span class="n">aut</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">added_states</span><span class="p">[</span><span class="n">sym</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">aut</span>

<div class="viewcode-block" id="regexp.nfaPSNF"><a class="viewcode-back" href="../index.html#reex.regexp.nfaPSNF">[docs]</a>    <span class="k">def</span> <span class="nf">nfaPSNF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Position or Glushkov automaton of the regular expression constructed from the expression&#39;s star normal form.</span>

<span class="sd">        :return: position automaton</span>
<span class="sd">        :rtype: NFA</span>

<span class="sd">        .. seeall: Brüggemann-Klein, 92&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">snf</span><span class="p">()</span><span class="o">.</span><span class="n">nfaPosition</span><span class="p">(</span><span class="n">lstar</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_dfaD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Word derivatives automaton of the regular expression</span>

<span class="sd">        :return: word derivatives automaton</span>
<span class="sd">        :rtype: DFA</span>

<span class="sd">        .. attention:</span>
<span class="sd">             This is a probably non terminating method. Must be removed. (nam)</span>
<span class="sd">        .. seealso:</span>
<span class="sd">            J. A. Brzozowski, Derivatives of Regular Expressions. J. ACM 11(4): 481-494 (1964)&quot;&quot;&quot;</span>
        <span class="n">dfa</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">DFA</span><span class="p">()</span>
        <span class="n">initial</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">initial_idx</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
        <span class="n">dfa</span><span class="o">.</span><span class="n">setInitial</span><span class="p">(</span><span class="n">initial_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dfa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">dfa</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">initial</span><span class="o">.</span><span class="n">setOfSymbols</span><span class="p">())</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">initial</span><span class="p">,</span> <span class="n">initial_idx</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">state</span><span class="p">,</span> <span class="n">state_idx</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">dfa</span><span class="o">.</span><span class="n">Sigma</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dfa</span><span class="o">.</span><span class="n">States</span><span class="p">:</span>
                    <span class="n">d_idx</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">d_idx</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d_idx</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">.</span><span class="n">stateIndex</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">dfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">state_idx</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">d_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
                <span class="n">dfa</span><span class="o">.</span><span class="n">addFinal</span><span class="p">(</span><span class="n">state_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dfa</span>

<div class="viewcode-block" id="regexp.toNFA"><a class="viewcode-back" href="../index.html#reex.regexp.toNFA">[docs]</a>    <span class="k">def</span> <span class="nf">toNFA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nfa_method</span><span class="o">=</span><span class="s">&quot;nfaPD&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NFA that accepts the regular expression&#39;s language.</span>
<span class="sd">        :param nfa_method: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="n">nfa_method</span><span class="p">)()</span>
</div>
<div class="viewcode-block" id="regexp.toDFA"><a class="viewcode-back" href="../index.html#reex.regexp.toDFA">[docs]</a>    <span class="k">def</span> <span class="nf">toDFA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;DFA that accepts the regular expression&#39;s language</span>

<span class="sd">        .. versionadded 0.9.6&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toNFA</span><span class="p">()</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="regexp.compare"><a class="viewcode-back" href="../index.html#reex.regexp.compare">[docs]</a>    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cmp_method</span><span class="o">=</span><span class="s">&quot;compareMinimalDFA&quot;</span><span class="p">,</span> <span class="n">nfa_method</span><span class="o">=</span><span class="s">&quot;nfaPosition&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare with another regular expression for equivalence.</span>
<span class="sd">        :param r:</span>
<span class="sd">        :param cmp_method:</span>
<span class="sd">        :param nfa_method:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cmp_method</span> <span class="o">==</span> <span class="s">&quot;compareMinimalDFA&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compareMinimalDFA</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">nfa_method</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="regexp.equivalentP"><a class="viewcode-back" href="../index.html#reex.regexp.equivalentP">[docs]</a>    <span class="k">def</span> <span class="nf">equivalentP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests equivalence</span>

<span class="sd">        :param other:</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        .. versionadded: 0.9.6&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">fa</span><span class="o">.</span><span class="n">OFA</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">equivalentP</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="regexp.compareMinimalDFA"><a class="viewcode-back" href="../index.html#reex.regexp.compareMinimalDFA">[docs]</a>    <span class="k">def</span> <span class="nf">compareMinimalDFA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">nfa_method</span><span class="o">=</span><span class="s">&quot;nfaPosition&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare with another regular expression for equivalence through minimal DFAs.</span>
<span class="sd">        :param r:</span>
<span class="sd">        :param nfa_method: &quot;&quot;&quot;</span>
        <span class="n">fa0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toNFA</span><span class="p">(</span><span class="n">nfa_method</span><span class="p">)</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span>
        <span class="n">fa1</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">toNFA</span><span class="p">(</span><span class="n">nfa_method</span><span class="p">)</span><span class="o">.</span><span class="n">toDFA</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fa0</span> <span class="o">==</span> <span class="n">fa1</span>
</div>
<div class="viewcode-block" id="regexp.evalWordP"><a class="viewcode-back" href="../index.html#reex.regexp.evalWordP">[docs]</a>    <span class="k">def</span> <span class="nf">evalWordP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verifies if a word is a member of the language represented by the regular expression.</span>

<span class="sd">        :param str word: the word</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordDerivative</span><span class="p">(</span><span class="n">word</span><span class="p">)</span><span class="o">.</span><span class="n">ewp</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="regexp.reversal"><a class="viewcode-back" href="../index.html#reex.regexp.reversal">[docs]</a>    <span class="k">def</span> <span class="nf">reversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reversal of regexp</span>

<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>

</div></div>
<div class="viewcode-block" id="specialConstant"><a class="viewcode-back" href="../index.html#reex.specialConstant">[docs]</a><span class="k">class</span> <span class="nc">specialConstant</span><span class="p">(</span><span class="n">regexp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for Epsilon and EmptySet</span>

<span class="sd">    .. inheritance-diagram:: specialConstant&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param sigma: &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">sigma</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="specialConstant.setOfSymbols"><a class="viewcode-back" href="../index.html#reex.specialConstant.setOfSymbols">[docs]</a>    <span class="k">def</span> <span class="nf">setOfSymbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="specialConstant.alphabeticLength"><a class="viewcode-back" href="../index.html#reex.specialConstant.alphabeticLength">[docs]</a>    <span class="k">def</span> <span class="nf">alphabeticLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>
</div>
    <span class="k">def</span> <span class="nf">_marked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param pos:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pos</span>

<div class="viewcode-block" id="specialConstant.unmarked"><a class="viewcode-back" href="../index.html#reex.specialConstant.unmarked">[docs]</a>    <span class="k">def</span> <span class="nf">unmarked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The unmarked form of the regular expression. Each leaf in its syntactical tree becomes a regexp(),</span>
<span class="sd">        the epsilon() or the emptyset().</span>

<span class="sd">        :rtype: (general) regular expression&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="specialConstant.first"><a class="viewcode-back" href="../index.html#reex.specialConstant.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_first</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param parent_first:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parent_first</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">parent_first</span>
</div>
<div class="viewcode-block" id="specialConstant.last"><a class="viewcode-back" href="../index.html#reex.specialConstant.last">[docs]</a>    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_last</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param parent_last:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parent_last</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">parent_last</span>
</div>
<div class="viewcode-block" id="specialConstant.followLists"><a class="viewcode-back" href="../index.html#reex.specialConstant.followLists">[docs]</a>    <span class="k">def</span> <span class="nf">followLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param lists:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="n">lists</span>
</div>
<div class="viewcode-block" id="specialConstant.followListsD"><a class="viewcode-back" href="../index.html#reex.specialConstant.followListsD">[docs]</a>    <span class="k">def</span> <span class="nf">followListsD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param lists:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="n">lists</span>
</div>
<div class="viewcode-block" id="specialConstant.followListsStar"><a class="viewcode-back" href="../index.html#reex.specialConstant.followListsStar">[docs]</a>    <span class="k">def</span> <span class="nf">followListsStar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param lists:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="n">lists</span>
</div>
<div class="viewcode-block" id="specialConstant.derivative"><a class="viewcode-back" href="../index.html#reex.specialConstant.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param sigma:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">emptyset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="specialConstant.wordDerivative"><a class="viewcode-back" href="../index.html#reex.specialConstant.wordDerivative">[docs]</a>    <span class="k">def</span> <span class="nf">wordDerivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param word:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="specialConstant.linearForm"><a class="viewcode-back" href="../index.html#reex.specialConstant.linearForm">[docs]</a>    <span class="k">def</span> <span class="nf">linearForm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span>
</div>
    <span class="k">def</span> <span class="nf">_memoLF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span>

    <span class="k">def</span> <span class="nf">_delAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param attr:</span>
<span class="sd">        :return:&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="n">_lf</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="specialConstant.support"><a class="viewcode-back" href="../index.html#reex.specialConstant.support">[docs]</a>    <span class="k">def</span> <span class="nf">support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return:&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="specialConstant.reversal"><a class="viewcode-back" href="../index.html#reex.specialConstant.reversal">[docs]</a>    <span class="k">def</span> <span class="nf">reversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reversal of regexp</span>

<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>

</div></div>
<div class="viewcode-block" id="epsilon"><a class="viewcode-back" href="../index.html#reex.epsilon">[docs]</a><span class="k">class</span> <span class="nc">epsilon</span><span class="p">(</span><span class="n">specialConstant</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class that represents the empty word.</span>

<span class="sd">    .. inheritance-diagram:: epsilon&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;epsilon()&quot;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Epsilon</span>

    <span class="n">_strP</span> <span class="o">=</span> <span class="n">__str__</span>

<div class="viewcode-block" id="epsilon.rpn"><a class="viewcode-back" href="../index.html#reex.epsilon.rpn">[docs]</a>    <span class="k">def</span> <span class="nf">rpn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Epsilon</span>
</div>
    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">Epsilon</span><span class="p">)</span>

<div class="viewcode-block" id="epsilon.epsilonP"><a class="viewcode-back" href="../index.html#reex.epsilon.epsilonP">[docs]</a>    <span class="k">def</span> <span class="nf">epsilonP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="epsilon.measure"><a class="viewcode-back" href="../index.html#reex.epsilon.measure">[docs]</a>    <span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param from_parent:</span>
<span class="sd">        :return: measures&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">from_parent</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">from_parent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">from_parent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">from_parent</span>
</div>
<div class="viewcode-block" id="epsilon.epsilonLength"><a class="viewcode-back" href="../index.html#reex.epsilon.epsilonLength">[docs]</a>    <span class="k">def</span> <span class="nf">epsilonLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: int &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>
</div>
<div class="viewcode-block" id="epsilon.ewp"><a class="viewcode-back" href="../index.html#reex.epsilon.ewp">[docs]</a>    <span class="k">def</span> <span class="nf">ewp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: bool&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="epsilon.nfaThompson"><a class="viewcode-back" href="../index.html#reex.epsilon.nfaThompson">[docs]</a>    <span class="k">def</span> <span class="nf">nfaThompson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :rtype: NFA &quot;&quot;&quot;</span>
        <span class="n">aut</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">()</span>
        <span class="n">s0</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">setInitial</span><span class="p">([</span><span class="n">s0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">aut</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aut</span><span class="o">.</span><span class="n">setSigma</span><span class="p">([])</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">s1</span><span class="p">])</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aut</span>
</div>
    <span class="k">def</span> <span class="nf">_nfaGlushkovStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param nfa:</span>
<span class="sd">        :param initial:</span>
<span class="sd">        :param final:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="n">final</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span>

    <span class="k">def</span> <span class="nf">_nfaFollowEpsilonStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param conditions:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">conditions</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>

<div class="viewcode-block" id="epsilon.snf"><a class="viewcode-back" href="../index.html#reex.epsilon.snf">[docs]</a>    <span class="k">def</span> <span class="nf">snf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_hollowdot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param _hollowdot:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_hollowdot</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">emptyset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="epsilon.partialDerivatives"><a class="viewcode-back" href="../index.html#reex.epsilon.partialDerivatives">[docs]</a>    <span class="k">def</span> <span class="nf">partialDerivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param sigma:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>

</div></div>
<div class="viewcode-block" id="emptyset"><a class="viewcode-back" href="../index.html#reex.emptyset">[docs]</a><span class="k">class</span> <span class="nc">emptyset</span><span class="p">(</span><span class="n">specialConstant</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class that represents the empty set.</span>

<span class="sd">    .. inheritance-diagram:: emptyset&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;emptyset()&quot;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EmptySet</span>

<div class="viewcode-block" id="emptyset.rpn"><a class="viewcode-back" href="../index.html#reex.emptyset.rpn">[docs]</a>    <span class="k">def</span> <span class="nf">rpn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EmptySet</span>
</div>
    <span class="n">_strP</span> <span class="o">=</span> <span class="n">__str__</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">EmptySet</span><span class="p">)</span>

<div class="viewcode-block" id="emptyset.emptyP"><a class="viewcode-back" href="../index.html#reex.emptyset.emptyP">[docs]</a>    <span class="k">def</span> <span class="nf">emptyP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="emptyset.epsilonP"><a class="viewcode-back" href="../index.html#reex.emptyset.epsilonP">[docs]</a>    <span class="k">def</span> <span class="nf">epsilonP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="emptyset.measure"><a class="viewcode-back" href="../index.html#reex.emptyset.measure">[docs]</a>    <span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param from_parent:</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">from_parent</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">from_parent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">from_parent</span>
</div>
<div class="viewcode-block" id="emptyset.epsilonLength"><a class="viewcode-back" href="../index.html#reex.emptyset.epsilonLength">[docs]</a>    <span class="k">def</span> <span class="nf">epsilonLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span>
</div>
<div class="viewcode-block" id="emptyset.ewp"><a class="viewcode-back" href="../index.html#reex.emptyset.ewp">[docs]</a>    <span class="k">def</span> <span class="nf">ewp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
    <span class="k">def</span> <span class="nf">nfaThompson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">aut</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">()</span>
        <span class="n">s0</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">setInitial</span><span class="p">([</span><span class="n">s0</span><span class="p">])</span>
        <span class="n">aut</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">s1</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">aut</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aut</span>

    <span class="k">def</span> <span class="nf">_nfaGlushkovStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span>

    <span class="k">def</span> <span class="nf">_nfaFollowEpsilonStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditions</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">snf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_hollowdot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">partialDerivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="connective"><a class="viewcode-back" href="../index.html#reex.connective">[docs]</a><span class="k">class</span> <span class="nc">connective</span><span class="p">(</span><span class="n">regexp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for concatenation, and disjunction operations.</span>

<span class="sd">    .. inheritance-diagram:: connective&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span> <span class="o">=</span> <span class="n">arg1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span> <span class="o">=</span> <span class="n">arg2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">sigma</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">(</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                              <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">__copy__</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">__copy__</span><span class="p">(),</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_setSigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unmarked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">unmarked</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">unmarked</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_marked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">pos1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_marked</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">pos2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_marked</span><span class="p">(</span><span class="n">pos1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">),</span> <span class="n">pos2</span>

    <span class="k">def</span> <span class="nf">setOfSymbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">setOS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">setOfSymbols</span><span class="p">()</span>
        <span class="n">setOS</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">setOfSymbols</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">setOS</span>

    <span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">from_parent</span><span class="p">:</span>
            <span class="n">from_parent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">measure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">from_parent</span><span class="p">)</span>
        <span class="n">starh</span><span class="p">,</span> <span class="n">measure</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">measure</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0</span>
        <span class="n">measure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">measure</span><span class="p">)</span>
        <span class="n">measure</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">measure</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">measure</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">starh</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">measure</span>

    <span class="k">def</span> <span class="nf">alphabeticLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">alphabeticLength</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">alphabeticLength</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">treeLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">treeLength</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">treeLength</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">epsilonLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">epsilonLength</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">epsilonLength</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">starHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">starHeight</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">starHeight</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the pairs lastxfirst and firstxlast of the arguments</span>

<span class="sd">        :param lists:</span>
<span class="sd">        :return: pairs as a dictionary</span>
<span class="sd">        :rtype: dictionary&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">last</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">:</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">last</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">:</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">lists</span>

</div>
<div class="viewcode-block" id="disj"><a class="viewcode-back" href="../index.html#reex.disj">[docs]</a><span class="k">class</span> <span class="nc">disj</span><span class="p">(</span><span class="n">connective</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for disjuction operation on regular expressions.</span>

<span class="sd">    .. inheritance-diagram:: disj&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> + </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_strP</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_strP</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_strP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;(</span><span class="si">%s</span><span class="s"> + </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_strP</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_strP</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">rpn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;+</span><span class="si">%s%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">rpn</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">rpn</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">ewp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">ewp</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">ewp</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_first</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">parent_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="n">parent_first</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="n">parent_first</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_last</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">parent_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">parent_last</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">parent_last</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">followLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">lists</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">followLists</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">followLists</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">followListsD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">lists</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">followListsD</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">followListsD</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">followListsStar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">lists</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">followListsStar</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">followListsStar</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cross</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reduced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hasEpsilon</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">reduced</span><span class="p">(</span><span class="n">hasEpsilon</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">ewp</span><span class="p">())</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">reduced</span><span class="p">(</span><span class="n">hasEpsilon</span> <span class="ow">or</span> <span class="n">left</span><span class="o">.</span><span class="n">ewp</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">emptyP</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">right</span>
        <span class="k">if</span> <span class="n">right</span><span class="o">.</span><span class="n">emptyP</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">left</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">hasEpsilon</span> <span class="ow">or</span> <span class="n">right</span><span class="o">.</span><span class="n">ewp</span><span class="p">()):</span>
            <span class="k">return</span> <span class="n">right</span>
        <span class="k">if</span> <span class="n">right</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">hasEpsilon</span> <span class="ow">or</span> <span class="n">left</span><span class="o">.</span><span class="n">ewp</span><span class="p">()):</span>
            <span class="k">return</span> <span class="n">left</span>
        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">and</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">reduced</span> <span class="o">=</span> <span class="n">disj</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">reduced</span><span class="o">.</span><span class="n">_reduced</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">reduced</span>

    <span class="n">_reducedS</span> <span class="o">=</span> <span class="n">reduced</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">disj</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">partialDerivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="n">pdset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">partialDerivatives</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">pdset</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">partialDerivatives</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pdset</span>

    <span class="k">def</span> <span class="nf">linearForm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arg1_lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">linearForm</span><span class="p">()</span>
        <span class="n">arg2_lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">linearForm</span><span class="p">()</span>
        <span class="n">lf</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">arg1_lf</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">+</span> <span class="n">arg2_lf</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">tails</span> <span class="o">=</span> <span class="n">arg1_lf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span> <span class="o">|</span> <span class="n">arg2_lf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">tails</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">():</span>
                <span class="n">lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="n">tails</span>
        <span class="k">return</span> <span class="n">lf</span>

    <span class="k">def</span> <span class="nf">_delAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_delAttr</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_delAttr</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_memoLF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_lf&quot;</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_memoLF</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_memoLF</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_lf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_lf</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">snf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hollowdot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">disj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">snf</span><span class="p">(</span><span class="n">hollowdot</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">snf</span><span class="p">(</span><span class="n">hollowdot</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>

<div class="viewcode-block" id="disj.nfaThompson"><a class="viewcode-back" href="../index.html#reex.disj.nfaThompson">[docs]</a>    <span class="k">def</span> <span class="nf">nfaThompson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns an NFA (Thompson) that accepts the RE.</span>

<span class="sd">    :rtype: NFA</span>

<span class="sd">    .. graphviz::</span>

<span class="sd">       digraph dij {</span>
<span class="sd">        &quot;0&quot; -&gt; &quot;si1&quot; [label=e];</span>
<span class="sd">        &quot;si1&quot; -&gt; &quot;sf1&quot; [label=&quot;arg1&quot;];</span>
<span class="sd">        &quot;sf1&quot; -&gt; &quot;1&quot; [label=e];</span>
<span class="sd">        &quot;0&quot; -&gt; &quot;si2&quot; [label=e];</span>
<span class="sd">        &quot;si2&quot; -&gt; &quot;sf2&quot; [label=&quot;arg2&quot;];</span>
<span class="sd">        &quot;sf2&quot; -&gt; &quot;1&quot; [label=e];</span>
<span class="sd">        }&quot;&quot;&quot;</span>
        <span class="n">au</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">au</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">addState</span><span class="p">(),</span> <span class="n">au</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="n">au</span><span class="o">.</span><span class="n">setInitial</span><span class="p">([</span><span class="n">s0</span><span class="p">])</span>
        <span class="n">au</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">s1</span><span class="p">])</span>
        <span class="n">si1</span><span class="p">,</span> <span class="n">sf1</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">_inc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">nfaThompson</span><span class="p">())</span>
        <span class="n">au</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">si1</span><span class="p">)</span>
        <span class="n">au</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">sf1</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
        <span class="n">si2</span><span class="p">,</span> <span class="n">sf2</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">_inc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">nfaThompson</span><span class="p">())</span>
        <span class="n">au</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">si2</span><span class="p">)</span>
        <span class="n">au</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">sf2</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">au</span>
</div>
    <span class="k">def</span> <span class="nf">_nfaGlushkovStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">newFinal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_nfaGlushkovStep</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">final</span><span class="p">))</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_nfaGlushkovStep</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="n">final</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">newFinal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span>

    <span class="k">def</span> <span class="nf">_nfaFollowEpsilonStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditions</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_nfaFollowEpsilonStep</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_nfaFollowEpsilonStep</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span>

<div class="viewcode-block" id="disj.reversal"><a class="viewcode-back" href="../index.html#reex.disj.reversal">[docs]</a>    <span class="k">def</span> <span class="nf">reversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reversal of regexp</span>
<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">disj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">reversal</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">reversal</span><span class="p">(),</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
</div></div>
<span class="k">class</span> <span class="nc">power</span><span class="p">(</span><span class="n">regexp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for power operation  on regular expressions.</span>

<span class="sd">    .. inheritance-diagram:: power&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pw</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">sigma</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">^(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">_strP</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pw</span><span class="p">)</span>

    <span class="n">_strP</span> <span class="o">=</span> <span class="n">__str__</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;power(</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pw</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">setOfSymbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">setOfSymbols</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Reversal of regexp</span>
<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">reversal</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>


<div class="viewcode-block" id="star"><a class="viewcode-back" href="../index.html#reex.star">[docs]</a><span class="k">class</span> <span class="nc">star</span><span class="p">(</span><span class="n">regexp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for iteration operation (aka Kleene star, or Kleene closure) on regular expressions.</span>

<span class="sd">    .. inheritance-diagram:: star&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">sigma</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">*&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">_strP</span><span class="p">()</span>

    <span class="n">_strP</span> <span class="o">=</span> <span class="n">__str__</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;star(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">star</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">),</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rpn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;*</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">rpn</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">setOfSymbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">setOfSymbols</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setSigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">from_parent</span><span class="p">:</span> <span class="n">from_parent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">measure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">from_parent</span><span class="p">)</span>
        <span class="n">measure</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">measure</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">measure</span>

    <span class="k">def</span> <span class="nf">alphabeticLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">alphabeticLength</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">treeLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">treeLength</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">epsilonLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">epsilonLength</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">starHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">starHeight</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_first</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="n">parent_first</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_first</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">parent_first</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">followLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">followLists</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">last</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">:</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">lists</span>

    <span class="k">def</span> <span class="nf">followListsD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">followListsStar</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">followListsStar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">followListsStar</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unmarked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">star</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">unmarked</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_marked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">pos1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">_marked</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">star</span><span class="p">(</span><span class="n">r1</span><span class="p">),</span> <span class="n">pos1</span>

    <span class="k">def</span> <span class="nf">reduced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hasEpsilon</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="n">rarg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">_reducedS</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rarg</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">()</span> <span class="ow">or</span> <span class="n">rarg</span><span class="o">.</span><span class="n">emptyP</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">epsilon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span> <span class="ow">is</span> <span class="n">rarg</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">reduced</span> <span class="o">=</span> <span class="n">star</span><span class="p">(</span><span class="n">rarg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reduced</span>

    <span class="c"># noinspection PyUnusedLocal</span>
    <span class="k">def</span> <span class="nf">_reducedS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hasEpsilon</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">_reducedS</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">concat</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">partialDerivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="n">arg_pdset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">partialDerivatives</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">pds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pd</span> <span class="ow">in</span> <span class="n">arg_pdset</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">emptyP</span><span class="p">():</span>
                <span class="n">pds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">emptyset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
                <span class="n">pds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">concat</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pds</span>

    <span class="k">def</span> <span class="nf">linearForm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arg_lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">linearForm</span><span class="p">()</span>
        <span class="n">lf</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">arg_lf</span><span class="p">:</span>
            <span class="n">lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">tail</span> <span class="ow">in</span> <span class="n">arg_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tail</span><span class="o">.</span><span class="n">emptyP</span><span class="p">():</span>
                    <span class="n">lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">emptyset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">tail</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
                    <span class="n">lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">concat</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">lf</span>

    <span class="k">def</span> <span class="nf">_delAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">_delAttr</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_memoLF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_lf&quot;</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">_memoLF</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">_lf</span><span class="p">:</span>
            <span class="n">pd_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd_set</span>
            <span class="k">for</span> <span class="n">tail</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tail</span><span class="o">.</span><span class="n">emptyP</span><span class="p">():</span>
                    <span class="n">pd_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">emptyset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">tail</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
                    <span class="n">pd_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pd_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">concat</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">ewp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">snf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_hollowdot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_hollowdot</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">snf</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">star</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">snf</span><span class="p">(</span><span class="bp">True</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>

<div class="viewcode-block" id="star.nfaThompson"><a class="viewcode-back" href="../index.html#reex.star.nfaThompson">[docs]</a>    <span class="k">def</span> <span class="nf">nfaThompson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a NFA that accepts the RE.</span>

<span class="sd">    :rtype: NFA</span>

<span class="sd">    .. graphviz::</span>

<span class="sd">       digraph foo {</span>
<span class="sd">        &quot;0&quot; -&gt; &quot;1&quot; [label=e];</span>
<span class="sd">        &quot;0&quot; -&gt; &quot;a&quot; [label=e];</span>
<span class="sd">        &quot;a&quot; -&gt; &quot;b&quot; [label=A];</span>
<span class="sd">        &quot;b&quot; -&gt; &quot;1&quot; [label=e];</span>
<span class="sd">        &quot;1&quot; -&gt; &quot;0&quot; [label=e];</span>
<span class="sd">        }&quot;&quot;&quot;</span>

        <span class="n">sun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">nfaThompson</span><span class="p">()</span>
        <span class="n">au</span> <span class="o">=</span> <span class="n">sun</span><span class="o">.</span><span class="n">dup</span><span class="p">()</span>
        <span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">au</span><span class="o">.</span><span class="n">addState</span><span class="p">(),</span> <span class="n">au</span><span class="o">.</span><span class="n">addState</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">au</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">au_initial</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">Initial</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">au</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
        <span class="n">au</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span>
<span class="c">#        au.addTransition(list(au.Final)[0], Epsilon, au_initial)</span>
        <span class="n">au</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">au_initial</span><span class="p">)</span>
        <span class="n">au</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">au</span><span class="o">.</span><span class="n">Final</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>  <span class="c"># we know by contruction</span>
        <span class="n">au</span><span class="o">.</span><span class="n">setInitial</span><span class="p">([</span><span class="n">s0</span><span class="p">])</span>  <span class="c"># that there is only one final state,</span>
        <span class="n">au</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">s1</span><span class="p">])</span>  <span class="c"># and only one initial state</span>
        <span class="k">return</span> <span class="n">au</span>
</div>
    <span class="k">def</span> <span class="nf">_nfaGlushkovStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="n">previous_trans</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i_state</span> <span class="ow">in</span> <span class="n">initial</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i_state</span> <span class="ow">in</span> <span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="n">previous_trans</span><span class="p">[</span><span class="n">i_state</span><span class="p">]</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i_state</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i_state</span><span class="p">]</span>
        <span class="n">new_initial</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">_nfaGlushkovStep</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i_state</span> <span class="ow">in</span> <span class="n">initial</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i_state</span> <span class="ow">in</span> <span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i_state</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">nfa</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="n">i_state</span><span class="p">][</span><span class="n">symbol</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">f_state</span> <span class="ow">in</span> <span class="n">final</span><span class="p">:</span>
                            <span class="n">nfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">f_state</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i_state</span> <span class="ow">in</span> <span class="n">previous_trans</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">previous_trans</span><span class="p">[</span><span class="n">i_state</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">previous_trans</span><span class="p">[</span><span class="n">i_state</span><span class="p">][</span><span class="n">sym</span><span class="p">]:</span>
                    <span class="n">nfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">i_state</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">final</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_initial</span><span class="p">,</span> <span class="n">final</span>

    <span class="k">def</span> <span class="nf">_nfaFollowEpsilonStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditions</span><span class="p">):</span>
        <span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">conditions</span>
        <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="n">final</span><span class="p">:</span>
            <span class="n">iter_state</span> <span class="o">=</span> <span class="n">final</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iter_state</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">_nfaFollowEpsilonStep</span><span class="p">((</span><span class="n">nfa</span><span class="p">,</span> <span class="n">iter_state</span><span class="p">,</span> <span class="n">iter_state</span><span class="p">))</span>
        <span class="n">tomerge</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">epsilonPaths</span><span class="p">(</span><span class="n">iter_state</span><span class="p">,</span> <span class="n">iter_state</span><span class="p">)</span>
        <span class="n">nfa</span><span class="o">.</span><span class="n">mergeStatesSet</span><span class="p">(</span><span class="n">tomerge</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">final</span><span class="p">:</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">iter_state</span><span class="p">)</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">iter_state</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>

<div class="viewcode-block" id="star.reversal"><a class="viewcode-back" href="../index.html#reex.star.reversal">[docs]</a>    <span class="k">def</span> <span class="nf">reversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reversal of regexp</span>

<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">star</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">reversal</span><span class="p">(),</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="concat"><a class="viewcode-back" href="../index.html#reex.concat">[docs]</a><span class="k">class</span> <span class="nc">concat</span><span class="p">(</span><span class="n">connective</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for catenation operation on regular expressions.</span>

<span class="sd">    .. inheritance-diagram:: concat&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_strP</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_strP</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_strP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;(</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_strP</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_strP</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">rpn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;.</span><span class="si">%s%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">rpn</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">rpn</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">ewp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">ewp</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">ewp</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_first</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="n">parent_first</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="n">parent_first</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_last</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">parent_last</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="n">parent_last</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">followLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">followLists</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">followLists</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">last</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">:</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">lists</span>

    <span class="k">def</span> <span class="nf">followListsD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">lists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">followListsD</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">followListsD</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">last</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">:</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">lists</span>

    <span class="k">def</span> <span class="nf">followListsStar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">lists</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">followListsStar</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">followListsStar</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">followListsD</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">followListsStar</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">followListsStar</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">followListsD</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">followListsD</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">followListsD</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cross</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reduced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hasEpsilon</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">reduced</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">emptyP</span><span class="p">()</span> <span class="ow">or</span> <span class="n">right</span><span class="o">.</span><span class="n">emptyP</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">emptyset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">hasEpsilon</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">reduced</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">right</span>
        <span class="k">if</span> <span class="n">right</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">hasEpsilon</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">reduced</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">left</span>
        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">and</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">reduced</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reduced</span>

    <span class="n">_reducedS</span> <span class="o">=</span> <span class="n">reduced</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">disj</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left</span>

    <span class="k">def</span> <span class="nf">partialDerivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="n">pds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">partialDerivatives</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">emptyP</span><span class="p">():</span>
                <span class="n">pds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">emptyset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
                <span class="n">pds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">concat</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
            <span class="n">pds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">partialDerivatives</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pds</span>

    <span class="k">def</span> <span class="nf">linearForm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arg1_lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">linearForm</span><span class="p">()</span>
        <span class="n">lf</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">arg1_lf</span><span class="p">:</span>
            <span class="n">lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">tail</span> <span class="ow">in</span> <span class="n">arg1_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tail</span><span class="o">.</span><span class="n">emptyP</span><span class="p">():</span>
                    <span class="n">lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">emptyset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">tail</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
                    <span class="n">lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">concat</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
            <span class="n">arg2_lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">linearForm</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">arg2_lf</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">lf</span><span class="p">:</span>
                    <span class="n">lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">arg2_lf</span><span class="p">[</span><span class="n">head</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">arg2_lf</span><span class="p">[</span><span class="n">head</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">lf</span>

    <span class="k">def</span> <span class="nf">_memoLF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_lf&quot;</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_memoLF</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_lf</span><span class="p">:</span>
            <span class="n">pd_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd_set</span>
            <span class="k">for</span> <span class="n">tail</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tail</span><span class="o">.</span><span class="n">emptyP</span><span class="p">():</span>
                    <span class="n">pd_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">emptyset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">tail</span><span class="o">.</span><span class="n">epsilonP</span><span class="p">():</span>
                    <span class="n">pd_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pd_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">concat</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_memoLF</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_lf</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">head</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_lf</span><span class="p">[</span><span class="n">head</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">snf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_hollowdot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_hollowdot</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">concat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">snf</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">snf</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">disj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">snf</span><span class="p">(</span><span class="bp">True</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">snf</span><span class="p">(</span><span class="bp">True</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">concat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">snf</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">snf</span><span class="p">(</span><span class="bp">True</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">ewp</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">concat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">snf</span><span class="p">(</span><span class="bp">True</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">snf</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">concat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">snf</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">snf</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nfaThompson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c"># &gt;(0)--arg1--&gt;(1)---&gt;(2)--arg2--&gt;((3))</span>
        <span class="n">au</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">NFA</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">au</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>
        <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">_inc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">nfaThompson</span><span class="p">())</span>
        <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">_inc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">nfaThompson</span><span class="p">())</span>
        <span class="n">au</span><span class="o">.</span><span class="n">setInitial</span><span class="p">([</span><span class="n">s0</span><span class="p">])</span>
        <span class="n">au</span><span class="o">.</span><span class="n">setFinal</span><span class="p">([</span><span class="n">s3</span><span class="p">])</span>
        <span class="n">au</span><span class="o">.</span><span class="n">addTransition</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">au</span>

    <span class="k">def</span> <span class="nf">_nfaGlushkovStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="n">initial</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_nfaGlushkovStep</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_nfaGlushkovStep</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span> <span class="n">final</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_nfaFollowEpsilonStep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditions</span><span class="p">):</span>
        <span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="n">conditions</span>
        <span class="n">interm</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">addState</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">_nfaFollowEpsilonStep</span><span class="p">((</span><span class="n">nfa</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">interm</span><span class="p">))</span>
        <span class="c"># At this stage, if the intermediate state has a single</span>
        <span class="c"># incoming transition, and it&#39;s through Epsilon, then the</span>
        <span class="c"># source becomes the new intermediate state:</span>
        <span class="n">new_interm</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">unlinkSoleIncoming</span><span class="p">(</span><span class="n">interm</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_interm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">interm</span> <span class="o">=</span> <span class="n">new_interm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">_nfaFollowEpsilonStep</span><span class="p">((</span><span class="n">nfa</span><span class="p">,</span> <span class="n">interm</span><span class="p">,</span> <span class="n">final</span><span class="p">))</span>
        <span class="c"># At this stage, if the intermediate state has a single</span>
        <span class="c"># outgoing transition, and it&#39;s through Epsilon, then we merge</span>
        <span class="c"># it with the target.</span>
        <span class="k">if</span> <span class="n">nfa</span><span class="o">.</span><span class="n">hasTransitionP</span><span class="p">(</span><span class="n">interm</span><span class="p">,</span> <span class="n">Epsilon</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">nfa</span><span class="o">.</span><span class="n">unlinkSoleOutgoing</span><span class="p">(</span><span class="n">interm</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">nfa</span><span class="o">.</span><span class="n">mergeStates</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">interm</span><span class="p">)</span>

<div class="viewcode-block" id="concat.reversal"><a class="viewcode-back" href="../index.html#reex.concat.reversal">[docs]</a>    <span class="k">def</span> <span class="nf">reversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reversal of regexp</span>
<span class="sd">        :rtype: regexp&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">concat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="o">.</span><span class="n">reversal</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="o">.</span><span class="n">reversal</span><span class="p">(),</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="position"><a class="viewcode-back" href="../index.html#reex.position">[docs]</a><span class="k">class</span> <span class="nc">position</span><span class="p">(</span><span class="n">regexp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for marked regular expression symbols.</span>

<span class="sd">    .. inheritance-diagram:: position&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">pos</span><span class="p">),</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">sigma</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;position</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">position</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setOfSymbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">unmarked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">regexp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

</div>
<span class="k">class</span> <span class="nc">ParseReg1</span><span class="p">(</span><span class="n">Yappy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    .. inheritance-diagram:: ParseReg1&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">no_table</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="s">&#39;.tablereg&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  &quot;&quot;&quot;</span>
        <span class="n">grammar</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;r&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;r&quot;</span><span class="p">,</span> <span class="s">&quot;|&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">OrSemRule</span><span class="p">),</span>
                   <span class="p">(</span><span class="s">&quot;r&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;c&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">DefaultSemRule</span><span class="p">),</span>
                   <span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ConcatSemRule</span><span class="p">),</span>
                   <span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;s&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">DefaultSemRule</span><span class="p">),</span>
                   <span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;s&quot;</span><span class="p">,</span> <span class="s">&quot;*&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">StarSemRule</span><span class="p">),</span>
                   <span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;f&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">DefaultSemRule</span><span class="p">),</span>
                   <span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">DefaultSemRule</span><span class="p">),</span>
                   <span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;(&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">,</span> <span class="s">&quot;)&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParSemRule</span><span class="p">),</span>
                   <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;id&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">BaseSemRule</span><span class="p">),</span>
                   <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">EmptySet</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">BaseSemRule</span><span class="p">),</span>
                   <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">Epsilon</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">BaseSemRule</span><span class="p">)]</span>
        <span class="n">tokenize</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;\s+&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">Epsilon</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span>
                    <span class="p">(</span><span class="n">EmptySet</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;[A-Za-z0-9]&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;\|&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;\+&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;|&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;\*&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;\(|\)&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))]</span>
        <span class="n">Yappy</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenize</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">no_table</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DefaultSemRule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lst</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">BaseSemRule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lst</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&quot;sigma&quot;</span> <span class="ow">in</span> <span class="n">context</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="s">&quot;sigma&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">Epsilon</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">epsilon</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">EmptySet</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">emptyset</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">regexp</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ParSemRule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lst</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">OrSemRule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lst</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&quot;sigma&quot;</span> <span class="ow">in</span> <span class="n">context</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="s">&quot;sigma&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">disj</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sigma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConcatSemRule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lst</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&quot;sigma&quot;</span> <span class="ow">in</span> <span class="n">context</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="s">&quot;sigma&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">concat</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StarSemRule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lst</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&quot;sigma&quot;</span> <span class="ow">in</span> <span class="n">context</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="s">&quot;sigma&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">star</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DoPrint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lst</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<div class="viewcode-block" id="ParseReg"><a class="viewcode-back" href="../index.html#reex.ParseReg">[docs]</a><span class="k">class</span> <span class="nc">ParseReg</span><span class="p">(</span><span class="n">ParseReg1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    .. inheritance-diagram:: ParseReg&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">no_table</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="s">&#39;tableambreg&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A parser for regular expressions with ambiguous rules: not working  &quot;&quot;&quot;</span>

        <span class="n">grammar</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">    reg -&gt; reg + reg {{ self.OrSemRule }} |</span>
<span class="s">         reg reg {{ self.ConcatSemRule // 200 left }} |</span>
<span class="s">         reg * {{ self.StarSemRule }} |</span>
<span class="s">         ( reg ) {{self.ParSemRule }} |</span>
<span class="s">         id {{ self.BaseSemRule }};</span>
<span class="s">    &quot;&quot;&quot;</span>

        <span class="n">tokenize</span> <span class="o">=</span> <span class="p">[(</span><span class="n">Epsilon</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span>
                    <span class="p">(</span><span class="n">EmptySet</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;[A-Za-z0-9]&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;[+|]&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;[*]&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;\(|\)&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))]</span>

        <span class="n">Yappy</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenize</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">no_table</span><span class="p">)</span>

</div>
<span class="k">class</span> <span class="nc">ParseReg2</span><span class="p">(</span><span class="n">ParseReg1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    .. inheritance-diagram:: ParseReg2&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">no_table</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="s">&#39;tableambreg2&#39;</span><span class="p">):</span>
        <span class="n">grammar</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">    reg -&gt; reg + reg {{ self.OrSemRule}}|</span>
<span class="s">         reg reg {{ self.ConcatSemRule // 200 left }} |</span>
<span class="s">         reg * {{ self.StarSemRule }} |</span>
<span class="s">         ( reg ) {{self.ParSemRule}} |</span>
<span class="s">         id {{ self.BaseSemRule }} ;</span>
<span class="s">    &quot;&quot;&quot;</span>
        <span class="n">tokenize</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;\s+&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">Epsilon</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)),</span>
                    <span class="p">(</span><span class="n">EmptySet</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;[A-Za-z0-9]&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;[+|]&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;[*]&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">&quot;\(|\)&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))]</span>

        <span class="n">Yappy</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokenize</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">no_table</span><span class="p">)</span>


<div class="viewcode-block" id="str2regexp"><a class="viewcode-back" href="../index.html#reex.str2regexp">[docs]</a><span class="k">def</span> <span class="nf">str2regexp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">ParseReg1</span><span class="p">,</span> <span class="n">no_table</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reads a regexp from string.</span>

<span class="sd">    :arg s:  the string representation of the regular expression</span>
<span class="sd">    :type s: string</span>
<span class="sd">    :arg parser: a parser generator for regexps</span>
<span class="sd">    :type parser: Yappy</span>
<span class="sd">    :arg no_table:</span>
<span class="sd">    :type no_table: integer</span>
<span class="sd">    :arg sigma: alphabet of the regular expression</span>
<span class="sd">    :type sigma: list or set of symbols</span>
<span class="sd">    :arg strict: if True tests if the symbols of the regular expression are included in the sigma</span>
<span class="sd">    :type strict: boolean</span>
<span class="sd">    :rtype: regexp&quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot;\s+&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">parser</span><span class="p">(</span><span class="n">no_table</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;sigma&quot;</span><span class="p">:</span> <span class="n">sigma</span><span class="p">})</span>
    <span class="k">except</span> <span class="n">LRParserError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">regexpInvalid</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">reg</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">strict</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">reg</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">setOfSymbols</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">reg</span>

</div>
<div class="viewcode-block" id="rpn2regexp"><a class="viewcode-back" href="../index.html#reex.rpn2regexp">[docs]</a><span class="k">def</span> <span class="nf">rpn2regexp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reads a regexp from a RPN representation</span>

<span class="sd">    .. productionlist:: Representation R</span>
<span class="sd">       R: .RR | +RR | \*R | L | @</span>
<span class="sd">       L: [a-z] | [A-Z]</span>

<span class="sd">    :param s: RPN representation</span>
<span class="sd">    :type s: string</span>
<span class="sd">    :rtype: regexp</span>

<span class="sd">    .. note:: This method uses python stack... thus depdth limitations apply&quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">=</span> <span class="n">_rpn2re</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">&quot;@epsilon&quot;</span><span class="p">,</span> <span class="s">&quot;@&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">reg</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">strict</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">reg</span><span class="o">.</span><span class="n">setSigma</span><span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">setOfSymbols</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">reg</span>

</div>
<span class="k">def</span> <span class="nf">_rpn2re</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param s:</span>
<span class="sd">    :param i:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="s">&quot;+.&quot;</span><span class="p">:</span>
        <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span> <span class="o">=</span> <span class="n">_rpn2re</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span> <span class="o">=</span> <span class="n">_rpn2re</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;.&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i2</span><span class="p">,</span> <span class="n">concat</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i2</span><span class="p">,</span> <span class="n">disj</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;*&quot;</span><span class="p">:</span>
        <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span> <span class="o">=</span> <span class="n">_rpn2re</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">i1</span><span class="p">,</span> <span class="n">star</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;@&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">regexp</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sigma</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">FAdo 1.2 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 1999-2014, Rogério Reis &amp; Nelma Moreira.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>